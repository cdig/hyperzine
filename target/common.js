// Generated by CoffeeScript 2.5.1
// node_modules/take-and-make/source/take-and-make.coffee
// Since this is typically the first bit of code included in our big compiled and
// concatenated JS files, this is a great place to demand strictness. CoffeeScript
// does not add strict on its own, but it will permit and enforce it.
"use strict";
var DebugTakeMake, Make, Take, Test, Tests,
  splice = [].splice,
  indexOf = [].indexOf;

if (!((typeof Take !== "undefined" && Take !== null) || (typeof Make !== "undefined" && Make !== null))) {
  // We declare our globals such that they're visible everywhere within the current scope.
  // This allows for namespacing — all things within a given scope share a copy of Take & Make.
  Take = null;
  Make = null;
  DebugTakeMake = null;
  (function() {
    var addListener, allNeedsAreMet, alreadyChecking, alreadyWaitingToNotify, asynchronousResolve, checkWaitingTakers, clone, made, microtasksNeeded, microtasksUsed, notify, notifyTakers, register, resolve, synchronousResolve, takersToNotify, waitingTakers;
    made = {};
    waitingTakers = [];
    takersToNotify = [];
    alreadyWaitingToNotify = false;
    alreadyChecking = false;
    microtasksNeeded = 0;
    microtasksUsed = 0;
    Make = function(name, value = name) {
      if (name == null) {
        // Debug — call Make() in the console to see what we've regstered
        return clone(made);
      }
      // Synchronous register, returns value
      return register(name, value);
    };
    Take = function(needs, callback) {
      if (needs == null) {
        // Debug — call Take() in the console to see what we're waiting for
        return waitingTakers.slice();
      }
      // Synchronous and asynchronous resolve, returns value or object of values
      return resolve(needs, callback);
    };
    // A variation of Make that defers committing the value
    Make.async = function(name, value = name) {
      return queueMicrotask(function() {
        return Make(name, value);
      });
    };
    // A variation of Take that returns a promise
    Take.async = function(needs) {
      return new Promise(function(res) {
        return Take(needs, function() {
          // Resolve the promise with a value or object of values
          return res(synchronousResolve(needs));
        });
      });
    };
    DebugTakeMake = function() {
      var base, len1, len2, m, need, output, q, ref, waiting;
      output = {
        microtasksNeeded: microtasksNeeded,
        microtasksUsed: microtasksUsed,
        unresolved: {}
      };
      for (m = 0, len1 = waitingTakers.length; m < len1; m++) {
        waiting = waitingTakers[m];
        ref = waiting.needs;
        for (q = 0, len2 = ref.length; q < len2; q++) {
          need = ref[q];
          if (made[need] == null) {
            if ((base = output.unresolved)[need] == null) {
              base[need] = 0;
            }
            output.unresolved[need]++;
          }
        }
      }
      return output;
    };
    register = function(name, value) {
      if (name === "") {
        throw new Error("You may not Make(\"\") an empty string.");
      }
      if (made[name] != null) {
        throw new Error(`You may not Make() the same name twice: ${name}`);
      }
      made[name] = value;
      checkWaitingTakers();
      return value;
    };
    checkWaitingTakers = function() {
      var index, len1, m, taker;
      if (alreadyChecking) { // Prevent recursion from Make() calls inside notify()
        return;
      }
      alreadyChecking = true;
// Depends on `waitingTakers`
// Comments below are to help reason through the (potentially) recursive behaviour
      for (index = m = 0, len1 = waitingTakers.length; m < len1; index = ++m) {
        taker = waitingTakers[index];
        if (allNeedsAreMet(taker.needs)) { // Depends on `made`
          waitingTakers.splice(index, 1); // Mutates `waitingTakers`
          notify(taker); // Calls to Make() or Take() will mutate `made` or `waitingTakers`
          alreadyChecking = false;
          return checkWaitingTakers(); // Restart: `waitingTakers` (and possibly `made`) were mutated
        }
      }
      return alreadyChecking = false;
    };
    allNeedsAreMet = function(needs) {
      return needs.every(function(name) {
        return made[name] != null;
      });
    };
    resolve = function(needs, callback) {
      if (callback != null) {
        // We always try to resolve both synchronously and asynchronously
        asynchronousResolve(needs, callback);
      }
      return synchronousResolve(needs);
    };
    asynchronousResolve = function(needs, callback) {
      var taker;
      if (needs === "") {
        needs = [];
      } else if (typeof needs === "string") {
        needs = [needs];
      }
      taker = {
        needs: needs,
        callback: callback
      };
      if (allNeedsAreMet(needs)) {
        takersToNotify.push(taker);
        microtasksNeeded++;
        if (!alreadyWaitingToNotify) {
          alreadyWaitingToNotify = true;
          queueMicrotask(notifyTakers); // Preserve asynchrony
          return microtasksUsed++;
        }
      } else {
        return waitingTakers.push(taker);
      }
    };
    synchronousResolve = function(needs) {
      var len1, m, n, o;
      if (typeof needs === "string") {
        return made[needs];
      } else {
        o = {};
        for (m = 0, len1 = needs.length; m < len1; m++) {
          n = needs[m];
          o[n] = made[n];
        }
        return o;
      }
    };
    notifyTakers = function() {
      var len1, m, taker, takers;
      alreadyWaitingToNotify = false;
      takers = takersToNotify;
      takersToNotify = [];
      for (m = 0, len1 = takers.length; m < len1; m++) {
        taker = takers[m];
        notify(taker);
      }
      return null;
    };
    notify = function(taker) {
      var resolvedNeeds;
      resolvedNeeds = taker.needs.map(function(name) {
        return made[name];
      });
      return taker.callback.apply(null, resolvedNeeds);
    };
    // IE11 doesn't support Object.assign({}, obj), so we just use our own
    clone = function(obj) {
      var k, out, v;
      out = {};
      for (k in obj) {
        v = obj[k];
        out[k] = v;
      }
      return out;
    };
    // We want to add a few handy one-time events.
    // However, we don't know if we'll be running in a browser, or in node.
    // Thus, we look for the presence of a "window" object as our clue.
    if (typeof window !== "undefined" && window !== null) {
      addListener = function(eventName) {
        var handler;
        return window.addEventListener(eventName, handler = function(eventObject) {
          window.removeEventListener(eventName, handler);
          Make(eventName, eventObject);
          return void 0; // prevent unload from opening a popup
        });
      };
      addListener("beforeunload");
      addListener("click");
      addListener("unload");
      // Since we have a window object, it's probably safe to assume we have a document object
      switch (document.readyState) {
        case "loading":
          addListener("DOMContentLoaded");
          addListener("load");
          break;
        case "interactive":
          Make("DOMContentLoaded");
          addListener("load");
          break;
        case "complete":
          Make("DOMContentLoaded");
          Make("load");
          break;
        default:
          throw new Error(`Unknown document.readyState: ${document.readyState}. Cannot setup Take&Make.`);
      }
    }
    // Finally, we're ready to hand over control to module systems
    if (typeof module !== "undefined" && module !== null) {
      return module.exports = {
        Take: Take,
        Make: Make,
        DebugTakeMake: DebugTakeMake
      };
    }
  })();
}

// submodule/bucket/adsr.coffee
// ADSR
// This gives your function an "attack" phase and a "release" phase
// (borrowing terminology from ADSR on synthesizers).
// The attack phase is a debounce — your function will run just once after the attack phase ends,
// no matter how many times it's called until then.
// When the function runs, it'll use the args from the most recent time it was called.
// The release is a throttle — if your function is called during the release phase,
// then after the release phase ends the attack phase will start over again.
// This is useful if you want a function that will run shortly after it's called (good for fast reactions)
// but doesn't run again until a while later (good for reducing strain).
// Attack and release are specified in ms, and are optional.
// If you pass a time of 0 ms for either the attack, release, or both, the phase will last until the next microtask.
// If you pass a time less than 5 ms, the phase will last until the next animation frame.
// It's idiomatic to pass a time of 1 ms if you want the next frame.
// We also keep a count of how many functions are currently waiting, and support adding watchers
// that will run a callback when the count changes, just in case you want to (for example)
// wait for them all to finish before quitting / closing, or monitor their performance.
Take([], function() {
  var ADSR, active, afterAttack, afterDelay, afterRelease, updateWatchers, watchers;
  active = new Map();
  watchers = [];
  Make.async("ADSR", ADSR = function(...arg) {
    var attack, fn, ref, release;
    ref = arg, [...arg] = ref, [fn] = splice.call(arg, -1);
    [attack = 0, release = 0] = arg;
    return function(...args) {
      if (!active.has(fn)) {
        afterDelay(attack, afterAttack(fn, attack, release));
        ADSR.count++;
        updateWatchers();
      }
      return active.set(fn, {args}); // Always use the most recent args
    };
  });
  ADSR.count = 0;
  ADSR.watcher = function(watcher) {
    return watchers.push(watcher);
  };
  afterAttack = function(fn, attack, release) {
    return function() {
      var args;
      ({args} = active.get(fn));
      active.set(fn, {});
      fn(...args);
      return afterDelay(release, afterRelease(fn, attack, release));
    };
  };
  afterRelease = function(fn, attack, release) {
    return function() {
      var args;
      ({args} = active.get(fn));
      if (args) {
        return afterDelay(attack, afterAttack(fn, attack, release));
      } else {
        active.delete(fn);
        ADSR.count--;
        return updateWatchers();
      }
    };
  };
  afterDelay = function(delay = 0, cb) {
    if (delay === 0) {
      return queueMicrotask(cb);
    } else if (delay < 5) {
      return requestAnimationFrame(cb);
    } else {
      return setTimeout(cb, delay);
    }
  };
  return updateWatchers = function() {
    var len1, m, watcher;
    for (m = 0, len1 = watchers.length; m < len1; m++) {
      watcher = watchers[m];
      watcher(ADSR.count);
    }
    return null;
  };
});

// submodule/bucket/monkey-patch.coffee
// Monkey Patch
// The JS standard library leaves a lot to be desired, so let's carefully (see bottom of file)
// modify the built-in classes to add a few helpful methods.
(function() {
  var className, classPatches, globalclass, key, monkeyPatches, results1, value;
  monkeyPatches = {
    Array: {
      type: function(v) {
        return v instanceof Array;
      },
      // Sorting
      numericSortAscending: function(a, b) {
        return a - b;
      },
      numericSortDescending: function(a, b) {
        return b - a;
      },
      sortAlphabetic: function(arr) {
        return arr.sort(Array.alphabeticSort != null ? Array.alphabeticSort : Array.alphabeticSort = new Intl.Collator('en').compare);
      },
      sortNumericAscending: function(arr) {
        return arr.sort(Array.numericSortAscending);
      },
      sortNumericDescending: function(arr) {
        return arr.sort(Array.numericSortDescending);
      },
      // Accessing
      first: function(arr) {
        return arr[0];
      },
      second: function(arr) {
        return arr[1];
      },
      last: function(arr) {
        return arr[arr.length - 1];
      },
      rest: function(arr) {
        return arr.slice(1);
      },
      butLast: function(arr) {
        return arr.slice(0, -1);
      },
      // Misc
      clone: function(arr) {
        return arr.map(Function.clone);
      },
      empty: function(arr) {
        return (arr == null) || arr.length === 0;
      },
      equal: function(a, b) {
        var ai, bi, i, len1, m;
        if (Object.is(a, b)) {
          return true;
        }
        if (!(Array.type(a) && Array.type(b) && a.length === b.length)) {
          return false;
        }
        for (i = m = 0, len1 = a.length; m < len1; i = ++m) {
          ai = a[i];
          bi = b[i];
          if (Function.equal(ai, bi)) {
            continue;
          } else {
            return false;
          }
        }
        return true;
      },
      mapToObject: function(arr, fn = Function.identity) {
        var k, len1, m, o;
        o = {};
        for (m = 0, len1 = arr.length; m < len1; m++) {
          k = arr[m];
          o[k] = fn(k);
        }
        return o;
      },
      pull: function(arr, elms) {
        var elm, i, len1, m;
        if (!((arr != null) && (elms != null))) {
          return;
        }
        if (!Array.type(elms)) {
          elms = [elms];
        }
        for (m = 0, len1 = elms.length; m < len1; m++) {
          elm = elms[m];
          while ((i = arr.indexOf(elm)) > -1) {
            arr.splice(i, 1);
          }
        }
        return arr;
      },
      search: function(arr, key) {
        var len1, m, v;
        for (m = 0, len1 = arr.length; m < len1; m++) {
          v = arr[m];
          if (Array.type(v)) {
            if (Array.search(v, key)) {
              return true;
            }
          } else if (Object.type(v)) {
            if (Object.search(v, key)) {
              return true;
            }
          }
        }
        return false;
      },
      shuffle: function(arr) {
        var i, item, len1, m, newArr;
        newArr = [];
        for (i = m = 0, len1 = arr.length; m < len1; i = ++m) {
          item = arr[i];
          newArr.splice(Math.randInt(0, newArr.length), 0, item);
        }
        return newArr;
      },
      unique: function(elements) {
        return Array.from(new Set([].concat(elements)));
      }
    },
    Function: {
      type: function(v) {
        return v instanceof Function;
      },
      identity: function(v) {
        return v;
      },
      exists: function(e) {
        return e != null;
      },
      notExists: function(e) {
        return e == null;
      },
      is: function(a, b) {
        return a === b;
      },
      isnt: function(a, b) {
        return a !== b;
      },
      equal: function(a, b) {
        if (Object.is(a, b)) {
          return true;
        } else if (Array.type(a) && Array.type(b)) {
          if (Array.equal(a, b)) {
            return true;
          }
        } else if (Object.type(a) && Object.type(b)) {
          if (Object.equal(a, b)) {
            return true;
          }
        } else {
          return false;
        }
      },
      equivalent: function(a, b) {
        return a == b || Function.equal(a, b); // Like equal, but also equates null & undefined, -0 & 0, etc
      },
      notEqual: function(a, b) {
        return !Function.equal(a, b);
      },
      notEquivalent: function(a, b) {
        return !Function.equivalent(a, b);
      },
      clone: function(v) {
        if (v == null) {
          return v;
        } else if (Function.type(v)) {
          throw new Error("If you need to clone functions, use a custom cloner");
        } else if (Promise.type(v)) {
          throw new Error("If you need to clone promises, use a custom cloner");
        } else if (Array.type(v)) {
          return Array.clone(v);
        } else if (Object.type(v)) {
          return Object.clone(v);
        } else {
          return v;
        }
      }
    },
    Math: {
      TAU: Math.PI * 2,
      zero: function(v) {
        return Math.EPSILON > Math.abs(v);
      },
      nonzero: function(v) {
        return !Math.zero(v);
      },
      add: function(a, b) {
        return a + b;
      },
      div: function(a, b) {
        return a / b;
      },
      mod: function(a, b) {
        return a % b;
      },
      mul: function(a, b) {
        return a * b;
      },
      sub: function(a, b) {
        return a - b;
      },
      avg: function(a, b) {
        return (a + b) / 2;
      },
      clip: function(v, ...arg) {
        var max, min, ref;
        ref = arg, [...arg] = ref, [max] = splice.call(arg, -1);
        [min = 0] = arg;
        if (max === void 0) {
          max = 1;
        }
        return Math.min(max, Math.max(min, v));
      },
      sat: function(v) {
        return Math.clip(v);
      },
      lerpN: function(input, outputMin = 0, outputMax = 1, clip = false) {
        input *= outputMax - outputMin;
        input += outputMin;
        if (clip) {
          input = Math.clip(input, outputMin, outputMax);
        }
        return input;
      },
      lerp: function(input, inputMin = 0, inputMax = 1, outputMin = 0, outputMax = 1, clip = true) {
        if (inputMin === inputMax) { // Avoids a divide by zero
          return outputMin;
        }
        if (inputMin > inputMax) {
          [inputMin, inputMax, outputMin, outputMax] = [inputMax, inputMin, outputMax, outputMin];
        }
        if (clip) {
          input = Math.clip(input, inputMin, inputMax);
        }
        input -= inputMin;
        input /= inputMax - inputMin;
        return Math.lerpN(input, outputMin, outputMax, false);
      },
      rand: function(min = -1, max = 1) {
        return Math.lerpN(Math.random(), min, max);
      },
      randInt: function(min, max) {
        return Math.round(Math.rand(min, max));
      },
      roundTo: function(input, precision) {
        var p;
        // Using the reciprocal avoids floating point errors. Eg: 3/10 is fine, but 3*0.1 is wrong.
        p = 1 / precision;
        return Math.round(input * p) / p;
      }
    },
    Object: {
      type: function(v) {
        return "[object Object]" === Object.prototype.toString.call(v);
      },
      // This should probably be a function on Array, as a mirror of Object.keys / Object.values.
      // In general, functions that take an array go on Array, even if they return a different type.
      by: function(k, arr) { // Object.by "name", [{name:"a"}, {name:"b"}] => {a:{name:"a"}, b:{name:"b"}}
        var len1, m, o, obj;
        o = {};
        for (m = 0, len1 = arr.length; m < len1; m++) {
          obj = arr[m];
          o[obj[k]] = obj;
        }
        return o;
      },
      clone: function(obj) {
        return Object.mapValues(obj, Function.clone);
      },
      count: function(obj) {
        return Object.keys(obj).length;
      },
      equal: function(a, b) {
        var av, bv, k, ref;
        if (Object.is(a, b)) {
          return true;
        }
        if (!(((a != null) && (b != null)) && (({}.constructor === (ref = a.constructor) && ref === b.constructor)))) {
          return false;
        }
        if (Object.keys(a).length !== Object.keys(b).length) {
          return false;
        }
        for (k in a) {
          av = a[k];
          bv = b[k];
          if (Function.equal(av, bv)) {
            continue;
          } else {
            return false;
          }
        }
        return true;
      },
      mapKeys: function(obj, fn = Function.identity) {
        var k, o;
        o = {};
        for (k in obj) {
          o[k] = fn(k);
        }
        return o;
      },
      mapValues: function(obj, fn = Function.identity) {
        var k, o, v;
        o = {};
        for (k in obj) {
          v = obj[k];
          o[k] = fn(v);
        }
        return o;
      },
      merge: function(...objs) {
        var k, len1, m, obj, out, v;
        out = {};
        for (m = 0, len1 = objs.length; m < len1; m++) {
          obj = objs[m];
          if (obj != null) {
            for (k in obj) {
              v = obj[k];
              // DO NOT add any additional logic for merging other types (like arrays),
              // or existing apps will break (Hyperzine, Hest, etc.)
              // If you want to deep merge other types, write a custom merge function.
              out[k] = Object.type(v) ? Object.merge(out[k], v) : v;
            }
          }
        }
        return out;
      },
      rmerge: function(...objs) {
        return Object.merge(...objs.reverse());
      },
      search: function(obj, key) {
        var k, v;
        if (obj[key] != null) {
          return true;
        }
        for (k in obj) {
          v = obj[k];
          if (Array.type(v)) {
            if (Array.search(v, key)) {
              return true;
            }
          } else if (Object.type(v)) {
            if (Object.search(v, key)) {
              return true;
            }
          }
        }
        return false;
      },
      subtractKeys: function(a, b) {
        var k, o;
        o = Object.mapKeys(a); // shallow clone
        for (k in b) {
          delete o[k];
        }
        return o;
      }
    },
    Promise: {
      type: function(v) {
        return v instanceof Promise;
      },
      timeout: function(t) {
        return new Promise(function(resolve) {
          return setTimeout(resolve, t);
        });
      }
    },
    String: {
      type: function(v) {
        return "string" === typeof v;
      },
      // https://stackoverflow.com/a/52171480/313576, public domain
      hash: function(str, seed = 0) {
        var c, ch, h1, h2, len1, m;
        if (str == null) {
          return 0;
        }
        h1 = 0xdeadbeef ^ seed;
        h2 = 0x41c6ce57 ^ seed;
        for (m = 0, len1 = str.length; m < len1; m++) {
          c = str[m];
          ch = c.charCodeAt(0);
          h1 = Math.imul(h1 ^ ch, 2654435761);
          h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
        h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
        return 4294967296 * (2097151 & h2) + (h1 >>> 0);
      },
      pluralize: function(count, string, suffix = "s") {
        if (count === 1) {
          suffix = "";
        }
        return (string + suffix).replace("%%", count);
      },
      toKebabCase: function(v) {
        return v.replace(/([A-Z])/g, "-$1").toLowerCase();
      }
    }
  };
// Init
  results1 = [];
  for (className in monkeyPatches) {
    classPatches = monkeyPatches[className];
    globalclass = globalThis[className];
    results1.push((function() {
      var results2;
      results2 = [];
      for (key in classPatches) {
        value = classPatches[key];
        if (globalclass[key] != null) {
          results2.push(console.log(`Can't monkey patch ${className}.${key} because it already exists.`));
        } else {
          results2.push(globalclass[key] = value);
        }
      }
      return results2;
    })());
  }
  return results1;
})();

// submodule/bucket/test.coffee
Tests = Test = null;

(function() {
  var context;
  context = null;
  Tests = function(name, test) {
    context = function() {
      console.group(`%c${name}`, "color: red");
      return context = null;
    };
    test();
    console.groupEnd();
    return context = null;
  };
  return Test = function(name, ...stuff) {
    var i, len1, len2, m, q, ref, results1, thing;
// If we've been passed any functions, run them and capture the return values.
    for (i = m = 0, len1 = stuff.length; m < len1; i = ++m) {
      thing = stuff[i];
      if (Function.type(thing)) {
        stuff[i] = thing();
      }
    }
    // If there's only one thing in stuff, just compare it with true
    if (stuff.length === 1) {
      stuff.unshift(true);
    }
    ref = Array.butLast(stuff);
    // Now, all things in stuff must all be equivalent. Or else.
    // (This test framework is super casual, so we just check each neighbouring pair)
    results1 = [];
    for (i = q = 0, len2 = ref.length; q < len2; i = ++q) {
      thing = ref[i];
      if (!Function.equivalent(thing, stuff[i + 1])) {
        if (typeof context === "function") {
          context();
        }
        console.group(`%c${name}`, "font-weight:normal;");
        console.log("this:", thing);
        console.log("isnt:", stuff[i + 1]);
        results1.push(console.groupEnd());
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  };
})();

// node_modules/doom/doom.coffee
(function() {
  var DOOM, act, attrNames, eventNames, propNames, read, styleNames, svgElms, svgNS, write, xlinkNS;
  svgNS = "http://www.w3.org/2000/svg";
  xlinkNS = "http://www.w3.org/1999/xlink";
  // This is used to cache normalized keys, and to provide defaults for keys that shouldn't be normalized
  attrNames = {
    gradientUnits: "gradientUnits",
    preserveAspectRatio: "preserveAspectRatio",
    startOffset: "startOffset",
    viewBox: "viewBox"
  };
  // common case-sensitive attr names should be listed here as needed — see svg.cofee in https://github.com/cdig/svg for reference
  eventNames = {
    blur: true,
    change: true,
    click: true,
    focus: true,
    input: true,
    keydown: true,
    keypress: true,
    keyup: true,
    mousedown: true,
    mouseenter: true,
    mouseleave: true,
    mousemove: true,
    mouseup: true,
    scroll: true
  };
  propNames = {
    childNodes: true,
    firstChild: true,
    innerHTML: true,
    lastChild: true,
    nextSibling: true,
    parentElement: true,
    parentNode: true,
    previousSibling: true,
    textContent: true,
    value: true
  };
  styleNames = {
    animation: true,
    animationDelay: true,
    background: true,
    borderRadius: true,
    color: true,
    display: true,
    fontSize: "html", // Only treat as a style if this is an HTML elm. SVG elms will treat this as an attribute.
    fontFamily: true,
    fontWeight: true,
    height: "html",
    left: true,
    letterSpacing: true,
    lineHeight: true,
    maxHeight: true,
    maxWidth: true,
    margin: true,
    marginTop: true,
    marginLeft: true,
    marginRight: true,
    marginBottom: true,
    minWidth: true,
    minHeight: true,
    opacity: "html",
    overflow: true,
    overflowX: true,
    overflowY: true,
    padding: true,
    paddingTop: true,
    paddingLeft: true,
    paddingRight: true,
    paddingBottom: true,
    pointerEvents: true,
    position: true,
    textDecoration: true,
    top: true,
    transform: "html",
    transition: true,
    visibility: true,
    width: "html",
    zIndex: true
  };
  // When creating an element, SVG elements require a special namespace, so we use this list to know whether a tag name is for an SVG or not
  svgElms = {
    circle: true,
    clipPath: true,
    defs: true,
    ellipse: true,
    g: true,
    image: true,
    line: true,
    linearGradient: true,
    mask: true,
    path: true,
    polygon: true,
    polyline: true,
    radialGradient: true,
    rect: true,
    stop: true,
    svg: true,
    symbol: true,
    text: true,
    textPath: true,
    tspan: true,
    use: true
  };
  read = function(elm, k) {
    var cache;
    if (propNames[k] != null) {
      cache = elm._DOOM_prop;
      if (cache[k] === void 0) {
        cache[k] = elm[k];
      }
      return cache[k];
    } else if (styleNames[k] != null) {
      cache = elm._DOOM_style;
      if (cache[k] === void 0) {
        cache[k] = elm.style[k];
      }
      return cache[k];
    } else {
      k = attrNames[k] != null ? attrNames[k] : attrNames[k] = k.replace(/([A-Z])/g, "-$1").toLowerCase(); // Normalize camelCase into kebab-case
      cache = elm._DOOM_attr;
      if (cache[k] === void 0) {
        cache[k] = elm.getAttribute(k);
      }
      return cache[k];
    }
  };
  write = function(elm, k, v) {
    var cache, isCached, ns;
    if (propNames[k] != null) {
      cache = elm._DOOM_prop;
      isCached = cache[k] === v;
      if (!isCached) {
        return elm[k] = cache[k] = v;
      }
    } else if ((styleNames[k] != null) && !(elm._DOOM_SVG && styleNames[k] === "html")) {
      cache = elm._DOOM_style;
      isCached = cache[k] === v;
      if (!isCached) {
        return elm.style[k] = cache[k] = v;
      }
    } else if (eventNames[k] != null) {
      cache = elm._DOOM_event;
      if (cache[k] === v) {
        return;
      }
      if (cache[k] != null) {
        throw "DOOM experimentally imposes a limit of one handler per event per object.";
      }
      // If we want to add multiple handlers for the same event to an object,
      // we need to decide how that interacts with passing null to remove events.
      // Should null remove all events? Probably. How do we track that? Keep an array of refs to handlers?
      // That seems slow and error prone.
      cache[k] = v;
      if (v != null) {
        return elm.addEventListener(k, v);
      } else {
        return elm.removeEventListener(k, v);
      }
    } else {
      k = attrNames[k] != null ? attrNames[k] : attrNames[k] = k.replace(/([A-Z])/g, "-$1").toLowerCase(); // Normalize camelCase into kebab-case
      cache = elm._DOOM_attr;
      if (cache[k] === v) {
        return;
      }
      cache[k] = v;
      ns = k === "xlink:href" ? xlinkNS : null; // Grab the namespace if needed
      if (ns != null) {
        if (v != null) {
          return elm.setAttributeNS(ns, k, v); // set DOM attribute
// v is explicitly set to null (not undefined)
        } else {
          return elm.removeAttributeNS(ns, k); // remove DOM attribute // check for null
        }
      } else {
        if (v != null) {
          return elm.setAttribute(k, v); // set DOM attribute
// v is explicitly set to null (not undefined)
        } else {
          return elm.removeAttribute(k); // remove DOM attribute // check for null
        }
      }
    }
  };
  act = function(elm, opts) {
    var k, v;
    // Initialize the caches
    if (elm._DOOM_attr == null) {
      elm._DOOM_attr = {};
    }
    if (elm._DOOM_event == null) {
      elm._DOOM_event = {};
    }
    if (elm._DOOM_prop == null) {
      elm._DOOM_prop = {};
    }
    if (elm._DOOM_style == null) {
      elm._DOOM_style = {};
    }
    if (typeof opts === "object") {
      for (k in opts) {
        v = opts[k];
        write(elm, k, v);
      }
      return elm;
    } else if (typeof opts === "string") {
      return read(elm, opts);
    }
  };
  // PUBLIC API ####################################################################################

  // The first arg can be an elm or array of elms
  // The second arg can be an object of stuff to update in the elm(s), in which case we'll return the elm(s).
  // Or it can be a string prop/attr/style to read from the elm(s), in which case we return the value(s).
  DOOM = function(elms, opts) {
    var elm, len1, m, results;
    if (typeof elms !== "array") {
      elms = [elms];
    }
    for (m = 0, len1 = elms.length; m < len1; m++) {
      elm = elms[m];
      ((function() {
        if (elm == null) {
          throw new Error("DOOM was called with a null element");
        }
      })());
    }
    if (opts == null) {
      throw new Error("DOOM was called with null options");
    }
    results = (function() {
      var len2, q, results1;
      results1 = [];
      for (q = 0, len2 = elms.length; q < len2; q++) {
        elm = elms[q];
        results1.push(act(elm, opts));
      }
      return results1;
    })();
    if (results.length === 1) {
      return results[0];
    } else {
      return results;
    }
  };
  DOOM.create = function(type, parent, opts) {
    var elm;
    if (svgElms[type] != null) {
      elm = document.createElementNS(svgNS, type);
      if (type === "svg") {
        (opts != null ? opts : opts = {}).xmlns = svgNS;
      } else {
        elm._DOOM_SVG = true;
      }
    } else {
      elm = document.createElement(type);
    }
    if (opts != null) {
      DOOM(elm, opts);
    }
    if (parent != null) {
      DOOM.append(parent, elm);
    }
    return elm;
  };
  DOOM.append = function(parent, child) {
    parent.appendChild(child);
    return child;
  };
  DOOM.prepend = function(parent, child) {
    if (parent.hasChildNodes()) {
      parent.insertBefore(child, parent.firstChild);
    } else {
      parent.appendChild(child);
    }
    return child;
  };
  DOOM.remove = function(elm, child) {
    if (child != null) {
      if (child.parentNode === elm) {
        elm.removeChild(child);
      }
      return child;
    } else {
      elm.remove();
      return elm;
    }
  };
  DOOM.empty = function(elm) {
    return elm.innerHTML = "";
  };
  if (this != null) {
    // Attach to this
    this.DOOM = DOOM;
  }
  if (typeof window !== "undefined" && window !== null) {
    // Attach to the window
    window.DOOM = DOOM;
  }
  if (Make != null) {
    // Integrate with Take & Make
    return Make("DOOM", DOOM);
  }
})();

// lib/file-tree.coffee
Take(["Read"], function(Read) {
  var FileTree, populateTree, sort;
  sort = function(a, b) {
    return a.name.localeCompare(b.name);
  };
  populateTree = async function(tree) {
    var dirents;
    if ((await Read.exists(tree.path))) {
      dirents = (await Read.withFileTypes(tree.path));
      dirents.sort(sort);
      tree.children = (await Promise.all(dirents.map(async function(dirent) {
        var childFile, childTree, parts;
        if (dirent.isDirectory()) {
          childTree = FileTree.newEmpty(tree.path, dirent.name);
          childTree.relpath = Read.path(tree.relpath, dirent.name);
          await populateTree(childTree);
          tree.count += childTree.count;
          return childTree;
        } else {
          tree.count += 1;
          parts = dirent.name.split(".");
          return childFile = {
            name: dirent.name,
            basename: Array.butLast(parts).join("."),
            ext: parts.length > 1 ? Array.last(parts).toLowerCase() : null,
            path: Read.path(tree.path, dirent.name),
            relpath: Read.path(tree.relpath, dirent.name)
          };
        }
      })));
    }
    return tree;
  };
  return Make("FileTree", FileTree = {
    newEmpty: function(parentPath, name) {
      return {
        name: name,
        basename: name,
        ext: null,
        path: Read.path(parentPath, name), // absolute path on the local HD
        relpath: name, // path relative to the parent of the tree root
        count: 0,
        children: []
      };
    },
    newPopulated: async function(parentPath, name) {
      var root;
      root = FileTree.newEmpty(parentPath, name);
      await populateTree(root);
      return root;
    },
    flat: function(tree, k, into = []) {
      var child, len1, m, ref;
      ref = tree.children;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        child = ref[m];
        if (k == null) { // collecting children
          into.push(child);
        } else if (child[k] != null) {
          into.push(child[k]);
        }
        if (child.children) {
          FileTree.flat(child, k, into);
        }
      }
      return into;
    },
    find: function(tree, k, v) {
      var child, len1, m, ref, res;
      if (tree[k] === v) {
        return tree;
      }
      if (tree.children) {
        ref = tree.children;
        for (m = 0, len1 = ref.length; m < len1; m++) {
          child = ref[m];
          if (res = FileTree.find(child, k, v)) {
            return res;
          }
        }
      }
      return null;
    }
  });
});

// lib/frustration.coffee
Take([], function() {
  var arr;
  arr = ["•_•` ", "`•_•`", " `•_•", "  o.o", " o.o ", "o.o  ", "•√•  ", " •√• ", "  •√•", "  °e°", " °o° ", "°3°  ", "v_v  ", " v_v ", "  v_v", " `•ω•", "`•ω•`", "•ω•` ", "‘^‘  ", " '^' ", "  `^`", "  T∞T", " T∞T ", "T∞T  ", "¡^¡  ", " ¡^¡ ", "  ¡^¡", "  ;_;", " ;_; ", ";_;  "];
  return Make("Frustration", function(i) {
    if (i != null) {
      i %= arr.length;
    } else {
      i = Math.rand(0, arr.length);
    }
    return arr[i | 0];
  });
});

// lib/iterated.coffee
Take([], function() {
  var Iterated;
  return Make("Iterated", Iterated = function(...arg) {
    var didRunThisFrame, iteratedFunction, more, nextFrame, nextFrameRequested, ranOutOfTime, ref, requestNextFrame, run, runAgainNextFrame, startTime, timeLimit;
    ref = arg, [...arg] = ref, [iteratedFunction] = splice.call(arg, -1);
    [timeLimit = 5] = arg;
    nextFrameRequested = false;
    runAgainNextFrame = false;
    didRunThisFrame = false;
    ranOutOfTime = false;
    startTime = null;
    run = function() {
      if (didRunThisFrame) {
        // Only run once per frame. If we've already run, mark that we want to run again next frame.
        return runAgainNextFrame = true;
      }
      didRunThisFrame = true;
      // Whenever we run, we need to do some additional work next frame.
      requestNextFrame();
      // Defer the execution of the function *slightly*, to improve batching behaviour
      // when an iterated function is called repeatedly inside a loop (eg: by lib/job.coffee).
      queueMicrotask(function() {
        // Now we can actually run the iterated function!
        startTime = performance.now();
        return iteratedFunction(more);
      });
      // Iterated functions are just for side effects — a return value is not needed.
      return null;
    };
    requestNextFrame = function() {
      if (nextFrameRequested) {
        return;
      }
      nextFrameRequested = true;
      return requestAnimationFrame(nextFrame);
    };
    // Whenever someone calls run(), we *always* need to do some cleanup work, and me might
    // also need to call run() again ourselves if there's more iterated work to be done.
    nextFrame = function() {
      var doRun;
      doRun = runAgainNextFrame;
      nextFrameRequested = false;
      runAgainNextFrame = false;
      didRunThisFrame = false;
      ranOutOfTime = false;
      if (doRun) {
        return run();
      }
    };
    // This function will tell the caller whether they're safe to do more work this frame.
    // They'll call it repeatedly in a loop (while doing other work) until either they
    // run out of time and break out of the loop, or run out of work to do and just stop
    // calling us.
    more = function(customLimit) {
      ranOutOfTime = performance.now() - startTime > (customLimit || timeLimit);
      if (ranOutOfTime) {
        // Mark that we want to actually do a run() next frame, not just the usual cleanup.
        runAgainNextFrame = true;
        // We always need to request a new frame, since the call to more() might come
        // long after the last call to run() if the iterated function is doing something async.
        requestNextFrame();
      }
      return !ranOutOfTime;
    };
    return run;
  });
});

// lib/job.coffee
Take([], function() {
  var Job, bail, handlers, lastN, lastTime, run, running, updateWatchers, watchers;
  handlers = {};
  watchers = [];
  running = false;
  lastTime = null;
  lastN = [];
  Make.async("Job", Job = function(priority, type, ...args) {
    // Priority is optional, and defaults to 0
    if (String.type(priority)) {
      return Job(0, priority, type, ...args);
    }
    if (handlers[type] == null) {
      throw Error(`No handler for job type: ${type}`);
    }
    return new Promise(function(resolve) {
      var base;
      if ((base = Job.queues)[priority] == null) {
        base[priority] = [];
      }
      Job.queues[priority].push({type, args, resolve});
      Job.count++;
      return Job.runJobs();
    });
  });
  Job.queues = [];
  Job.count = 0;
  Job.delay = 0;
  Job.handler = function(type, handler) {
    if (handlers[type]) {
      throw Error(`A job handler for ${type} already exists`);
    }
    return handlers[type] = handler;
  };
  Job.watcher = function(watcher) {
    return watchers.push(watcher);
  };
  Job.runJobs = function() {
    if (running) {
      return;
    }
    running = true;
    lastTime = performance.now();
    Job.delay = 16;
    updateWatchers();
    return requestAnimationFrame(run);
  };
  run = function() {
    var args, dirty, m, priority, queue, ref, resolve, time, type;
    dirty = false;
    ref = Job.queues;
    for (priority = m = ref.length - 1; m >= 0; priority = m += -1) {
      queue = ref[priority];
      while ((queue != null ? queue.length : void 0) > 0) {
        dirty = true;
        ({time, type, args, resolve} = queue.shift());
        Job.count--;
        resolve(handlers[type](...args)); // We can't await, or else if a Job creates a new Job inside itself, we'll get stuck
        Job.delay = (performance.now() - lastTime) * 0.1 + Job.delay * 0.9;
        if (Job.delay > 30) { // Don't let the frame rate crater
          return bail();
        }
      }
    }
    running = false;
    if (dirty) {
      // If any jobs ran this frame, we should run at least one more time, in case any jobs that we ran created new jobs at a higher priority.
      Job.runJobs();
    }
    return updateWatchers();
  };
  bail = function() {
    lastTime = performance.now();
    requestAnimationFrame(run);
    return updateWatchers();
  };
  return updateWatchers = function() {
    var len1, m, watcher;
    for (m = 0, len1 = watchers.length; m < len1; m++) {
      watcher = watchers[m];
      watcher(Job.count, Job.delay);
    }
    return null;
  };
});

// lib/log-initialization-time.coffee
(async function() {
  var Log, performance, time;
  if (typeof performance === "undefined" || performance === null) {
    ({performance} = require("perf_hooks"));
  }
  time = performance.now();
  Log = (await Take.async("Log"));
  return Log("Initialization Time", null, time);
})();

// lib/log.coffee
Take([], function() {
  var DB, Env, IPC, Log, Printer, performance;
  if (typeof performance === "undefined" || performance === null) {
    ({performance} = require("perf_hooks"));
  }
  // We can't / shouldn't Take anything, since Log might need to be used *anywhere*
  DB = Env = IPC = Printer = null;
  Make.async("Log", Log = function(msg, attrs, time) {
    if (Env == null) {
      Env = Take("Env");
    }
    // Send logs to the local printer
    if (Printer != null ? Printer : Printer = Take("Printer")) {
      Printer(msg, attrs, time);
    }
    // If we have a port to the DB, send logs to the DB Printer
    if (DB != null ? DB : DB = Take("DB")) {
      DB.send("printer", msg, attrs, time);
    }
    // If we're in dev, and in a render process, send logs to the main process Printer
    if ((Env != null ? Env.isDev : void 0) && (Env != null ? Env.isRender : void 0) && (IPC != null ? IPC : IPC = Take("IPC"))) {
      IPC.send("printer", msg, attrs, time);
    }
    return msg;
  });
  Log.time = function(msg, fn) {
    var start, v;
    start = performance.now();
    v = fn();
    Log.time.formatted(msg, performance.now() - start);
    return v;
  };
  Log.time.async = async function(msg, fn) {
    var start, v;
    start = performance.now();
    v = (await fn());
    Log.time.formatted(msg, performance.now() - start);
    return v;
  };
  Log.time.custom = function(preMsg) {
    var start;
    if (preMsg) {
      Log(preMsg);
    }
    start = performance.now();
    return function(postMsg) {
      return Log.time.formatted(postMsg, performance.now() - start);
    };
  };
  Log.time.formatted = function(msg, time) {
    return Log(time.toFixed(1).padStart(6) + " " + msg);
  };
  return Log.err = function(msg) {
    return Log(msg, {
      color: "#F00"
    });
  };
});

// lib/paths.coffee
Take(["Read"], function(Read) {
  var Paths;
  return Make("Paths", Paths = {
    files: function(asset) {
      return Read.path(asset.path, "Files");
    },
    names: function(asset) {
      return Read.path(asset.path, "Name");
    },
    shots: function(asset) {
      return Read.path(asset.path, "Shot");
    },
    newShots: function(asset) {
      return Read.path(asset.path, "Shot (New)");
    },
    tags: function(asset) {
      return Read.path(asset.path, "Tags");
    },
    thumbnails: function(asset) {
      return Read.path(asset.path, "Thumbnail Cache");
    },
    file: function(asset, filename) {
      return Read.path(Paths.files(asset), filename);
    },
    name: function(asset) {
      return Read.path(Paths.names(asset), asset.name);
    },
    shot: function(asset) {
      return Read.path(Paths.shots(asset), asset.shot);
    },
    newShot: function(asset) {
      return Read.path(Paths.newShots(asset), asset.newShot);
    },
    thumbnail: function(asset, filename) {
      return Read.path(Paths.thumbnails(asset), filename);
    },
    tag: function(asset, tag) {
      return Read.path(Paths.tags(asset), tag);
    },
    thumbnailName: function(file, size) {
      return `${String.hash(file.relpath)}-${size}.jpg`;
    },
    ext: {
      icon: {
        "as": "as",
        "cptx": "cptx",
        "css": "css",
        "dwg": "dwg",
        "exe": "exe",
        "fla": "fla",
        "idlk": "idlk",
        "indb": "indb",
        "indd": "indd",
        "swf": "swf",
        null: true,
        undefined: true // Include null / undefined because we want those to get an icon, not a thumbnail
      },
      sips: {"3fr": "3fr", "arw": "arw", "astc": "astc", "avci": "avci", "bmp": "bmp", "cr2": "cr2", "cr3": "cr3", "crw": "crw", "dcr": "dcr", "dds": "dds", "dng": "dng", "dxo": "dxo", "erf": "erf", "exr": "exr", "fff": "fff", "gif": "gif", "heic": "heic", "heics": "heics", "heif": "heif", "icns": "icns", "ico": "ico", "iiq": "iiq", "jp2": "jp2", "jpeg": "jpeg", "jpg": "jpg", "ktx": "ktx", "mos": "mos", "mpo": "mpo", "mrw": "mrw", "nef": "nef", "nrw": "nrw", "orf": "orf", "orf": "orf", "orf": "orf", "pbm": "pbm", "pdf": "pdf", "pef": "pef", "pic": "pic", "pict": "pict", "png": "png", "psd": "psd", "pvr": "pvr", "raf": "raf", "raw": "raw", "rw2": "rw2", "rwl": "rwl", "sgi": "sgi", "sr2": "sr2", "srf": "srf", "srw": "srw", "tga": "tga", "tiff": "tiff", "webp": "webp"},
      video: {"avchd": "avchd", "avi": "avi", "m4p": "m4p", "m4v": "m4v", "mov": "mov", "mp2": "mp2", "mp4": "mp4", "mpe": "mpe", "mpeg": "mpeg", "mpg": "mpg", "mpv": "mpv", "ogg": "ogg", "qt": "qt", "webm": "webm", "wmv": "wmv"}
    }
  });
});

// lib/printer.coffee
Take([], function() {
  var Printer, performance;
  if (typeof window !== "undefined" && window !== null ? window.isDB : void 0) { // DB has its own Printer
    return;
  }
  if (typeof performance === "undefined" || performance === null) {
    ({performance} = require("perf_hooks"));
  }
  return Make("Printer", Printer = function(msg, attrs, time) {
    time = (time || performance.now()).toFixed(0).padStart(5);
    return console.log(time + "  " + msg);
  });
});

// lib/pub-sub.coffee
Take([], function() {
  var Pub, Sub, subs;
  subs = {};
  Sub = function(name, cb) {
    return (subs[name] != null ? subs[name] : subs[name] = []).push(cb);
  };
  Pub = function(name, ...args) {
    var handler, len1, m, ref;
    if (subs[name] != null) {
      ref = subs[name];
      for (m = 0, len1 = ref.length; m < len1; m++) {
        handler = ref[m];
        handler(...args);
      }
    }
    return null;
  };
  return Make("PubSub", {Pub, Sub});
});

// lib/read.coffee
// TODO: Clear up the naming so that everything is explicitly Read.sync.foo or Read.async.foo
Take([], function() {
  var Read, filterValidDirentName, fs, path, validDirentName, validFileName;
  fs = require("fs");
  path = require("path");
  validFileName = function(v) {
    if (0 === v.indexOf(".")) { // Exclude dotfiles
      return false;
    }
    if (-1 !== v.search(/[<>:;,?"*|\/\\]/)) { // Exclude names we won't be able to roundtrip
      return false;
    }
    return true; // Everything else is good
  };
  validDirentName = function(v) {
    return validFileName(v.name);
  };
  filterValidDirentName = function(vs) {
    return vs.filter(validDirentName);
  };
  Read = function(folderPath) {
    var fileNames;
    try {
      fileNames = fs.readdirSync(folderPath);
      return fileNames.filter(validFileName);
    } catch (error) {
      return null;
    }
  };
  // Temporary hack until we fully switch Read over to split sync and async.
  // Note that we can't just say Read.sync = Read, or that breaks Read.sync.exists!
  Read.sync = function(p) {
    return Read(p);
  };
  Read.sync.exists = function(path) {
    return fs.existsSync(path);
  };
  Read.async = function(folderPath) {
    return new Promise(function(resolve) {
      return fs.readdir(folderPath, function(err, fileNames) {
        if (err != null) {
          return resolve(null);
        } else {
          return resolve(fileNames.filter(validFileName));
        }
      });
    });
  };
  Read.withFileTypes = function(folderPath) {
    return fs.promises.readdir(folderPath, {
      withFileTypes: true
    }).then(filterValidDirentName);
  };
  Read.isFolder = function(folderPath) {
    if (!(folderPath != null ? folderPath.length : void 0)) {
      return false;
    }
    return new Promise(function(resolve) {
      return fs.stat(folderPath, function(err, stat) {
        return resolve(stat != null ? stat.isDirectory() : void 0);
      });
    });
  };
  Read.stat = function(path) {
    return new Promise(function(resolve) {
      return fs.stat(path, function(err, stat) {
        return resolve(stat);
      });
    });
  };
  Read.exists = function(filePath) {
    if (!(filePath != null ? filePath.length : void 0)) {
      return false;
    }
    return new Promise(function(resolve) {
      return fs.access(filePath, function(err) {
        return resolve(err == null);
      });
    });
  };
  Read.file = function(filePath) {
    var file;
    try {
      return file = fs.readFileSync(filePath);
    } catch (error) {
      return null;
    }
  };
  Read.sep = path.sep;
  Read.watch = fs.watch;
  Read.path = function(...segs) {
    return segs.join(path.sep);
  };
  Read.split = function(p) {
    return Array.pull(p.split(path.sep), "");
  };
  Read.last = function(p) {
    return Array.last(Read.split(p));
  };
  Read.parentPath = function(p) {
    return Read.path(...Array.butLast(Read.split(p)));
  };
  return Make("Read", Read);
});

// lib/size-on-disk.coffee
Take(["Read"], function(Read) {
  var SizeOnDisk;
  Make.async("SizeOnDisk", SizeOnDisk = function(path) {
    return new Promise(async function(resolve) {
      var childName, children, len1, m, size, sizes, stats, total;
      stats = (await Read.stat(path));
      if (stats == null) {
        return resolve(0);
      } else if (!stats.isDirectory()) {
        return resolve(stats.size);
      } else {
        total = 0;
        children = (await Read.async(path));
        sizes = (function() {
          var len1, m, results1;
          results1 = [];
          for (m = 0, len1 = children.length; m < len1; m++) {
            childName = children[m];
            results1.push(SizeOnDisk(Read.path(path, childName)));
          }
          return results1;
        })();
        for (m = 0, len1 = sizes.length; m < len1; m++) {
          size = sizes[m];
          total += (await size);
        }
        return resolve(total);
      }
    });
  });
  return SizeOnDisk.pretty = async function(path) {
    var exp, len, size, suffix;
    size = (await SizeOnDisk(path));
    len = size.toString().length;
    console.log(size / 1000);
    console.log(len);
    switch (false) {
      case !(len < 3):
        suffix = "B";
        exp = 0;
        break;
      case !(len < 7):
        suffix = "KB";
        exp = 1;
        break;
      case !(len < 11):
        suffix = "MB";
        exp = 2;
        break;
      default:
        suffix = "GB";
        exp = 3;
    }
    return (size / Math.pow(1000, exp)).toFixed(1) + " " + suffix;
  };
});

// lib/state.coffee
Take([], function() {
  var State, conditionalSet, getAt, localNotify, runCbs, runCbsAbove, runCbsWithin, state, subscriptions;
  state = {};
  subscriptions = {
    _cbs: []
  };
  getAt = function(node, path) {
    var k, len1, m, part, parts;
    if (path === "") {
      return [
        {
          "": node
        },
        ""
      ];
    }
    parts = path.split(".");
    k = parts.pop();
    for (m = 0, len1 = parts.length; m < len1; m++) {
      part = parts[m];
      node = node[part] != null ? node[part] : node[part] = {};
    }
    return [node, k];
  };
  Make.async("State", State = function(path = "", v, {immutable = false} = {}) {
    var k, node, old;
    [node, k] = getAt(state, path);
    if (v === void 0) { // Just a read
      return node[k];
    }
    if (!immutable) {
      
      // It's not safe to take something out of State, mutate it, and commit it again.
      // The immutable option tells us the caller promises they're not doing that.
      // Otherwise, we clone values before reading or writing them.
      v = Function.clone(v);
    }
    if (!immutable && v === node[k] && (Object.type(v) || Array.type(v))) {
      throw "Did you take something out of State, mutate it, and commit it again?";
    }
    if (path === "") {
      throw Error("You're not allowed to set the State root");
    }
    old = node[k];
    if (v != null) {
      node[k] = v;
    } else {
      delete node[k];
    }
    if (Function.notEquivalent(v, old)) {
      queueMicrotask(function() {
        return localNotify(path, v);
      });
    }
    return v;
  });
  conditionalSet = function(path, v, pred) {
    var doSet, k, node;
    [node, k] = getAt(state, path);
    doSet = pred(node[k], v);
    if (doSet) {
      State(path, v);
    }
    return doSet;
  };
  // These are useful because they return true if a change was made
  State.change = function(path, v) {
    return conditionalSet(path, v, Function.notEquivalent);
  };
  State.default = function(path, v) {
    return conditionalSet(path, v, Function.notExists);
  };
  // This is useful because it reduces the need to update State in a loop,
  // which triggers a lot of (possibly pointless) notifications.
  // Reminder that Object.merge doesn't handle arrays, so maybe
  // limit the use of this function to primitives (since it implies immutable).
  State.merge = function(path, v) {
    return State(path, Object.merge(v, State(path)), {
      immutable: true
    });
  };
  // These are useful because it offers a nice syntax for updating existing values in State,
  // with support for async, either mutably or immutably.
  State.update = async function(path, fn) {
    return State(path, (await fn(State(path))), {
      immutable: true
    });
  };
  State.mutate = async function(path, fn) {
    return State.clone(path, (await fn(State(path))), {
      immutable: true
    });
  };
  // This is a convenience function for reading something from State that is pre-cloned
  // (if necessary) to avoid mutability issues.
  State.clone = function(path) {
    return Function.clone(State(path));
  };
  State.subscribe = function(...arg) {
    var base, cb, k, node, path, ref, runNow, weak;
    ref = arg, [...arg] = ref, [cb] = splice.call(arg, -1);
    [path = "", runNow = true, weak = false] = arg;
    if (!String.type(path)) { // Avoid errors if you try say subscribe(runNow, cb)
      throw "Invalid subscribe path";
    }
    [node, k] = getAt(subscriptions, path);
    ((base = (node[k] != null ? node[k] : node[k] = {}))._cbs != null ? base._cbs : base._cbs = []).push(cb);
    cb._state_weak = weak; // ... this is fine 🐕☕️🔥
    if (runNow) {
      return cb(State(path));
    }
  };
  State.unsubscribe = function(...arg) {
    var cb, k, node, path, ref;
    ref = arg, [...arg] = ref, [cb] = splice.call(arg, -1);
    [path = ""] = arg;
    [node, k] = getAt(subscriptions, path);
    if (indexOf.call(node[k]._cbs, cb) < 0) {
      throw Error("Unsubscribe failed");
    }
    Array.pull(node[k]._cbs, cb);
    return null;
  };
  localNotify = function(path, v) {
    var changes, k, node;
    [node, k] = getAt(subscriptions, path);
    runCbsWithin(node[k], v);
    runCbs(node[k], v, v);
    changes = runCbsAbove(path, v);
    return runCbs(subscriptions, state, changes);
  };
  runCbsWithin = function(parent, v) {
    var _v, child, k;
    if (!Object.type(parent)) {
      return;
    }
    for (k in parent) {
      child = parent[k];
      if (!(k !== "_cbs")) {
        continue;
      }
      _v = v != null ? v[k] : void 0;
      runCbsWithin(child, _v);
      runCbs(child, _v, _v);
    }
    return null;
  };
  runCbsAbove = function(path, changes) {
    var changesAbove, k, node, p, parts, pathAbove;
    parts = path.split(".");
    p = parts.pop();
    changesAbove = {};
    changesAbove[p] = changes;
    if (!(parts.length > 0)) {
      return changesAbove;
    }
    pathAbove = parts.join(".");
    [node, k] = getAt(subscriptions, pathAbove);
    runCbs(node[k], State(pathAbove), changesAbove);
    return runCbsAbove(pathAbove, changesAbove);
  };
  return runCbs = function(node, v, changed) {
    var cb, dead, len1, len2, m, q, ref;
    if (node != null ? node._cbs : void 0) {
      dead = [];
      ref = node._cbs;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        cb = ref[m];
        if (cb._state_weak && (v == null)) {
          dead.push(cb);
        } else {
          cb(v, changed);
        }
      }
      for (q = 0, len2 = dead.length; q < len2; q++) {
        cb = dead[q];
        Array.pull(node._cbs, cb);
      }
    }
    return null;
  };
});

// lib/write.coffee
Take(["Env", "Log", "Read"], function(Env, Log, Read) {
  var Memory, Write, fs, logWrite, validPath;
  fs = require("fs");
  validPath = function(v) {
    var valid;
    valid = true;
    v = v.replace(/^\\*[A-Z]:/, ""); // Ignore the drive letter on Windows
    if (-1 !== v.search(/[<>:;,?"*|]/)) { // Exclude names we won't be able to roundtrip
      valid = false;
    }
    if (v.length <= 1) {
      valid = false;
    }
    if (!valid) {
      Log.err(`${v} is not a valid file path`);
    }
    return valid;
  };
  Make.async("Write", Write = function() {
    throw "Not Implemented";
  });
  Write.logging = true;
  Write.sync = {};
  Write.async = {};
  Memory = null;
  logWrite = function(fn, p, opts = {}) {
    if (opts.quiet) {
      return;
    }
    if (!Write.logging) {
      return;
    }
    if (Memory != null ? Memory : Memory = Take("Memory")) {
      if (p !== Memory("assetsFolder")) {
        p = p.replace(Memory("assetsFolder") + Read.sep, "");
      }
      if (p !== Memory("dataFolder")) {
        p = p.replace(Memory("dataFolder") + Read.sep, "");
      }
    }
    if (p !== Env.home) {
      p = p.replace(Env.home + Read.sep, "");
    }
    return Log(`WRITE ${fn} ${p}`);
  };
  Write.sync.file = function(path, data, opts) {
    var valid;
    if (valid = validPath(path)) {
      logWrite("file", path, opts);
      fs.writeFileSync(path, data);
    }
    return valid;
  };
  Write.sync.mkdir = function(path, opts) {
    var valid;
    if (fs.existsSync(path)) {
      return true;
    }
    if (valid = validPath(path)) {
      logWrite("mkdir", path, opts);
      fs.mkdirSync(path, {
        recursive: true
      });
    }
    return valid;
  };
  Write.sync.rename = function(path, newName, opts) {
    var newPath, valid;
    newPath = Read.sep + Read.path(Read.parentPath(path), newName);
    if (path === newPath) {
      return true;
    }
    if (valid = validPath(path) && validPath(newPath)) {
      logWrite("rename", `${path} -> ${newPath}`, opts);
      fs.renameSync(path, newPath);
    }
    return valid;
  };
  Write.sync.rm = function(path, opts) {
    var valid;
    if (!fs.existsSync(path)) {
      return true;
    }
    if (valid = validPath(path)) {
      logWrite("rm", path, opts);
      fs.rmSync(path, {
        recursive: true
      });
    }
    return valid;
  };
  Write.sync.copyFile = function(src, dest, opts) {
    var valid;
    if (valid = validPath(src) && validPath(dest)) {
      logWrite("copyFile", `${src} -> ${dest}`, opts);
      fs.copyFileSync(src, dest);
    }
    return valid;
  };
  Write.sync.json = function(path, data, opts) {
    return Write.sync.file(path, JSON.stringify(data), opts);
  };
  Write.sync.array = function(path, arr, opts) {
    var current, len1, len2, m, q, v;
    current = Read(path);
    if (current == null) {
      current = [];
    }
    if (Array.equal(arr, current)) {
      return;
    }
    for (m = 0, len1 = current.length; m < len1; m++) {
      v = current[m];
      if (indexOf.call(arr, v) < 0) {
        // Remove anything that's in the folder but not in our new array
        Write.sync.rm(Read.path(path, v), opts);
      }
    }
    for (q = 0, len2 = arr.length; q < len2; q++) {
      v = arr[q];
      if (indexOf.call(current, v) < 0) {
        // Save anything that's in our new array but not in the folder
        Write.sync.mkdir(Read.path(path, v), opts);
      }
    }
    return null;
  };
  return Write.async.copyInto = async function(src, destFolder, opts) {
    var _valid, childDestFolder, item, len1, m, ref, srcName, valid;
    srcName = Read.last(src);
    if ((await Read.isFolder(src))) {
      childDestFolder = Read.path(destFolder, srcName);
      Write.sync.mkdir(childDestFolder, opts);
      valid = true;
      ref = Read(src);
      for (m = 0, len1 = ref.length; m < len1; m++) {
        item = ref[m];
        _valid = Write.async.copyInto(Read.path(src, item), childDestFolder, opts);
        valid && (valid = _valid);
      }
      return valid;
    } else {
      return Write.sync.copyFile(src, Read.path(destFolder, srcName), opts);
    }
  };
});

// common/adsr-status.coffee
Take(["ADSR"], function(ADSR) {
  var elm;
  elm = document.querySelector("adsr-status");
  if (elm == null) {
    return;
  }
  return ADSR.watcher(function(count, delay) {
    count = String.pluralize(count, "%% ADSR");
    return elm.textContent = `${count} Active`;
  });
});

// common/db.coffee
Take(["IPC", "Log"], async function(IPC, Log) {
  var DB, bind, db, id, ignoreList, listeners, requestID, requests, returned;
  if (window.isDB) { // The DB process doesn't use this — use Ports instead
    return;
  }
  bind = new Promise(function(resolve) {
    return IPC.on("port", function({ports}, {id}) {
      return resolve([ports[0], id]);
    });
  });
  IPC.send("bind-db");
  [db, id] = (await bind);
  requests = {};
  listeners = {};
  ignoreList = {"memory-broadcast": "memory-broadcast"};
  requestID = 0;
  db.onmessage = function({
      data: [msg, ...data]
    }) {
    var cb, l, len1, m, results1;
    if (msg === "return") {
      return returned(...data);
    } else if (l = listeners[msg]) {
      results1 = [];
      for (m = 0, len1 = l.length; m < len1; m++) {
        cb = l[m];
        results1.push(cb(...data));
      }
      return results1;
    } else if (ignoreList[msg] == null) {
      return Log(`Message from DB dropped: ${msg}`);
    }
  };
  returned = function(requestID, resp) {
    var resolve;
    resolve = requests[requestID];
    delete requests[requestID];
    return resolve(resp);
  };
  return Make("DB", DB = {
    on: function(msg, cb) {
      return (listeners[msg] != null ? listeners[msg] : listeners[msg] = []).push(cb);
    },
    send: function(msg, ...args) {
      var response;
      requestID++ % Number.MAX_SAFE_INTEGER;
      response = new Promise(function(resolve) {
        return requests[requestID] = resolve;
      });
      db.postMessage([requestID, msg, ...args]);
      return response;
    }
  });
});

// common/editable-field.coffee
Take(["DOOM"], function(DOOM) {
  var EditableField;
  return Make("EditableField", EditableField = function(elm, cb, opts = {}) {
    var setValue, startValue, validate;
    if (DOOM(elm, "editableField") != null) {
      return;
    }
    startValue = null;
    DOOM(elm, {
      editableField: "",
      contenteditable: "",
      autocomplete: "off",
      autocorrect: "off",
      autocapitalize: "off",
      spellcheck: "false"
    });
    setValue = function() {
      validate();
      if (elm._valid) {
        return cb(elm.textContent);
      }
    };
    validate = function() {
      elm.textContent = elm.textContent.trim();
      if (opts.validate != null) {
        elm._valid = opts.validate(elm.textContent);
        return DOOM(elm, {
          fieldInvalid: elm._valid ? null : ""
        });
      } else {
        return elm._valid = true;
      }
    };
    elm.addEventListener("input", function(e) {
      if (opts.saveOnInput) {
        return setValue();
      }
    });
    elm.addEventListener("focus", function() {
      validate();
      return startValue = elm.textContent;
    });
    elm.addEventListener("blur", function() {
      window.getSelection().empty();
      return setValue();
    });
    return elm.addEventListener("keydown", function(e) {
      switch (e.keyCode) {
        case 13:
          e.preventDefault();
          return elm.blur();
        case 27:
          elm.textContent = startValue;
          e.preventDefault();
          return elm.blur();
      }
    });
  });
});

// common/env-style.coffee
Take(["DOOM", "Env"], function(DOOM, Env) {
  return DOOM(document.body, {
    envDev: Env.isDev,
    envMac: Env.isMac
  });
});

// common/env.coffee
Take(["IPC"], async function(IPC) {
  var Env;
  Env = (await IPC.invoke("env"));
  Env.isMain = false;
  Env.isRender = true;
  return Make("Env", Env);
});

// common/find.coffee
// The main window sets up a global Command-F menu item, which will forward
// a "find" IPC event to the frontmost window. Here we catch it and pass it along
// to any interested parties in this window.
Take(["IPC", "PubSub"], function(IPC, {Pub, Sub}) {
  return IPC.on("find", function() {
    return Pub("find");
  });
});

// common/gear-view.coffee
Take(["DOOM", "DOMContentLoaded"], function(DOOM) {
  return Make("GearView", function(depth = 30, offset = -10, attrs = {}) {
    var gearElm, gearsElm, i, m, ref;
    gearsElm = document.querySelector("gear-view");
    gearElm = gearsElm;
    for (i = m = 0, ref = depth; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {
      gearElm = DOOM.create("span", gearElm); // For special effects
      gearElm = DOOM.create("div", gearElm, {
        style: `animation-delay: ${offset}s`
      });
    }
    return DOOM(gearsElm, attrs);
  });
});

// common/hold-to-run.coffee
Take(["DOOM", "DOMContentLoaded"], function(DOOM) {
  var HoldToRun, down, isDown, run, timeout, up;
  isDown = null;
  timeout = null;
  down = function(elm, time, cb) {
    return function(e) {
      if ((isDown == null) && e.button === 0) {
        isDown = elm;
        DOOM(isDown, {
          holdActive: "",
          holdLonger: null
        });
        return timeout = setTimeout(run(cb), time);
      }
    };
  };
  up = function() {
    if (isDown != null) {
      DOOM(isDown, {
        holdActive: null,
        holdLonger: ""
      });
      clearTimeout(timeout);
      return isDown = null;
    }
  };
  run = function(cb) {
    return function() {
      isDown = null;
      return cb();
    };
  };
  window.addEventListener("mouseup", up);
  return Make("HoldToRun", HoldToRun = function(elm, time, cb) {
    DOOM(elm, {
      holdToRun: ""
    });
    elm.style.setProperty("--hold-time", time + "ms");
    return elm.onmousedown = down(elm, time, cb);
  });
});

// common/icons.coffee
Take(["DOOM", "DOMContentLoaded"], function(DOOM) {
  return DOOM.create("svg", document.body, {
    id: "icons",
    innerHTML: `<defs>
  <path id="i-check" d="M20 100L75 155 185 45"/>
  <path id="i-ex" d="M35 165 L165 35 M35 35 L165 165"/>
  <path id="i-arrow" d="M40 100 L180 100 M110 30 L40 100 110 170"/>
  <path id="i-diamond" d="M165 100L100 165 35 100 100 35z"/>
  <g id="i-eye" transform="scale(1.8, 1.8) translate(0, 15)" stroke-width="10">
    <path d="M55.5 5c19 0 35.4 11.9 49.6 34.5C91 62.1 74.5 74 55.5 74S20.1 62.1 5.9 39.5C20 16.9 36.5 5 55.5 5z"/>
    <circle cx="55.5" cy="39.5" r="18.5"/>
  </g>
  <g id="i-file" stroke-width="18">
    <path d="M38,19 L108,19 C110,19 112,19 114,21 L159,65 C161,67 162,69 162,71 L162,180 L162,180 L38,180 L38,19 Z"/>
    <polyline points="162 70 108 70 108 19"/>
  </g>
</defs>`
  });
});

// common/ipc.coffee
Take([], function() {
  var IPC, ipcRenderer;
  ({ipcRenderer} = require("electron"));
  return Make("IPC", IPC = {
    send: function(...args) {
      return ipcRenderer.send(...args);
    },
    invoke: function(...args) {
      return ipcRenderer.invoke(...args);
    },
    on: function(channel, cb) {
      return ipcRenderer.on(channel, cb);
    },
    once: function(channel, cb) {
      return ipcRenderer.on(channel, cb);
    },
    // Promise-based handlers, optimized for use with await
    promise: {
      once: function(channel) {
        return new Promise(function(resolve) {
          return ipcRenderer.once(channel, resolve);
        });
      }
    }
  });
});

// common/job-status.coffee
Take(["Job"], function(Job) {
  var elm;
  elm = document.querySelector("job-status");
  if (elm == null) {
    return;
  }
  return Job.watcher(function(count, delay) {
    count = String.pluralize(count, "%% Job");
    elm.firstChild.textContent = `${count} Queued`;
    return elm.lastChild.textContent = `(${delay | 0}ms)`;
  });
});

// common/memory-field.coffee
Take(["DOOM", "EditableField", "Memory"], function(DOOM, EditableField, Memory) {
  var MemoryField;
  return Make("MemoryField", MemoryField = function(memoryKey, elm, opts = {}) {
    var focused, setValue;
    // Flag whether we've been set up on an elm already. That makes it safe to create a
    // MemoryField inside a repeatedly-run Render call.
    if (DOOM(elm, "memoryField") != null) {
      return;
    }
    DOOM(elm, {
      memoryField: ""
    });
    focused = false;
    elm.addEventListener("focus", function(e) {
      return focused = true;
    });
    elm.addEventListener("blur", function(e) {
      return focused = false;
    });
    Memory.subscribe("Read Only", true, function(v) {
      return DOOM(elm, {
        contenteditable: v ? null : ""
      });
    });
    Memory.subscribe(memoryKey, true, function(value) {
      if (!value) {
        return;
      }
      if (focused) {
        return;
      }
      return elm.textContent = value;
    });
    setValue = function(value) {
      Memory(memoryKey, value);
      return typeof opts.update === "function" ? opts.update(value) : void 0;
    };
    return EditableField(elm, setValue, opts);
  });
});

// common/memory.coffee
Take([], async function() {
  var DB, Memory, Ports, conditionalSet, getAt, j, localNotify, memory, remoteNotify, runCbs, runCbsAbove, runCbsWithin, set, sub, subscriptions;
  memory = null; // Stores all the values committed to Memory
  subscriptions = {
    _cbs: [] // Notified when specific paths are changed
  };
  if (window.isDB) {
    Ports = (await Take.async("Ports"));
    // DB owns the cannonical copy of Memory, so we initialize to an empty object to store it all
    memory = {};
    // Other windows will want to initialize themselves with a clone our Memory
    Ports.on("clone-memory", function() {
      return memory;
    });
    // Other windows will notify us when they want to change something in Memory
    Ports.on("memory-notify-db", function(path, v) {
      return Memory(path, v);
    });
    // When the DB's Memory changes, we should notify other windows
    remoteNotify = function(path, v) {
      return Ports.send("memory-broadcast", path, v);
    };
  } else {
    DB = (await Take.async("DB"));
    // The DB owns the cannonical copy of Memory, so we initialize to a clone of whatever it has
    memory = (await DB.send("clone-memory"));
    // Notify the DB whenever anything in our Memory changes
    remoteNotify = function(path, v) {
      return DB.send("memory-notify-db", path, v);
    };
    // When the DB's memory changes, it'll notify us
    DB.on("memory-broadcast", function(path, v) {
      return Memory(path, v, {
        remote: false
      });
    });
  }
  // This is how we support "deep.paths":
  // Pass a tree-like object, and a dot-separated string of keys.
  // We'll return the penultimate node in the tree, and the final key.
  // (Stopping just above the final node allows you to do assignment.)
  // For uniformity, pass "" to get back the tree root wrapped in a node with a "" key.
  getAt = function(node, path) {
    var k, len1, m, part, parts;
    if (path === "") {
      return [
        {
          "": node
        },
        ""
      ];
    }
    parts = path.split(".");
    k = parts.pop();
    for (m = 0, len1 = parts.length; m < len1; m++) {
      part = parts[m];
      node = node[part] != null ? node[part] : node[part] = {};
    }
    return [node, k];
  };
  Make.async("Memory", Memory = function(path = "", v, {remote = true, immutable = false} = {}) {
    var k, node, old;
    [node, k] = getAt(memory, path);
    if (v === void 0) { // Just a read
      return node[k];
    }
    if (!immutable) {
      
      // It's not safe to take something out of Memory, mutate it, and commit it again.
      // The immutable option tells us the caller promises they're not doing that.
      // Otherwise, we clone values before writing them.
      v = Function.clone(v);
    }
    if ((Object.type(v) || Array.type(v)) && v === node[k]) {
      throw "Did you take something out of Memory, mutate it, and commit it again?";
    }
    if (path === "") {
      throw Error("You're not allowed to set the Memory root");
    }
    old = node[k];
    if (v != null) {
      node[k] = v;
    } else {
      delete node[k];
    }
    if (Function.notEquivalent(v, old)) {
      queueMicrotask(function() {
        localNotify(path, v);
        if (remote) {
          return remoteNotify(path, v);
        }
      });
    }
    return v;
  });
  conditionalSet = function(path, v, pred) {
    var doSet, k, node;
    [node, k] = getAt(memory, path);
    doSet = pred(node[k], v);
    if (doSet) {
      Memory(path, v);
    }
    return doSet;
  };
  // These are useful because they return true if a change was made
  Memory.change = function(path, v) {
    return conditionalSet(path, v, Function.notEquivalent);
  };
  Memory.default = function(path, v) {
    return conditionalSet(path, v, Function.notExists);
  };
  // This is useful because it reduces the need to update Memory in a loop,
  // which triggers a lot of (possibly pointless) notifications.
  // Reminder that Object.merge doesn't handle arrays, so maybe
  // limit the use of this function to primitives (since it implies immutable).
  Memory.merge = function(path, v) {
    return Memory(path, Object.merge(v, Memory(path)), {
      immutable: true
    });
  };
  // These are useful because it offers a nice syntax for updating existing values in Memory,
  // with support for async, either mutably or immutably.
  Memory.update = async function(path, fn) {
    return Memory(path, (await fn(Memory(path))), {
      immutable: true
    });
  };
  Memory.mutate = async function(path, fn) {
    return Memory(path, (await fn(Memory.clone(path))), {
      immutable: true
    });
  };
  // This is a convenience function for reading something from Memory that is pre-cloned
  // (if necessary) to avoid mutability issues.
  Memory.clone = function(path) {
    return Function.clone(Memory(path));
  };
  Memory.subscribe = function(...arg) {
    var base, cb, k, node, path, ref, runNow, weak;
    ref = arg, [...arg] = ref, [cb] = splice.call(arg, -1);
    [path = "", runNow = true, weak = false] = arg;
    if (!String.type(path)) { // Avoid errors if you try say subscribe(runNow, cb)
      throw "Invalid subscribe path";
    }
    [node, k] = getAt(subscriptions, path);
    ((base = (node[k] != null ? node[k] : node[k] = {}))._cbs != null ? base._cbs : base._cbs = []).push(cb);
    cb._memory_weak = weak; // ... this is fine 🐕☕️🔥
    if (runNow) {
      return cb(Memory(path));
    }
  };
  Memory.unsubscribe = function(...arg) {
    var cb, k, node, path, ref;
    ref = arg, [...arg] = ref, [cb] = splice.call(arg, -1);
    [path = ""] = arg;
    [node, k] = getAt(subscriptions, path);
    if (indexOf.call(node[k]._cbs, cb) < 0) {
      throw Error("Unsubscribe failed");
    }
    Array.pull(node[k]._cbs, cb);
    return null;
  };
  localNotify = function(path, v) {
    var changes, k, node;
    [node, k] = getAt(subscriptions, path);
    // console.log "  within:"
    runCbsWithin(node[k], v);
    // console.log "  at path:"
    runCbs(node[k], v, v);
    // console.log "  above:"
    changes = runCbsAbove(path, v);
    // console.log "  root:"
    return runCbs(subscriptions, memory, changes);
  };
  runCbsWithin = function(parent, v) {
    var _v, child, k;
    if (!Object.type(parent)) {
      return;
    }
    for (k in parent) {
      child = parent[k];
      if (!(k !== "_cbs")) {
        continue;
      }
      _v = v != null ? v[k] : void 0;
      runCbsWithin(child, _v);
      runCbs(child, _v, _v);
    }
    return null;
  };
  runCbsAbove = function(path, changes) {
    var changesAbove, k, node, p, parts, pathAbove;
    parts = path.split(".");
    p = parts.pop();
    changesAbove = {};
    changesAbove[p] = changes;
    if (!(parts.length > 0)) {
      return changesAbove;
    }
    pathAbove = parts.join(".");
    [node, k] = getAt(subscriptions, pathAbove);
    runCbs(node[k], Memory(pathAbove), changesAbove);
    return runCbsAbove(pathAbove, changesAbove);
  };
  runCbs = function(node, v, changed) {
    var cb, dead, len1, len2, m, q, ref;
    if (node != null ? node._cbs : void 0) {
      dead = [];
      ref = node._cbs;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        cb = ref[m];
        if (cb._memory_weak && (v == null)) {
          dead.push(cb);
        } else {
          cb(v, changed);
        }
      }
      for (q = 0, len2 = dead.length; q < len2; q++) {
        cb = dead[q];
        Array.pull(node._cbs, cb);
      }
    }
    return null;
  };
  // TESTS
  j = function(x) {
    return JSON.stringify(x);
  };
  sub = function(p) {
    console.log(p);
    return Memory.subscribe(p, false, function(v, changed) {
      return console.log("    " + p, j(v), j(changed));
    });
  };
  // Memory.subscribe p, false, (v, changed)-> console.log "    strong  " + p, j(v), j changed
  // Memory.subscribe p, false, true, (v, changed)-> console.log "    weak    " + p, j(v), j changed
  return set = function(p, v, msg) {
    if (msg != null) {
      console.log("\n\n" + msg);
    }
    console.log(`\nSET ${p} to`, j(v));
    return Memory(p, v);
  };
});

// Note: changed only exists when we've modified a subpath rather than the path specified by the listener

// console.log "SUBSCRIBERS"
// sub "assets.A.id"
// sub "assets.A.files"
// sub "assets.A"
// sub "assets.B"
// sub "assets"
// sub "squibs - should never see this run"
// sub ""

// set "assets.A", {id:0, x: 0}, "create an obj"
// set "assets.A.y", 0, "create a primitive"
// set "assets.A.id", 1, "change a primitive"
// # set "assets.A.x.wat", 0, "drill into a primitive!?" — error
// set "assets.A.id", {in:0}, "replace a primitive with an obj"
// set "assets.A.id", null, "delete an obj"
// set "assets.B", {id:9}, "create another obj"
// set "fork", {}, "create, no subscribers"
// set "assets", null, "delete an obj with many subs"
// # set "", 3, "set root — should error"

// common/on-screen.coffee
Take([], function() {
  var OnScreen, elms, observer, observerFn;
  elms = new WeakMap();
  observerFn = function(entries) {
    var cb, entry, len1, m, results1;
    results1 = [];
    for (m = 0, len1 = entries.length; m < len1; m++) {
      entry = entries[m];
      if (cb = elms.get(entry.target)) {
        results1.push(cb(entry.target, entry.isIntersecting));
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  };
  observer = new IntersectionObserver(observerFn, {
    root: document.querySelector("[on-screen-container]"),
    rootMargin: "1000px" // Start loading images a little before they scroll into view
  });
  Make.async("OnScreen", OnScreen = function(elm, cb) {
    if (elms.has(elm)) {
      throw Error("Overwriting existing OnScreen");
    }
    elms.set(elm, cb);
    return observer.observe(elm);
  });
  return OnScreen.off = function(elm) {
    return elms.delete(elm);
  };
});

// common/rainbow-before.coffee
Take(["ADSR", "Rainbow", "DOMContentLoaded"], function(ADSR, Rainbow) {
  var len1, m, ref, results1, scroll, scrollable;
  scroll = ADSR(1, 1, function() {
    return Rainbow.move(0.5);
  });
  scroll();
  ref = document.querySelectorAll(".scrollable");
  results1 = [];
  for (m = 0, len1 = ref.length; m < len1; m++) {
    scrollable = ref[m];
    results1.push(scrollable.addEventListener("wheel", scroll, {
      passive: true
    }));
  }
  return results1;
});

// common/rainbow-colors.coffee
(function() {
  var colors;
  colors = ["hsl(20, 100%, 50%)", "hsl(170, 100%, 50%)", "hsl(250, 100%, 50%)"];
  colors = Array.shuffle(colors);
  document.body.style.setProperty("--rainbow-a", colors[0]);
  document.body.style.setProperty("--rainbow-b", colors[1]);
  return document.body.style.setProperty("--rainbow-c", colors[2]);
})();

// common/rainbow.coffee
Take(["State"], function(State) {
  var Rainbow;
  State("rainbow-before-delay", Math.randInt(0, -1000));
  Make("Rainbow", Rainbow = {
    move: function(delta) {
      var delay;
      delay = State("rainbow-before-delay") - delta;
      State("rainbow-before-delay", delay);
      document.body.style.setProperty("--rainbow-before-delay", `${delay}ms`);
      return document.body.style.setProperty("--rainbow-focus", d3.lch(70, 30, -delay / 2));
    }
  });
  return window.addEventListener("keydown", function() {
    return Rainbow.move(4);
  });
});

// common/search-box.coffee
Take(["ADSR", "PubSub", "State", "DOMContentLoaded"], function(ADSR, {Pub, Sub}, State) {
  var change, elm, focused;
  elm = document.querySelector("search-box input");
  if (elm == null) {
    return;
  }
  focused = false;
  change = ADSR(1, 1, function(e) {
    return State("search", elm.value);
  });
  State.subscribe("search", false, function(v) {
    if (!focused) {
      return elm.value = v;
    }
  });
  elm.addEventListener("change", change);
  elm.addEventListener("input", change);
  elm.onfocus = function() {
    return focused = true;
  };
  elm.onblur = function() {
    return focused = false;
  };
  return Sub("find", function() {
    return elm.focus();
  });
});

// common/subscriptions/search-render.coffee
Take(["PubSub", "State"], function({Pub}, State) {
  return State.subscribe("search", false, function() {
    return Pub("Render");
  });
});

// common/tag-list.coffee
Take(["Memory"], function(Memory) {
  var TagList, makeTag;
  Make.async("TagList", TagList = function(asset, opts = {}) {
    var frag, len1, len2, m, q, sortedTags, specialTags, tag;
    specialTags = Memory("specialTags");
    sortedTags = Array.sortAlphabetic(asset.tags);
    // Make all the special tags first, so they come at the start of the list
    frag = new DocumentFragment();
    for (m = 0, len1 = sortedTags.length; m < len1; m++) {
      tag = sortedTags[m];
      if (specialTags[tag] != null) {
        frag.append(makeTag(tag, opts, true));
      }
    }
    for (q = 0, len2 = sortedTags.length; q < len2; q++) {
      tag = sortedTags[q];
      if (specialTags[tag] == null) {
        frag.append(makeTag(tag, opts, false));
      }
    }
    return frag;
  });
  return makeTag = function(tag, opts, special) {
    var elm;
    elm = DOOM.create("tag-item", null, {
      textContent: tag
    });
    if (special) {
      DOOM(elm, {
        special: ""
      });
    }
    if (opts.click != null) {
      DOOM(elm, {
        click: function(e) {
          if (!Memory("Read Only")) {
            return opts.click(tag, elm);
          }
        }
      });
    }
    if (opts.removeFn != null) {
      DOOM.create("span", elm, {
        textContent: "x",
        class: "remove",
        click: function(e) {
          if (!Memory("Read Only")) {
            return opts.removeFn(tag);
          }
        }
      });
    }
    return elm;
  };
});

// common/validations.coffee
Take([], function() {
  var Validations;
  return Make("Validations", Validations = {
    asset: {
      name: function(v) {
        return -1 === v.search(/[.:\/\\]/);
      }
    },
    file: function(v) {
      return -1 === v.search(/[:\/\\]/);
    }
  });
});

// common/window-events.coffee
Take(["IPC"], function(IPC) {
  IPC.on("focus", function() {
    return document.documentElement.classList.remove("blur");
  });
  IPC.on("blur", function() {
    return document.documentElement.classList.add("blur");
  });
  IPC.on("maximize", function() {
    return document.documentElement.classList.add("maximize");
  });
  return IPC.on("unmaximize", function() {
    return document.documentElement.classList.remove("maximize");
  });
});

// common/windows-menu.coffee
Take(["IPC", "Log", "DOMContentLoaded"], function(IPC, Log) {
  var close, max, min, restore;
  min = document.querySelector("windows-menu #min");
  max = document.querySelector("windows-menu #max");
  restore = document.querySelector("windows-menu #restore");
  close = document.querySelector("windows-menu #close");
  if (!(min && max && restore && close)) {
    return;
  }
  min.addEventListener("click", function(e) {
    return IPC.send("minimize-window");
  });
  max.addEventListener("click", function(e) {
    return IPC.send("maximize-window");
  });
  restore.addEventListener("click", function(e) {
    return IPC.send("unmaximize-window");
  });
  return close.addEventListener("click", function(e) {
    return IPC.send("close-window");
  });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6Ii4uIiwic291cmNlcyI6WyJ0ZW1wL2NvbW1vbi5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUtvRTs7OztBQUNwRTtBQURvRSxJQUFBLGFBQUEsRUFBQSxJQUFBLEVBQUEsSUFBQSxFQUFBLElBQUEsRUFBQSxLQUFBO0VBQUE7OztBQUlwRSxNQUFPLDhDQUFBLElBQVMsK0NBQWhCOzs7RUFJRSxJQUFBLEdBQU87RUFDUCxJQUFBLEdBQU87RUFDUCxhQUFBLEdBQWdCO0VBRWIsQ0FBQSxRQUFBLENBQUEsQ0FBQTtBQUVMLFFBQUEsV0FBQSxFQUFBLGNBQUEsRUFBQSxlQUFBLEVBQUEsc0JBQUEsRUFBQSxtQkFBQSxFQUFBLGtCQUFBLEVBQUEsS0FBQSxFQUFBLElBQUEsRUFBQSxnQkFBQSxFQUFBLGNBQUEsRUFBQSxNQUFBLEVBQUEsWUFBQSxFQUFBLFFBQUEsRUFBQSxPQUFBLEVBQUEsa0JBQUEsRUFBQSxjQUFBLEVBQUE7SUFBSSxJQUFBLEdBQU8sQ0FBQTtJQUNQLGFBQUEsR0FBZ0I7SUFDaEIsY0FBQSxHQUFpQjtJQUNqQixzQkFBQSxHQUF5QjtJQUN6QixlQUFBLEdBQWtCO0lBQ2xCLGdCQUFBLEdBQW1CO0lBQ25CLGNBQUEsR0FBaUI7SUFFakIsSUFBQSxHQUFPLFFBQUEsQ0FBQyxJQUFELEVBQU8sUUFBUSxJQUFmLENBQUE7TUFFTCxJQUF5QixZQUF6Qjs7QUFBQSxlQUFPLEtBQUEsQ0FBTSxJQUFOLEVBQVA7T0FETjs7YUFJTSxRQUFBLENBQVMsSUFBVCxFQUFlLEtBQWY7SUFMSztJQVFQLElBQUEsR0FBTyxRQUFBLENBQUMsS0FBRCxFQUFRLFFBQVIsQ0FBQTtNQUVMLElBQW9DLGFBQXBDOztBQUFBLGVBQU8sYUFBYSxDQUFDLEtBQWQsQ0FBQSxFQUFQO09BRE47O2FBSU0sT0FBQSxDQUFRLEtBQVIsRUFBZSxRQUFmO0lBTEssRUFoQlg7O0lBeUJJLElBQUksQ0FBQyxLQUFMLEdBQWEsUUFB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LElBQUosQ0FBUyxpQkFBVDtFQUQ0QixDQUE5QjtFQUdBLEdBQUcsQ0FBQyxnQkFBSixDQUFxQixPQUFyQixFQUE4QixRQUFBLENBQUMsQ0FBRCxDQUFBO1dBQzVCLEdBQUcsQ0FBQyxJQUFKLENBQVMsaUJBQVQ7RUFENEIsQ0FBOUI7RUFHQSxPQUFPLENBQUMsZ0JBQVIsQ0FBeUIsT0FBekIsRUFBa0MsUUFBQSxDQUFDLENBQUQsQ0FBQTtXQUNoQyxHQUFHLENBQUMsSUFBSixDQUFTLG1CQUFUO0VBRGdDLENBQWxDO1NBR0EsS0FBSyxDQUFDLGdCQUFOLENBQXVCLE9BQXZCLEVBQWdDLFFBQUEsQ0FBQyxDQUFELENBQUE7V0FDOUIsR0FBRyxDQUFDLElBQUosQ0FBUyxjQUFUO0VBRDhCLENBQWhDO0FBakJ1QyxDQUF6QyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4jIG5vZGVfbW9kdWxlcy90YWtlLWFuZC1tYWtlL3NvdXJjZS90YWtlLWFuZC1tYWtlLmNvZmZlZVxuIyBTaW5jZSB0aGlzIGlzIHR5cGljYWxseSB0aGUgZmlyc3QgYml0IG9mIGNvZGUgaW5jbHVkZWQgaW4gb3VyIGJpZyBjb21waWxlZCBhbmRcbiMgY29uY2F0ZW5hdGVkIEpTIGZpbGVzLCB0aGlzIGlzIGEgZ3JlYXQgcGxhY2UgdG8gZGVtYW5kIHN0cmljdG5lc3MuIENvZmZlZVNjcmlwdFxuIyBkb2VzIG5vdCBhZGQgc3RyaWN0IG9uIGl0cyBvd24sIGJ1dCBpdCB3aWxsIHBlcm1pdCBhbmQgZW5mb3JjZSBpdC5cblwidXNlIHN0cmljdFwiO1xuXG4jIEJhaWwgaWYgVGFrZSZNYWtlIGlzIGFscmVhZHkgcnVubmluZyBpbiB0aGlzIHNjb3BlLCBvciBpZiBzb21ldGhpbmcgZWxzZSBpcyB1c2luZyBvdXIgbmFtZXNcbnVubGVzcyBUYWtlPyBvciBNYWtlP1xuXG4gICMgV2UgZGVjbGFyZSBvdXIgZ2xvYmFscyBzdWNoIHRoYXQgdGhleSdyZSB2aXNpYmxlIGV2ZXJ5d2hlcmUgd2l0aGluIHRoZSBjdXJyZW50IHNjb3BlLlxuICAjIFRoaXMgYWxsb3dzIGZvciBuYW1lc3BhY2luZyDigJQgYWxsIHRoaW5ncyB3aXRoaW4gYSBnaXZlbiBzY29wZSBzaGFyZSBhIGNvcHkgb2YgVGFrZSAmIE1ha2UuXG4gIFRha2UgPSBudWxsXG4gIE1ha2UgPSBudWxsXG4gIERlYnVnVGFrZU1ha2UgPSBudWxsXG5cbiAgZG8gKCktPlxuXG4gICAgbWFkZSA9IHt9XG4gICAgd2FpdGluZ1Rha2VycyA9IFtdXG4gICAgdGFrZXJzVG9Ob3RpZnkgPSBbXVxuICAgIGFscmVhZHlXYWl0aW5nVG9Ob3RpZnkgPSBmYWxzZVxuICAgIGFscmVhZHlDaGVja2luZyA9IGZhbHNlXG4gICAgbWljcm90YXNrc05lZWRlZCA9IDBcbiAgICBtaWNyb3Rhc2tzVXNlZCA9IDBcblxuICAgIE1ha2UgPSAobmFtZSwgdmFsdWUgPSBuYW1lKS0+XG4gICAgICAjIERlYnVnIOKAlCBjYWxsIE1ha2UoKSBpbiB0aGUgY29uc29sZSB0byBzZWUgd2hhdCB3ZSd2ZSByZWdzdGVyZWRcbiAgICAgIHJldHVybiBjbG9uZSBtYWRlIGlmIG5vdCBuYW1lP1xuXG4gICAgICAjIFN5bmNocm9ub3VzIHJlZ2lzdGVyLCByZXR1cm5zIHZhbHVlXG4gICAgICByZWdpc3RlciBuYW1lLCB2YWx1ZVxuXG5cbiAgICBUYWtlID0gKG5lZWRzLCBjYWxsYmFjayktPlxuICAgICAgIyBEZWJ1ZyDigJQgY2FsbCBUYWtlKCkgaW4gdGhlIGNvbnNvbGUgdG8gc2VlIHdoYXQgd2UncmUgd2FpdGluZyBmb3JcbiAgICAgIHJldHVybiB3YWl0aW5nVGFrZXJzLnNsaWNlKCkgaWYgbm90IG5lZWRzP1xuXG4gICAgICAjIFN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXMgcmVzb2x2ZSwgcmV0dXJucyB2YWx1ZSBvciBvYmplY3Qgb2YgdmFsdWVzXG4gICAgICByZXNvbHZlIG5lZWRzLCBjYWxsYmFja1xuXG5cbiAgICAjIEEgdmFyaWF0aW9uIG9mIE1ha2UgdGhhdCBkZWZlcnMgY29tbWl0dGluZyB0aGUgdmFsdWVcbiAgICBNYWtlLmFzeW5jID0gKG5hbWUsIHZhbHVlID0gbmFtZSktPlxuICAgICAgcXVldWVNaWNyb3Rhc2sgKCktPlxuICAgICAgICBNYWtlIG5hbWUsIHZhbHVlXG5cblxuICAgICMgQSB2YXJpYXRpb24gb2YgVGFrZSB0aGF0IHJldHVybnMgYSBwcm9taXNlXG4gICAgVGFrZS5hc3luYyA9IChuZWVkcyktPlxuICAgICAgbmV3IFByb21pc2UgKHJlcyktPlxuICAgICAgICBUYWtlIG5lZWRzLCAoKS0+XG4gICAgICAgICAgIyBSZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggYSB2YWx1ZSBvciBvYmplY3Qgb2YgdmFsdWVzXG4gICAgICAgICAgcmVzIHN5bmNocm9ub3VzUmVzb2x2ZSBuZWVkc1xuXG5cbiAgICBEZWJ1Z1Rha2VNYWtlID0gKCktPlxuICAgICAgb3V0cHV0ID1cbiAgICAgICAgbWljcm90YXNrc05lZWRlZDogbWljcm90YXNrc05lZWRlZFxuICAgICAgICBtaWNyb3Rhc2tzVXNlZDogbWljcm90YXNrc1VzZWRcbiAgICAgICAgdW5yZXNvbHZlZDoge31cbiAgICAgIGZvciB3YWl0aW5nIGluIHdhaXRpbmdUYWtlcnNcbiAgICAgICAgZm9yIG5lZWQgaW4gd2FpdGluZy5uZWVkc1xuICAgICAgICAgIHVubGVzcyBtYWRlW25lZWRdP1xuICAgICAgICAgICAgb3V0cHV0LnVucmVzb2x2ZWRbbmVlZF0gPz0gMFxuICAgICAgICAgICAgb3V0cHV0LnVucmVzb2x2ZWRbbmVlZF0rK1xuICAgICAgcmV0dXJuIG91dHB1dFxuXG5cbiAgICByZWdpc3RlciA9IChuYW1lLCB2YWx1ZSktPlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG1heSBub3QgTWFrZShcXFwiXFxcIikgYW4gZW1wdHkgc3RyaW5nLlwiKSBpZiBuYW1lIGlzIFwiXCJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtYXkgbm90IE1ha2UoKSB0aGUgc2FtZSBuYW1lIHR3aWNlOiAje25hbWV9XCIpIGlmIG1hZGVbbmFtZV0/XG4gICAgICBtYWRlW25hbWVdID0gdmFsdWVcbiAgICAgIGNoZWNrV2FpdGluZ1Rha2VycygpXG4gICAgICB2YWx1ZVxuXG5cbiAgICBjaGVja1dhaXRpbmdUYWtlcnMgPSAoKS0+XG4gICAgICByZXR1cm4gaWYgYWxyZWFkeUNoZWNraW5nICMgUHJldmVudCByZWN1cnNpb24gZnJvbSBNYWtlKCkgY2FsbHMgaW5zaWRlIG5vdGlmeSgpXG4gICAgICBhbHJlYWR5Q2hlY2tpbmcgPSB0cnVlXG5cbiAgICAgICMgQ29tbWVudHMgYmVsb3cgYXJlIHRvIGhlbHAgcmVhc29uIHRocm91Z2ggdGhlIChwb3RlbnRpYWxseSkgcmVjdXJzaXZlIGJlaGF2aW91clxuXG4gICAgICBmb3IgdGFrZXIsIGluZGV4IGluIHdhaXRpbmdUYWtlcnMgIyBEZXBlbmRzIG9uIGB3YWl0aW5nVGFrZXJzYFxuICAgICAgICBpZiBhbGxOZWVkc0FyZU1ldCh0YWtlci5uZWVkcykgIyBEZXBlbmRzIG9uIGBtYWRlYFxuICAgICAgICAgIHdhaXRpbmdUYWtlcnMuc3BsaWNlKGluZGV4LCAxKSAjIE11dGF0ZXMgYHdhaXRpbmdUYWtlcnNgXG4gICAgICAgICAgbm90aWZ5KHRha2VyKSAjIENhbGxzIHRvIE1ha2UoKSBvciBUYWtlKCkgd2lsbCBtdXRhdGUgYG1hZGVgIG9yIGB3YWl0aW5nVGFrZXJzYFxuICAgICAgICAgIGFscmVhZHlDaGVja2luZyA9IGZhbHNlXG4gICAgICAgICAgcmV0dXJuIGNoZWNrV2FpdGluZ1Rha2VycygpICMgUmVzdGFydDogYHdhaXRpbmdUYWtlcnNgIChhbmQgcG9zc2libHkgYG1hZGVgKSB3ZXJlIG11dGF0ZWRcblxuICAgICAgYWxyZWFkeUNoZWNraW5nID0gZmFsc2VcblxuXG4gICAgYWxsTmVlZHNBcmVNZXQgPSAobmVlZHMpLT5cbiAgICAgIHJldHVybiBuZWVkcy5ldmVyeSAobmFtZSktPiBtYWRlW25hbWVdP1xuXG5cbiAgICByZXNvbHZlID0gKG5lZWRzLCBjYWxsYmFjayktPlxuICAgICAgIyBXZSBhbHdheXMgdHJ5IHRvIHJlc29sdmUgYm90aCBzeW5jaHJvbm91c2x5IGFuZCBhc3luY2hyb25vdXNseVxuICAgICAgYXN5bmNocm9ub3VzUmVzb2x2ZSBuZWVkcywgY2FsbGJhY2sgaWYgY2FsbGJhY2s/XG4gICAgICBzeW5jaHJvbm91c1Jlc29sdmUgbmVlZHNcblxuXG4gICAgYXN5bmNocm9ub3VzUmVzb2x2ZSA9IChuZWVkcywgY2FsbGJhY2spLT5cbiAgICAgIGlmIG5lZWRzIGlzIFwiXCJcbiAgICAgICAgbmVlZHMgPSBbXVxuICAgICAgZWxzZSBpZiB0eXBlb2YgbmVlZHMgaXMgXCJzdHJpbmdcIlxuICAgICAgICBuZWVkcyA9IFtuZWVkc11cblxuICAgICAgdGFrZXIgPSBuZWVkczogbmVlZHMsIGNhbGxiYWNrOiBjYWxsYmFja1xuXG4gICAgICBpZiBhbGxOZWVkc0FyZU1ldCBuZWVkc1xuICAgICAgICB0YWtlcnNUb05vdGlmeS5wdXNoIHRha2VyXG4gICAgICAgIG1pY3JvdGFza3NOZWVkZWQrK1xuICAgICAgICB1bmxlc3MgYWxyZWFkeVdhaXRpbmdUb05vdGlmeVxuICAgICAgICAgIGFscmVhZHlXYWl0aW5nVG9Ob3RpZnkgPSB0cnVlXG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2sgbm90aWZ5VGFrZXJzICMgUHJlc2VydmUgYXN5bmNocm9ueVxuICAgICAgICAgIG1pY3JvdGFza3NVc2VkKytcbiAgICAgIGVsc2VcbiAgICAgICAgd2FpdGluZ1Rha2Vycy5wdXNoIHRha2VyXG5cblxuICAgIHN5bmNocm9ub3VzUmVzb2x2ZSA9IChuZWVkcyktPlxuICAgICAgaWYgdHlwZW9mIG5lZWRzIGlzIFwic3RyaW5nXCJcbiAgICAgICAgcmV0dXJuIG1hZGVbbmVlZHNdXG4gICAgICBlbHNlXG4gICAgICAgIG8gPSB7fVxuICAgICAgICBvW25dID0gbWFkZVtuXSBmb3IgbiBpbiBuZWVkc1xuICAgICAgICByZXR1cm4gb1xuXG5cbiAgICBub3RpZnlUYWtlcnMgPSAoKS0+XG4gICAgICBhbHJlYWR5V2FpdGluZ1RvTm90aWZ5ID0gZmFsc2VcbiAgICAgIHRha2VycyA9IHRha2Vyc1RvTm90aWZ5XG4gICAgICB0YWtlcnNUb05vdGlmeSA9IFtdXG4gICAgICBub3RpZnkgdGFrZXIgZm9yIHRha2VyIGluIHRha2Vyc1xuICAgICAgbnVsbFxuXG5cbiAgICBub3RpZnkgPSAodGFrZXIpLT5cbiAgICAgIHJlc29sdmVkTmVlZHMgPSB0YWtlci5uZWVkcy5tYXAgKG5hbWUpLT4gbWFkZVtuYW1lXVxuICAgICAgdGFrZXIuY2FsbGJhY2suYXBwbHkobnVsbCwgcmVzb2x2ZWROZWVkcylcblxuXG4gICAgIyBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBPYmplY3QuYXNzaWduKHt9LCBvYmopLCBzbyB3ZSBqdXN0IHVzZSBvdXIgb3duXG4gICAgY2xvbmUgPSAob2JqKS0+XG4gICAgICBvdXQgPSB7fVxuICAgICAgb3V0W2tdID0gdiBmb3Igayx2IG9mIG9ialxuICAgICAgb3V0XG5cblxuICAgICMgV2Ugd2FudCB0byBhZGQgYSBmZXcgaGFuZHkgb25lLXRpbWUgZXZlbnRzLlxuICAgICMgSG93ZXZlciwgd2UgZG9uJ3Qga25vdyBpZiB3ZSdsbCBiZSBydW5uaW5nIGluIGEgYnJvd3Nlciwgb3IgaW4gbm9kZS5cbiAgICAjIFRodXMsIHdlIGxvb2sgZm9yIHRoZSBwcmVzZW5jZSBvZiBhIFwid2luZG93XCIgb2JqZWN0IGFzIG91ciBjbHVlLlxuICAgIGlmIHdpbmRvdz9cblxuICAgICAgYWRkTGlzdGVuZXIgPSAoZXZlbnROYW1lKS0+XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIGV2ZW50TmFtZSwgaGFuZGxlciA9IChldmVudE9iamVjdCktPlxuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyIGV2ZW50TmFtZSwgaGFuZGxlclxuICAgICAgICAgIE1ha2UgZXZlbnROYW1lLCBldmVudE9iamVjdFxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQgIyBwcmV2ZW50IHVubG9hZCBmcm9tIG9wZW5pbmcgYSBwb3B1cFxuXG4gICAgICBhZGRMaXN0ZW5lciBcImJlZm9yZXVubG9hZFwiXG4gICAgICBhZGRMaXN0ZW5lciBcImNsaWNrXCJcbiAgICAgIGFkZExpc3RlbmVyIFwidW5sb2FkXCJcblxuICAgICAgIyBTaW5jZSB3ZSBoYXZlIGEgd2luZG93IG9iamVjdCwgaXQncyBwcm9iYWJseSBzYWZlIHRvIGFzc3VtZSB3ZSBoYXZlIGEgZG9jdW1lbnQgb2JqZWN0XG4gICAgICBzd2l0Y2ggZG9jdW1lbnQucmVhZHlTdGF0ZVxuICAgICAgICB3aGVuIFwibG9hZGluZ1wiXG4gICAgICAgICAgYWRkTGlzdGVuZXIgXCJET01Db250ZW50TG9hZGVkXCJcbiAgICAgICAgICBhZGRMaXN0ZW5lciBcImxvYWRcIlxuICAgICAgICB3aGVuIFwiaW50ZXJhY3RpdmVcIlxuICAgICAgICAgIE1ha2UgXCJET01Db250ZW50TG9hZGVkXCJcbiAgICAgICAgICBhZGRMaXN0ZW5lciBcImxvYWRcIlxuICAgICAgICB3aGVuIFwiY29tcGxldGVcIlxuICAgICAgICAgIE1ha2UgXCJET01Db250ZW50TG9hZGVkXCJcbiAgICAgICAgICBNYWtlIFwibG9hZFwiXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IgXCJVbmtub3duIGRvY3VtZW50LnJlYWR5U3RhdGU6ICN7ZG9jdW1lbnQucmVhZHlTdGF0ZX0uIENhbm5vdCBzZXR1cCBUYWtlJk1ha2UuXCJcblxuXG4gICAgIyBGaW5hbGx5LCB3ZSdyZSByZWFkeSB0byBoYW5kIG92ZXIgY29udHJvbCB0byBtb2R1bGUgc3lzdGVtc1xuICAgIGlmIG1vZHVsZT9cbiAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBUYWtlOiBUYWtlLFxuICAgICAgICBNYWtlOiBNYWtlLFxuICAgICAgICBEZWJ1Z1Rha2VNYWtlOiBEZWJ1Z1Rha2VNYWtlXG4gICAgICB9XG5cblxuIyBzdWJtb2R1bGUvYnVja2V0L2Fkc3IuY29mZmVlXG4jIEFEU1JcbiMgVGhpcyBnaXZlcyB5b3VyIGZ1bmN0aW9uIGFuIFwiYXR0YWNrXCIgcGhhc2UgYW5kIGEgXCJyZWxlYXNlXCIgcGhhc2VcbiMgKGJvcnJvd2luZyB0ZXJtaW5vbG9neSBmcm9tIEFEU1Igb24gc3ludGhlc2l6ZXJzKS5cbiMgVGhlIGF0dGFjayBwaGFzZSBpcyBhIGRlYm91bmNlIOKAlCB5b3VyIGZ1bmN0aW9uIHdpbGwgcnVuIGp1c3Qgb25jZSBhZnRlciB0aGUgYXR0YWNrIHBoYXNlIGVuZHMsXG4jIG5vIG1hdHRlciBob3cgbWFueSB0aW1lcyBpdCdzIGNhbGxlZCB1bnRpbCB0aGVuLlxuIyBXaGVuIHRoZSBmdW5jdGlvbiBydW5zLCBpdCdsbCB1c2UgdGhlIGFyZ3MgZnJvbSB0aGUgbW9zdCByZWNlbnQgdGltZSBpdCB3YXMgY2FsbGVkLlxuIyBUaGUgcmVsZWFzZSBpcyBhIHRocm90dGxlIOKAlCBpZiB5b3VyIGZ1bmN0aW9uIGlzIGNhbGxlZCBkdXJpbmcgdGhlIHJlbGVhc2UgcGhhc2UsXG4jIHRoZW4gYWZ0ZXIgdGhlIHJlbGVhc2UgcGhhc2UgZW5kcyB0aGUgYXR0YWNrIHBoYXNlIHdpbGwgc3RhcnQgb3ZlciBhZ2Fpbi5cbiMgVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcnVuIHNob3J0bHkgYWZ0ZXIgaXQncyBjYWxsZWQgKGdvb2QgZm9yIGZhc3QgcmVhY3Rpb25zKVxuIyBidXQgZG9lc24ndCBydW4gYWdhaW4gdW50aWwgYSB3aGlsZSBsYXRlciAoZ29vZCBmb3IgcmVkdWNpbmcgc3RyYWluKS5cbiMgQXR0YWNrIGFuZCByZWxlYXNlIGFyZSBzcGVjaWZpZWQgaW4gbXMsIGFuZCBhcmUgb3B0aW9uYWwuXG4jIElmIHlvdSBwYXNzIGEgdGltZSBvZiAwIG1zIGZvciBlaXRoZXIgdGhlIGF0dGFjaywgcmVsZWFzZSwgb3IgYm90aCwgdGhlIHBoYXNlIHdpbGwgbGFzdCB1bnRpbCB0aGUgbmV4dCBtaWNyb3Rhc2suXG4jIElmIHlvdSBwYXNzIGEgdGltZSBsZXNzIHRoYW4gNSBtcywgdGhlIHBoYXNlIHdpbGwgbGFzdCB1bnRpbCB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuXG4jIEl0J3MgaWRpb21hdGljIHRvIHBhc3MgYSB0aW1lIG9mIDEgbXMgaWYgeW91IHdhbnQgdGhlIG5leHQgZnJhbWUuXG4jIFdlIGFsc28ga2VlcCBhIGNvdW50IG9mIGhvdyBtYW55IGZ1bmN0aW9ucyBhcmUgY3VycmVudGx5IHdhaXRpbmcsIGFuZCBzdXBwb3J0IGFkZGluZyB3YXRjaGVyc1xuIyB0aGF0IHdpbGwgcnVuIGEgY2FsbGJhY2sgd2hlbiB0aGUgY291bnQgY2hhbmdlcywganVzdCBpbiBjYXNlIHlvdSB3YW50IHRvIChmb3IgZXhhbXBsZSlcbiMgd2FpdCBmb3IgdGhlbSBhbGwgdG8gZmluaXNoIGJlZm9yZSBxdWl0dGluZyAvIGNsb3NpbmcsIG9yIG1vbml0b3IgdGhlaXIgcGVyZm9ybWFuY2UuXG5cblRha2UgW10sICgpLT5cblxuICBhY3RpdmUgPSBuZXcgTWFwKClcbiAgd2F0Y2hlcnMgPSBbXVxuXG4gIE1ha2UuYXN5bmMgXCJBRFNSXCIsIEFEU1IgPSAoLi4uW2F0dGFjayA9IDAsIHJlbGVhc2UgPSAwXSwgZm4pLT4gKC4uLmFyZ3MpLT5cbiAgICBpZiBub3QgYWN0aXZlLmhhcyBmblxuICAgICAgYWZ0ZXJEZWxheSBhdHRhY2ssIGFmdGVyQXR0YWNrIGZuLCBhdHRhY2ssIHJlbGVhc2VcbiAgICAgIEFEU1IuY291bnQrK1xuICAgICAgdXBkYXRlV2F0Y2hlcnMoKVxuICAgIGFjdGl2ZS5zZXQgZm4sIHthcmdzfSAjIEFsd2F5cyB1c2UgdGhlIG1vc3QgcmVjZW50IGFyZ3NcblxuICBBRFNSLmNvdW50ID0gMFxuXG4gIEFEU1Iud2F0Y2hlciA9ICh3YXRjaGVyKS0+XG4gICAgd2F0Y2hlcnMucHVzaCB3YXRjaGVyXG5cbiAgYWZ0ZXJBdHRhY2sgPSAoZm4sIGF0dGFjaywgcmVsZWFzZSktPiAoKS0+XG4gICAge2FyZ3N9ID0gYWN0aXZlLmdldCBmblxuICAgIGFjdGl2ZS5zZXQgZm4sIHt9XG4gICAgZm4gLi4uYXJnc1xuICAgIGFmdGVyRGVsYXkgcmVsZWFzZSwgYWZ0ZXJSZWxlYXNlIGZuLCBhdHRhY2ssIHJlbGVhc2VcblxuICBhZnRlclJlbGVhc2UgPSAoZm4sIGF0dGFjaywgcmVsZWFzZSktPiAoKS0+XG4gICAge2FyZ3N9ID0gYWN0aXZlLmdldCBmblxuICAgIGlmIGFyZ3NcbiAgICAgIGFmdGVyRGVsYXkgYXR0YWNrLCBhZnRlckF0dGFjayBmbiwgYXR0YWNrLCByZWxlYXNlXG4gICAgZWxzZVxuICAgICAgYWN0aXZlLmRlbGV0ZSBmblxuICAgICAgQURTUi5jb3VudC0tXG4gICAgICB1cGRhdGVXYXRjaGVycygpXG5cbiAgYWZ0ZXJEZWxheSA9IChkZWxheSA9IDAsIGNiKS0+XG4gICAgaWYgZGVsYXkgaXMgMFxuICAgICAgcXVldWVNaWNyb3Rhc2sgY2JcbiAgICBlbHNlIGlmIGRlbGF5IDwgNVxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGNiXG4gICAgZWxzZVxuICAgICAgc2V0VGltZW91dCBjYiwgZGVsYXlcblxuICB1cGRhdGVXYXRjaGVycyA9ICgpLT5cbiAgICB3YXRjaGVyIEFEU1IuY291bnQgZm9yIHdhdGNoZXIgaW4gd2F0Y2hlcnNcbiAgICBudWxsXG5cblxuIyBzdWJtb2R1bGUvYnVja2V0L21vbmtleS1wYXRjaC5jb2ZmZWVcbiMgTW9ua2V5IFBhdGNoXG4jIFRoZSBKUyBzdGFuZGFyZCBsaWJyYXJ5IGxlYXZlcyBhIGxvdCB0byBiZSBkZXNpcmVkLCBzbyBsZXQncyBjYXJlZnVsbHkgKHNlZSBib3R0b20gb2YgZmlsZSlcbiMgbW9kaWZ5IHRoZSBidWlsdC1pbiBjbGFzc2VzIHRvIGFkZCBhIGZldyBoZWxwZnVsIG1ldGhvZHMuXG5cbmRvICgpLT5cbiAgbW9ua2V5UGF0Y2hlcyA9XG5cbiAgICBBcnJheTpcbiAgICAgIHR5cGU6ICh2KS0+IHYgaW5zdGFuY2VvZiBBcnJheVxuXG4gICAgICAjIFNvcnRpbmdcbiAgICAgIG51bWVyaWNTb3J0QXNjZW5kaW5nOiAoYSwgYiktPiBhIC0gYlxuICAgICAgbnVtZXJpY1NvcnREZXNjZW5kaW5nOiAoYSwgYiktPiBiIC0gYVxuICAgICAgc29ydEFscGhhYmV0aWM6IChhcnIpLT4gYXJyLnNvcnQgQXJyYXkuYWxwaGFiZXRpY1NvcnQgPz0gbmV3IEludGwuQ29sbGF0b3IoJ2VuJykuY29tcGFyZVxuICAgICAgc29ydE51bWVyaWNBc2NlbmRpbmc6IChhcnIpLT4gYXJyLnNvcnQgQXJyYXkubnVtZXJpY1NvcnRBc2NlbmRpbmdcbiAgICAgIHNvcnROdW1lcmljRGVzY2VuZGluZzogKGFyciktPiBhcnIuc29ydCBBcnJheS5udW1lcmljU29ydERlc2NlbmRpbmdcblxuICAgICAgIyBBY2Nlc3NpbmdcbiAgICAgIGZpcnN0OiAoYXJyKS0+IGFyclswXVxuICAgICAgc2Vjb25kOiAoYXJyKS0+IGFyclsxXVxuICAgICAgbGFzdDogKGFyciktPiBhcnJbYXJyLmxlbmd0aC0xXVxuICAgICAgcmVzdDogKGFyciktPiBhcnJbMS4uLl1cbiAgICAgIGJ1dExhc3Q6IChhcnIpLT4gYXJyWy4uLi0xXVxuXG4gICAgICAjIE1pc2NcblxuICAgICAgY2xvbmU6IChhcnIpLT5cbiAgICAgICAgYXJyLm1hcCBGdW5jdGlvbi5jbG9uZVxuXG4gICAgICBlbXB0eTogKGFyciktPlxuICAgICAgICBub3QgYXJyPyBvciBhcnIubGVuZ3RoIGlzIDBcblxuICAgICAgZXF1YWw6IChhLCBiKS0+XG4gICAgICAgIHJldHVybiB0cnVlIGlmIE9iamVjdC5pcyBhLCBiXG4gICAgICAgIHJldHVybiBmYWxzZSB1bmxlc3MgQXJyYXkudHlwZShhKSBhbmQgQXJyYXkudHlwZShiKSBhbmQgYS5sZW5ndGggaXMgYi5sZW5ndGhcbiAgICAgICAgZm9yIGFpLCBpIGluIGFcbiAgICAgICAgICBiaSA9IGJbaV1cbiAgICAgICAgICBpZiBGdW5jdGlvbi5lcXVhbCBhaSwgYmlcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgIG1hcFRvT2JqZWN0OiAoYXJyLCBmbiA9IEZ1bmN0aW9uLmlkZW50aXR5KS0+XG4gICAgICAgIG8gPSB7fVxuICAgICAgICBvW2tdID0gZm4gayBmb3IgayBpbiBhcnJcbiAgICAgICAgb1xuXG4gICAgICBwdWxsOiAoYXJyLCBlbG1zKS0+XG4gICAgICAgIHJldHVybiB1bmxlc3MgYXJyPyBhbmQgZWxtcz9cbiAgICAgICAgZWxtcyA9IFtlbG1zXSB1bmxlc3MgQXJyYXkudHlwZSBlbG1zXG4gICAgICAgIGZvciBlbG0gaW4gZWxtc1xuICAgICAgICAgIHdoaWxlIChpID0gYXJyLmluZGV4T2YgZWxtKSA+IC0xXG4gICAgICAgICAgICBhcnIuc3BsaWNlIGksIDFcbiAgICAgICAgYXJyXG5cbiAgICAgIHNlYXJjaDogKGFyciwga2V5KS0+XG4gICAgICAgIGZvciB2IGluIGFyclxuICAgICAgICAgIGlmIEFycmF5LnR5cGUgdlxuICAgICAgICAgICAgcmV0dXJuIHRydWUgaWYgQXJyYXkuc2VhcmNoIHYsIGtleVxuICAgICAgICAgIGVsc2UgaWYgT2JqZWN0LnR5cGUgdlxuICAgICAgICAgICAgcmV0dXJuIHRydWUgaWYgT2JqZWN0LnNlYXJjaCB2LCBrZXlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgIHNodWZmbGU6IChhcnIpLT5cbiAgICAgICAgbmV3QXJyID0gW11cbiAgICAgICAgZm9yIGl0ZW0sIGkgaW4gYXJyXG4gICAgICAgICAgbmV3QXJyLnNwbGljZSBNYXRoLnJhbmRJbnQoMCwgbmV3QXJyLmxlbmd0aCksIDAsIGl0ZW1cbiAgICAgICAgcmV0dXJuIG5ld0FyclxuXG4gICAgICB1bmlxdWU6IChlbGVtZW50cyktPlxuICAgICAgICBBcnJheS5mcm9tIG5ldyBTZXQgW10uY29uY2F0IGVsZW1lbnRzXG5cblxuICAgIEZ1bmN0aW9uOlxuICAgICAgdHlwZTogKHYpLT4gdiBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICBpZGVudGl0eTogKHYpLT4gdlxuXG4gICAgICBleGlzdHM6IChlKS0+IGU/XG4gICAgICBub3RFeGlzdHM6IChlKS0+ICFlP1xuICAgICAgaXM6IChhLCBiKS0+IGEgaXMgYlxuICAgICAgaXNudDogKGEsIGIpLT4gYSBpc250IGJcbiAgICAgIGVxdWFsOiAoYSwgYiktPlxuICAgICAgICBpZiBPYmplY3QuaXMgYSwgYlxuICAgICAgICAgIHRydWVcbiAgICAgICAgZWxzZSBpZiBBcnJheS50eXBlKGEpIGFuZCBBcnJheS50eXBlKGIpXG4gICAgICAgICAgdHJ1ZSBpZiBBcnJheS5lcXVhbCBhLCBiXG4gICAgICAgIGVsc2UgaWYgT2JqZWN0LnR5cGUoYSkgYW5kIE9iamVjdC50eXBlKGIpXG4gICAgICAgICAgdHJ1ZSBpZiBPYmplY3QuZXF1YWwgYSwgYlxuICAgICAgICBlbHNlXG4gICAgICAgICAgZmFsc2VcbiAgICAgIGVxdWl2YWxlbnQ6IChhLCBiKS0+IGBhID09IGJgIG9yIEZ1bmN0aW9uLmVxdWFsIGEsIGIgIyBMaWtlIGVxdWFsLCBidXQgYWxzbyBlcXVhdGVzIG51bGwgJiB1bmRlZmluZWQsIC0wICYgMCwgZXRjXG4gICAgICBub3RFcXVhbDogKGEsIGIpLT4gIUZ1bmN0aW9uLmVxdWFsIGEsIGJcbiAgICAgIG5vdEVxdWl2YWxlbnQ6IChhLCBiKS0+ICFGdW5jdGlvbi5lcXVpdmFsZW50IGEsIGJcblxuICAgICAgY2xvbmU6ICh2KS0+XG4gICAgICAgIGlmIG5vdCB2P1xuICAgICAgICAgIHZcbiAgICAgICAgZWxzZSBpZiBGdW5jdGlvbi50eXBlIHZcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IgXCJJZiB5b3UgbmVlZCB0byBjbG9uZSBmdW5jdGlvbnMsIHVzZSBhIGN1c3RvbSBjbG9uZXJcIlxuICAgICAgICBlbHNlIGlmIFByb21pc2UudHlwZSB2XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yIFwiSWYgeW91IG5lZWQgdG8gY2xvbmUgcHJvbWlzZXMsIHVzZSBhIGN1c3RvbSBjbG9uZXJcIlxuICAgICAgICBlbHNlIGlmIEFycmF5LnR5cGUgdlxuICAgICAgICAgIEFycmF5LmNsb25lIHZcbiAgICAgICAgZWxzZSBpZiBPYmplY3QudHlwZSB2XG4gICAgICAgICAgT2JqZWN0LmNsb25lIHZcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHZcblxuXG4gICAgTWF0aDpcblxuICAgICAgVEFVOiBNYXRoLlBJICogMlxuXG4gICAgICB6ZXJvOiAodiktPiBNYXRoLkVQU0lMT04gPiBNYXRoLmFicyB2XG4gICAgICBub256ZXJvOiAodiktPiBub3QgTWF0aC56ZXJvIHZcblxuICAgICAgYWRkOiAoYSwgYiktPiBhICsgYlxuICAgICAgZGl2OiAoYSwgYiktPiBhIC8gYlxuICAgICAgbW9kOiAoYSwgYiktPiBhICUgYlxuICAgICAgbXVsOiAoYSwgYiktPiBhICogYlxuICAgICAgc3ViOiAoYSwgYiktPiBhIC0gYlxuXG4gICAgICBhdmc6IChhLCBiKS0+IChhICsgYikvMlxuXG4gICAgICBjbGlwOiAodiwgLi4uW21pbiA9IDBdLCBtYXggPSAxKS0+IE1hdGgubWluIG1heCwgTWF0aC5tYXggbWluLCB2XG4gICAgICBzYXQ6ICh2KSAtPiBNYXRoLmNsaXAgdlxuXG4gICAgICBsZXJwTjogKGlucHV0LCBvdXRwdXRNaW4gPSAwLCBvdXRwdXRNYXggPSAxLCBjbGlwID0gZmFsc2UpLT5cbiAgICAgICAgaW5wdXQgKj0gb3V0cHV0TWF4IC0gb3V0cHV0TWluXG4gICAgICAgIGlucHV0ICs9IG91dHB1dE1pblxuICAgICAgICBpbnB1dCA9IE1hdGguY2xpcCBpbnB1dCwgb3V0cHV0TWluLCBvdXRwdXRNYXggaWYgY2xpcFxuICAgICAgICByZXR1cm4gaW5wdXRcblxuICAgICAgbGVycDogKGlucHV0LCBpbnB1dE1pbiA9IDAsIGlucHV0TWF4ID0gMSwgb3V0cHV0TWluID0gMCwgb3V0cHV0TWF4ID0gMSwgY2xpcCA9IHRydWUpLT5cbiAgICAgICAgcmV0dXJuIG91dHB1dE1pbiBpZiBpbnB1dE1pbiBpcyBpbnB1dE1heCAjIEF2b2lkcyBhIGRpdmlkZSBieSB6ZXJvXG4gICAgICAgIFtpbnB1dE1pbiwgaW5wdXRNYXgsIG91dHB1dE1pbiwgb3V0cHV0TWF4XSA9IFtpbnB1dE1heCwgaW5wdXRNaW4sIG91dHB1dE1heCwgb3V0cHV0TWluXSBpZiBpbnB1dE1pbiA+IGlucHV0TWF4XG4gICAgICAgIGlucHV0ID0gTWF0aC5jbGlwIGlucHV0LCBpbnB1dE1pbiwgaW5wdXRNYXggaWYgY2xpcFxuICAgICAgICBpbnB1dCAtPSBpbnB1dE1pblxuICAgICAgICBpbnB1dCAvPSBpbnB1dE1heCAtIGlucHV0TWluXG4gICAgICAgIHJldHVybiBNYXRoLmxlcnBOIGlucHV0LCBvdXRwdXRNaW4sIG91dHB1dE1heCwgZmFsc2VcblxuICAgICAgcmFuZDogKG1pbiA9IC0xLCBtYXggPSAxKS0+IE1hdGgubGVycE4gTWF0aC5yYW5kb20oKSwgbWluLCBtYXhcbiAgICAgIHJhbmRJbnQ6IChtaW4sIG1heCktPiBNYXRoLnJvdW5kIE1hdGgucmFuZCBtaW4sIG1heFxuXG4gICAgICByb3VuZFRvOiAoaW5wdXQsIHByZWNpc2lvbiktPlxuICAgICAgICAjIFVzaW5nIHRoZSByZWNpcHJvY2FsIGF2b2lkcyBmbG9hdGluZyBwb2ludCBlcnJvcnMuIEVnOiAzLzEwIGlzIGZpbmUsIGJ1dCAzKjAuMSBpcyB3cm9uZy5cbiAgICAgICAgcCA9IDEgLyBwcmVjaXNpb25cbiAgICAgICAgTWF0aC5yb3VuZChpbnB1dCAqIHApIC8gcFxuXG5cbiAgICBPYmplY3Q6XG4gICAgICB0eXBlOiAodiktPiBcIltvYmplY3QgT2JqZWN0XVwiIGlzIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCB2XG5cbiAgICAgICMgVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgYSBmdW5jdGlvbiBvbiBBcnJheSwgYXMgYSBtaXJyb3Igb2YgT2JqZWN0LmtleXMgLyBPYmplY3QudmFsdWVzLlxuICAgICAgIyBJbiBnZW5lcmFsLCBmdW5jdGlvbnMgdGhhdCB0YWtlIGFuIGFycmF5IGdvIG9uIEFycmF5LCBldmVuIGlmIHRoZXkgcmV0dXJuIGEgZGlmZmVyZW50IHR5cGUuXG4gICAgICBieTogKGssIGFyciktPiAjIE9iamVjdC5ieSBcIm5hbWVcIiwgW3tuYW1lOlwiYVwifSwge25hbWU6XCJiXCJ9XSA9PiB7YTp7bmFtZTpcImFcIn0sIGI6e25hbWU6XCJiXCJ9fVxuICAgICAgICBvID0ge31cbiAgICAgICAgb1tvYmpba11dID0gb2JqIGZvciBvYmogaW4gYXJyXG4gICAgICAgIHJldHVybiBvXG5cbiAgICAgIGNsb25lOiAob2JqKS0+XG4gICAgICAgIE9iamVjdC5tYXBWYWx1ZXMgb2JqLCBGdW5jdGlvbi5jbG9uZVxuXG4gICAgICBjb3VudDogKG9iaiktPlxuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmxlbmd0aFxuXG4gICAgICBlcXVhbDogKGEsIGIpLT5cbiAgICAgICAgcmV0dXJuIHRydWUgaWYgT2JqZWN0LmlzIGEsIGJcbiAgICAgICAgcmV0dXJuIGZhbHNlIHVubGVzcyAoYT8gYW5kIGI/KSBhbmQgKHt9LmNvbnN0cnVjdG9yIGlzIGEuY29uc3RydWN0b3IgaXMgYi5jb25zdHJ1Y3RvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlIHVubGVzcyBPYmplY3Qua2V5cyhhKS5sZW5ndGggaXMgT2JqZWN0LmtleXMoYikubGVuZ3RoXG4gICAgICAgIGZvciBrLCBhdiBvZiBhXG4gICAgICAgICAgYnYgPSBiW2tdXG4gICAgICAgICAgaWYgRnVuY3Rpb24uZXF1YWwgYXYsIGJ2XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICBtYXBLZXlzOiAob2JqLCBmbiA9IEZ1bmN0aW9uLmlkZW50aXR5KS0+XG4gICAgICAgIG8gPSB7fVxuICAgICAgICBvW2tdID0gZm4gayBmb3IgayBvZiBvYmpcbiAgICAgICAgb1xuXG4gICAgICBtYXBWYWx1ZXM6IChvYmosIGZuID0gRnVuY3Rpb24uaWRlbnRpdHkpLT5cbiAgICAgICAgbyA9IHt9XG4gICAgICAgIG9ba10gPSBmbiB2IGZvciBrLCB2IG9mIG9ialxuICAgICAgICBvXG5cbiAgICAgIG1lcmdlOiAob2Jqcy4uLiktPlxuICAgICAgICBvdXQgPSB7fVxuICAgICAgICBmb3Igb2JqIGluIG9ianMgd2hlbiBvYmo/XG4gICAgICAgICAgZm9yIGssIHYgb2Ygb2JqXG4gICAgICAgICAgICAjIERPIE5PVCBhZGQgYW55IGFkZGl0aW9uYWwgbG9naWMgZm9yIG1lcmdpbmcgb3RoZXIgdHlwZXMgKGxpa2UgYXJyYXlzKSxcbiAgICAgICAgICAgICMgb3IgZXhpc3RpbmcgYXBwcyB3aWxsIGJyZWFrIChIeXBlcnppbmUsIEhlc3QsIGV0Yy4pXG4gICAgICAgICAgICAjIElmIHlvdSB3YW50IHRvIGRlZXAgbWVyZ2Ugb3RoZXIgdHlwZXMsIHdyaXRlIGEgY3VzdG9tIG1lcmdlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgb3V0W2tdID0gaWYgT2JqZWN0LnR5cGUgdlxuICAgICAgICAgICAgICBPYmplY3QubWVyZ2Ugb3V0W2tdLCB2XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHZcbiAgICAgICAgb3V0XG5cbiAgICAgIHJtZXJnZTogKG9ianMuLi4pLT5cbiAgICAgICAgT2JqZWN0Lm1lcmdlIG9ianMucmV2ZXJzZSgpLi4uXG5cbiAgICAgIHNlYXJjaDogKG9iaiwga2V5KS0+XG4gICAgICAgIHJldHVybiB0cnVlIGlmIG9ialtrZXldP1xuICAgICAgICBmb3IgaywgdiBvZiBvYmpcbiAgICAgICAgICBpZiBBcnJheS50eXBlIHZcbiAgICAgICAgICAgIHJldHVybiB0cnVlIGlmIEFycmF5LnNlYXJjaCB2LCBrZXlcbiAgICAgICAgICBlbHNlIGlmIE9iamVjdC50eXBlIHZcbiAgICAgICAgICAgIHJldHVybiB0cnVlIGlmIE9iamVjdC5zZWFyY2ggdiwga2V5XG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICBzdWJ0cmFjdEtleXM6IChhLCBiKS0+XG4gICAgICAgIG8gPSBPYmplY3QubWFwS2V5cyBhICMgc2hhbGxvdyBjbG9uZVxuICAgICAgICBkZWxldGUgb1trXSBmb3IgayBvZiBiXG4gICAgICAgIG9cblxuXG4gICAgUHJvbWlzZTpcbiAgICAgIHR5cGU6ICh2KS0+IHYgaW5zdGFuY2VvZiBQcm9taXNlXG5cbiAgICAgIHRpbWVvdXQ6ICh0KS0+IG5ldyBQcm9taXNlIChyZXNvbHZlKS0+IHNldFRpbWVvdXQgcmVzb2x2ZSwgdFxuXG5cbiAgICBTdHJpbmc6XG4gICAgICB0eXBlOiAodiktPiBcInN0cmluZ1wiIGlzIHR5cGVvZiB2XG5cbiAgICAgICMgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUyMTcxNDgwLzMxMzU3NiwgcHVibGljIGRvbWFpblxuICAgICAgaGFzaDogKHN0ciwgc2VlZCA9IDApLT5cbiAgICAgICAgcmV0dXJuIDAgdW5sZXNzIHN0cj9cbiAgICAgICAgaDEgPSAweGRlYWRiZWVmIF4gc2VlZFxuICAgICAgICBoMiA9IDB4NDFjNmNlNTcgXiBzZWVkXG4gICAgICAgIGZvciBjIGluIHN0clxuICAgICAgICAgIGNoID0gYy5jaGFyQ29kZUF0IDBcbiAgICAgICAgICBoMSA9IE1hdGguaW11bCBoMSBeIGNoLCAyNjU0NDM1NzYxXG4gICAgICAgICAgaDIgPSBNYXRoLmltdWwgaDIgXiBjaCwgMTU5NzMzNDY3N1xuICAgICAgICBoMSA9IE1hdGguaW11bChoMSBeIChoMT4+PjE2KSwgMjI0NjgyMjUwNykgXiBNYXRoLmltdWwoaDIgXiAoaDI+Pj4xMyksIDMyNjY0ODk5MDkpXG4gICAgICAgIGgyID0gTWF0aC5pbXVsKGgyIF4gKGgyPj4+MTYpLCAyMjQ2ODIyNTA3KSBeIE1hdGguaW11bChoMSBeIChoMT4+PjEzKSwgMzI2NjQ4OTkwOSlcbiAgICAgICAgcmV0dXJuIDQyOTQ5NjcyOTYgKiAoMjA5NzE1MSAmIGgyKSArIChoMT4+PjApXG5cbiAgICAgIHBsdXJhbGl6ZTogKGNvdW50LCBzdHJpbmcsIHN1ZmZpeCA9IFwic1wiKS0+XG4gICAgICAgIHN1ZmZpeCA9IFwiXCIgaWYgY291bnQgaXMgMVxuICAgICAgICAoc3RyaW5nICsgc3VmZml4KS5yZXBsYWNlKFwiJSVcIiwgY291bnQpXG5cbiAgICAgIHRvS2ViYWJDYXNlOiAodiktPlxuICAgICAgICB2LnJlcGxhY2UoLyhbQS1aXSkvZyxcIi0kMVwiKS50b0xvd2VyQ2FzZSgpXG5cblxuICAjIEluaXRcblxuICBmb3IgY2xhc3NOYW1lLCBjbGFzc1BhdGNoZXMgb2YgbW9ua2V5UGF0Y2hlc1xuICAgIGdsb2JhbGNsYXNzID0gZ2xvYmFsVGhpc1tjbGFzc05hbWVdXG4gICAgZm9yIGtleSwgdmFsdWUgb2YgY2xhc3NQYXRjaGVzXG4gICAgICBpZiBnbG9iYWxjbGFzc1trZXldP1xuICAgICAgICBjb25zb2xlLmxvZyBcIkNhbid0IG1vbmtleSBwYXRjaCAje2NsYXNzTmFtZX0uI3trZXl9IGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXCJcbiAgICAgIGVsc2VcbiAgICAgICAgZ2xvYmFsY2xhc3Nba2V5XSA9IHZhbHVlXG5cblxuIyBzdWJtb2R1bGUvYnVja2V0L3Rlc3QuY29mZmVlXG5UZXN0cyA9IFRlc3QgPSBudWxsXG5cbmRvICgpLT5cbiAgY29udGV4dCA9IG51bGxcblxuICBUZXN0cyA9IChuYW1lLCB0ZXN0KS0+XG4gICAgY29udGV4dCA9ICgpLT4gY29uc29sZS5ncm91cCBcIiVjI3tuYW1lfVwiLCBcImNvbG9yOiByZWRcIjsgY29udGV4dCA9IG51bGxcbiAgICB0ZXN0KClcbiAgICBjb25zb2xlLmdyb3VwRW5kKClcbiAgICBjb250ZXh0ID0gbnVsbFxuXG4gIFRlc3QgPSAobmFtZSwgLi4uc3R1ZmYpLT5cblxuICAgICMgSWYgd2UndmUgYmVlbiBwYXNzZWQgYW55IGZ1bmN0aW9ucywgcnVuIHRoZW0gYW5kIGNhcHR1cmUgdGhlIHJldHVybiB2YWx1ZXMuXG4gICAgZm9yIHRoaW5nLCBpIGluIHN0dWZmIHdoZW4gRnVuY3Rpb24udHlwZSB0aGluZ1xuICAgICAgc3R1ZmZbaV0gPSB0aGluZygpXG5cbiAgICAjIElmIHRoZXJlJ3Mgb25seSBvbmUgdGhpbmcgaW4gc3R1ZmYsIGp1c3QgY29tcGFyZSBpdCB3aXRoIHRydWVcbiAgICBpZiBzdHVmZi5sZW5ndGggaXMgMVxuICAgICAgc3R1ZmYudW5zaGlmdCB0cnVlXG5cbiAgICAjIE5vdywgYWxsIHRoaW5ncyBpbiBzdHVmZiBtdXN0IGFsbCBiZSBlcXVpdmFsZW50LiBPciBlbHNlLlxuICAgICMgKFRoaXMgdGVzdCBmcmFtZXdvcmsgaXMgc3VwZXIgY2FzdWFsLCBzbyB3ZSBqdXN0IGNoZWNrIGVhY2ggbmVpZ2hib3VyaW5nIHBhaXIpXG4gICAgZm9yIHRoaW5nLCBpIGluIEFycmF5LmJ1dExhc3Qgc3R1ZmZcbiAgICAgIHVubGVzcyBGdW5jdGlvbi5lcXVpdmFsZW50IHRoaW5nLCBzdHVmZltpKzFdXG4gICAgICAgIGNvbnRleHQ/KClcbiAgICAgICAgY29uc29sZS5ncm91cCBcIiVjI3tuYW1lfVwiLCBcImZvbnQtd2VpZ2h0Om5vcm1hbDtcIlxuICAgICAgICBjb25zb2xlLmxvZyBcInRoaXM6XCIsIHRoaW5nXG4gICAgICAgIGNvbnNvbGUubG9nIFwiaXNudDpcIiwgc3R1ZmZbaSsxXVxuICAgICAgICBjb25zb2xlLmdyb3VwRW5kKClcblxuXG4jIG5vZGVfbW9kdWxlcy9kb29tL2Rvb20uY29mZmVlXG5kbyAoKS0+XG5cbiAgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgeGxpbmtOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiXG5cbiAgIyBUaGlzIGlzIHVzZWQgdG8gY2FjaGUgbm9ybWFsaXplZCBrZXlzLCBhbmQgdG8gcHJvdmlkZSBkZWZhdWx0cyBmb3Iga2V5cyB0aGF0IHNob3VsZG4ndCBiZSBub3JtYWxpemVkXG4gIGF0dHJOYW1lcyA9XG4gICAgZ3JhZGllbnRVbml0czogXCJncmFkaWVudFVuaXRzXCJcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcInByZXNlcnZlQXNwZWN0UmF0aW9cIlxuICAgIHN0YXJ0T2Zmc2V0OiBcInN0YXJ0T2Zmc2V0XCJcbiAgICB2aWV3Qm94OiBcInZpZXdCb3hcIlxuICAgICMgY29tbW9uIGNhc2Utc2Vuc2l0aXZlIGF0dHIgbmFtZXMgc2hvdWxkIGJlIGxpc3RlZCBoZXJlIGFzIG5lZWRlZCDigJQgc2VlIHN2Zy5jb2ZlZSBpbiBodHRwczovL2dpdGh1Yi5jb20vY2RpZy9zdmcgZm9yIHJlZmVyZW5jZVxuXG4gIGV2ZW50TmFtZXMgPVxuICAgIGJsdXI6IHRydWVcbiAgICBjaGFuZ2U6IHRydWVcbiAgICBjbGljazogdHJ1ZVxuICAgIGZvY3VzOiB0cnVlXG4gICAgaW5wdXQ6IHRydWVcbiAgICBrZXlkb3duOiB0cnVlXG4gICAga2V5cHJlc3M6IHRydWVcbiAgICBrZXl1cDogdHJ1ZVxuICAgIG1vdXNlZG93bjogdHJ1ZVxuICAgIG1vdXNlZW50ZXI6IHRydWVcbiAgICBtb3VzZWxlYXZlOiB0cnVlXG4gICAgbW91c2Vtb3ZlOiB0cnVlXG4gICAgbW91c2V1cDogdHJ1ZVxuICAgIHNjcm9sbDogdHJ1ZVxuXG4gIHByb3BOYW1lcyA9XG4gICAgY2hpbGROb2RlczogdHJ1ZVxuICAgIGZpcnN0Q2hpbGQ6IHRydWVcbiAgICBpbm5lckhUTUw6IHRydWVcbiAgICBsYXN0Q2hpbGQ6IHRydWVcbiAgICBuZXh0U2libGluZzogdHJ1ZVxuICAgIHBhcmVudEVsZW1lbnQ6IHRydWVcbiAgICBwYXJlbnROb2RlOiB0cnVlXG4gICAgcHJldmlvdXNTaWJsaW5nOiB0cnVlXG4gICAgdGV4dENvbnRlbnQ6IHRydWVcbiAgICB2YWx1ZTogdHJ1ZVxuXG4gIHN0eWxlTmFtZXMgPVxuICAgIGFuaW1hdGlvbjogdHJ1ZVxuICAgIGFuaW1hdGlvbkRlbGF5OiB0cnVlXG4gICAgYmFja2dyb3VuZDogdHJ1ZVxuICAgIGJvcmRlclJhZGl1czogdHJ1ZVxuICAgIGNvbG9yOiB0cnVlXG4gICAgZGlzcGxheTogdHJ1ZVxuICAgIGZvbnRTaXplOiBcImh0bWxcIiAjIE9ubHkgdHJlYXQgYXMgYSBzdHlsZSBpZiB0aGlzIGlzIGFuIEhUTUwgZWxtLiBTVkcgZWxtcyB3aWxsIHRyZWF0IHRoaXMgYXMgYW4gYXR0cmlidXRlLlxuICAgIGZvbnRGYW1pbHk6IHRydWVcbiAgICBmb250V2VpZ2h0OiB0cnVlXG4gICAgaGVpZ2h0OiBcImh0bWxcIlxuICAgIGxlZnQ6IHRydWVcbiAgICBsZXR0ZXJTcGFjaW5nOiB0cnVlXG4gICAgbGluZUhlaWdodDogdHJ1ZVxuICAgIG1heEhlaWdodDogdHJ1ZVxuICAgIG1heFdpZHRoOiB0cnVlXG4gICAgbWFyZ2luOiB0cnVlXG4gICAgbWFyZ2luVG9wOiB0cnVlXG4gICAgbWFyZ2luTGVmdDogdHJ1ZVxuICAgIG1hcmdpblJpZ2h0OiB0cnVlXG4gICAgbWFyZ2luQm90dG9tOiB0cnVlXG4gICAgbWluV2lkdGg6IHRydWVcbiAgICBtaW5IZWlnaHQ6IHRydWVcbiAgICBvcGFjaXR5OiBcImh0bWxcIlxuICAgIG92ZXJmbG93OiB0cnVlXG4gICAgb3ZlcmZsb3dYOiB0cnVlXG4gICAgb3ZlcmZsb3dZOiB0cnVlXG4gICAgcGFkZGluZzogdHJ1ZVxuICAgIHBhZGRpbmdUb3A6IHRydWVcbiAgICBwYWRkaW5nTGVmdDogdHJ1ZVxuICAgIHBhZGRpbmdSaWdodDogdHJ1ZVxuICAgIHBhZGRpbmdCb3R0b206IHRydWVcbiAgICBwb2ludGVyRXZlbnRzOiB0cnVlXG4gICAgcG9zaXRpb246IHRydWVcbiAgICB0ZXh0RGVjb3JhdGlvbjogdHJ1ZVxuICAgIHRvcDogdHJ1ZVxuICAgIHRyYW5zZm9ybTogXCJodG1sXCJcbiAgICB0cmFuc2l0aW9uOiB0cnVlXG4gICAgdmlzaWJpbGl0eTogdHJ1ZVxuICAgIHdpZHRoOiBcImh0bWxcIlxuICAgIHpJbmRleDogdHJ1ZVxuXG4gICMgV2hlbiBjcmVhdGluZyBhbiBlbGVtZW50LCBTVkcgZWxlbWVudHMgcmVxdWlyZSBhIHNwZWNpYWwgbmFtZXNwYWNlLCBzbyB3ZSB1c2UgdGhpcyBsaXN0IHRvIGtub3cgd2hldGhlciBhIHRhZyBuYW1lIGlzIGZvciBhbiBTVkcgb3Igbm90XG4gIHN2Z0VsbXMgPVxuICAgIGNpcmNsZTogdHJ1ZVxuICAgIGNsaXBQYXRoOiB0cnVlXG4gICAgZGVmczogdHJ1ZVxuICAgIGVsbGlwc2U6IHRydWVcbiAgICBnOiB0cnVlXG4gICAgaW1hZ2U6IHRydWVcbiAgICBsaW5lOiB0cnVlXG4gICAgbGluZWFyR3JhZGllbnQ6IHRydWVcbiAgICBtYXNrOiB0cnVlXG4gICAgcGF0aDogdHJ1ZVxuICAgIHBvbHlnb246IHRydWVcbiAgICBwb2x5bGluZTogdHJ1ZVxuICAgIHJhZGlhbEdyYWRpZW50OiB0cnVlXG4gICAgcmVjdDogdHJ1ZVxuICAgIHN0b3A6IHRydWVcbiAgICBzdmc6IHRydWVcbiAgICBzeW1ib2w6IHRydWVcbiAgICB0ZXh0OiB0cnVlXG4gICAgdGV4dFBhdGg6IHRydWVcbiAgICB0c3BhbjogdHJ1ZVxuICAgIHVzZTogdHJ1ZVxuXG5cbiAgcmVhZCA9IChlbG0sIGspLT5cbiAgICBpZiBwcm9wTmFtZXNba10/XG4gICAgICBjYWNoZSA9IGVsbS5fRE9PTV9wcm9wXG4gICAgICBjYWNoZVtrXSA9IGVsbVtrXSBpZiBjYWNoZVtrXSBpcyB1bmRlZmluZWRcbiAgICAgIGNhY2hlW2tdXG4gICAgZWxzZSBpZiBzdHlsZU5hbWVzW2tdP1xuICAgICAgY2FjaGUgPSBlbG0uX0RPT01fc3R5bGVcbiAgICAgIGNhY2hlW2tdID0gZWxtLnN0eWxlW2tdIGlmIGNhY2hlW2tdIGlzIHVuZGVmaW5lZFxuICAgICAgY2FjaGVba11cbiAgICBlbHNlXG4gICAgICBrID0gYXR0ck5hbWVzW2tdID89IGsucmVwbGFjZSgvKFtBLVpdKS9nLFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkgIyBOb3JtYWxpemUgY2FtZWxDYXNlIGludG8ga2ViYWItY2FzZVxuICAgICAgY2FjaGUgPSBlbG0uX0RPT01fYXR0clxuICAgICAgY2FjaGVba10gPSBlbG0uZ2V0QXR0cmlidXRlIGsgaWYgY2FjaGVba10gaXMgdW5kZWZpbmVkXG4gICAgICBjYWNoZVtrXVxuXG5cbiAgd3JpdGUgPSAoZWxtLCBrLCB2KS0+XG4gICAgaWYgcHJvcE5hbWVzW2tdP1xuICAgICAgY2FjaGUgPSBlbG0uX0RPT01fcHJvcFxuICAgICAgaXNDYWNoZWQgPSBjYWNoZVtrXSBpcyB2XG4gICAgICBlbG1ba10gPSBjYWNoZVtrXSA9IHYgaWYgbm90IGlzQ2FjaGVkXG4gICAgZWxzZSBpZiBzdHlsZU5hbWVzW2tdPyBhbmQgIShlbG0uX0RPT01fU1ZHIGFuZCBzdHlsZU5hbWVzW2tdIGlzIFwiaHRtbFwiKVxuICAgICAgY2FjaGUgPSBlbG0uX0RPT01fc3R5bGVcbiAgICAgIGlzQ2FjaGVkID0gY2FjaGVba10gaXMgdlxuICAgICAgZWxtLnN0eWxlW2tdID0gY2FjaGVba10gPSB2IGlmIG5vdCBpc0NhY2hlZFxuICAgIGVsc2UgaWYgZXZlbnROYW1lc1trXT9cbiAgICAgIGNhY2hlID0gZWxtLl9ET09NX2V2ZW50XG4gICAgICByZXR1cm4gaWYgY2FjaGVba10gaXMgdlxuICAgICAgaWYgY2FjaGVba10/XG4gICAgICAgIHRocm93IFwiRE9PTSBleHBlcmltZW50YWxseSBpbXBvc2VzIGEgbGltaXQgb2Ygb25lIGhhbmRsZXIgcGVyIGV2ZW50IHBlciBvYmplY3QuXCJcbiAgICAgICAgIyBJZiB3ZSB3YW50IHRvIGFkZCBtdWx0aXBsZSBoYW5kbGVycyBmb3IgdGhlIHNhbWUgZXZlbnQgdG8gYW4gb2JqZWN0LFxuICAgICAgICAjIHdlIG5lZWQgdG8gZGVjaWRlIGhvdyB0aGF0IGludGVyYWN0cyB3aXRoIHBhc3NpbmcgbnVsbCB0byByZW1vdmUgZXZlbnRzLlxuICAgICAgICAjIFNob3VsZCBudWxsIHJlbW92ZSBhbGwgZXZlbnRzPyBQcm9iYWJseS4gSG93IGRvIHdlIHRyYWNrIHRoYXQ/IEtlZXAgYW4gYXJyYXkgb2YgcmVmcyB0byBoYW5kbGVycz9cbiAgICAgICAgIyBUaGF0IHNlZW1zIHNsb3cgYW5kIGVycm9yIHByb25lLlxuICAgICAgY2FjaGVba10gPSB2XG4gICAgICBpZiB2P1xuICAgICAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lciBrLCB2XG4gICAgICBlbHNlXG4gICAgICAgIGVsbS5yZW1vdmVFdmVudExpc3RlbmVyIGssIHZcbiAgICBlbHNlXG4gICAgICBrID0gYXR0ck5hbWVzW2tdID89IGsucmVwbGFjZSgvKFtBLVpdKS9nLFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkgIyBOb3JtYWxpemUgY2FtZWxDYXNlIGludG8ga2ViYWItY2FzZVxuICAgICAgY2FjaGUgPSBlbG0uX0RPT01fYXR0clxuICAgICAgcmV0dXJuIGlmIGNhY2hlW2tdIGlzIHZcbiAgICAgIGNhY2hlW2tdID0gdlxuICAgICAgbnMgPSBpZiBrIGlzIFwieGxpbms6aHJlZlwiIHRoZW4geGxpbmtOUyBlbHNlIG51bGwgIyBHcmFiIHRoZSBuYW1lc3BhY2UgaWYgbmVlZGVkXG4gICAgICBpZiBucz9cbiAgICAgICAgaWYgdj8gIyBjaGVjayBmb3IgbnVsbFxuICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGVOUyBucywgaywgdiAjIHNldCBET00gYXR0cmlidXRlXG4gICAgICAgIGVsc2UgIyB2IGlzIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgKG5vdCB1bmRlZmluZWQpXG4gICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TIG5zLCBrICMgcmVtb3ZlIERPTSBhdHRyaWJ1dGVcbiAgICAgIGVsc2VcbiAgICAgICAgaWYgdj8gIyBjaGVjayBmb3IgbnVsbFxuICAgICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUgaywgdiAjIHNldCBET00gYXR0cmlidXRlXG4gICAgICAgIGVsc2UgIyB2IGlzIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgKG5vdCB1bmRlZmluZWQpXG4gICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZSBrICMgcmVtb3ZlIERPTSBhdHRyaWJ1dGVcblxuXG4gIGFjdCA9IChlbG0sIG9wdHMpLT5cbiAgICAjIEluaXRpYWxpemUgdGhlIGNhY2hlc1xuICAgIGVsbS5fRE9PTV9hdHRyID89IHt9XG4gICAgZWxtLl9ET09NX2V2ZW50ID89IHt9XG4gICAgZWxtLl9ET09NX3Byb3AgPz0ge31cbiAgICBlbG0uX0RPT01fc3R5bGUgPz0ge31cblxuICAgIGlmIHR5cGVvZiBvcHRzIGlzIFwib2JqZWN0XCJcbiAgICAgIGZvciBrLCB2IG9mIG9wdHNcbiAgICAgICAgd3JpdGUgZWxtLCBrLCB2XG4gICAgICByZXR1cm4gZWxtXG4gICAgZWxzZSBpZiB0eXBlb2Ygb3B0cyBpcyBcInN0cmluZ1wiXG4gICAgICByZXR1cm4gcmVhZCBlbG0sIG9wdHNcblxuXG4gICMgUFVCTElDIEFQSSAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuICAjIFRoZSBmaXJzdCBhcmcgY2FuIGJlIGFuIGVsbSBvciBhcnJheSBvZiBlbG1zXG4gICMgVGhlIHNlY29uZCBhcmcgY2FuIGJlIGFuIG9iamVjdCBvZiBzdHVmZiB0byB1cGRhdGUgaW4gdGhlIGVsbShzKSwgaW4gd2hpY2ggY2FzZSB3ZSdsbCByZXR1cm4gdGhlIGVsbShzKS5cbiAgIyBPciBpdCBjYW4gYmUgYSBzdHJpbmcgcHJvcC9hdHRyL3N0eWxlIHRvIHJlYWQgZnJvbSB0aGUgZWxtKHMpLCBpbiB3aGljaCBjYXNlIHdlIHJldHVybiB0aGUgdmFsdWUocykuXG4gIERPT00gPSAoZWxtcywgb3B0cyktPlxuICAgIGVsbXMgPSBbZWxtc10gdW5sZXNzIHR5cGVvZiBlbG1zIGlzIFwiYXJyYXlcIlxuICAgICh0aHJvdyBuZXcgRXJyb3IgXCJET09NIHdhcyBjYWxsZWQgd2l0aCBhIG51bGwgZWxlbWVudFwiIHVubGVzcyBlbG0/KSBmb3IgZWxtIGluIGVsbXNcbiAgICB0aHJvdyBuZXcgRXJyb3IgXCJET09NIHdhcyBjYWxsZWQgd2l0aCBudWxsIG9wdGlvbnNcIiB1bmxlc3Mgb3B0cz9cbiAgICByZXN1bHRzID0gKGFjdCBlbG0sIG9wdHMgZm9yIGVsbSBpbiBlbG1zKVxuICAgIHJldHVybiBpZiByZXN1bHRzLmxlbmd0aCBpcyAxIHRoZW4gcmVzdWx0c1swXSBlbHNlIHJlc3VsdHNcblxuXG4gIERPT00uY3JlYXRlID0gKHR5cGUsIHBhcmVudCwgb3B0cyktPlxuICAgIGlmIHN2Z0VsbXNbdHlwZV0/XG4gICAgICBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgc3ZnTlMsIHR5cGVcbiAgICAgIGlmIHR5cGUgaXMgXCJzdmdcIlxuICAgICAgICAob3B0cyA/PSB7fSkueG1sbnMgPSBzdmdOU1xuICAgICAgZWxzZVxuICAgICAgICBlbG0uX0RPT01fU1ZHID0gdHJ1ZVxuICAgIGVsc2VcbiAgICAgIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgdHlwZVxuICAgIERPT00gZWxtLCBvcHRzIGlmIG9wdHM/XG4gICAgRE9PTS5hcHBlbmQgcGFyZW50LCBlbG0gaWYgcGFyZW50P1xuICAgIHJldHVybiBlbG1cblxuXG4gIERPT00uYXBwZW5kID0gKHBhcmVudCwgY2hpbGQpLT5cbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQgY2hpbGRcbiAgICByZXR1cm4gY2hpbGRcblxuXG4gIERPT00ucHJlcGVuZCA9IChwYXJlbnQsIGNoaWxkKS0+XG4gICAgaWYgcGFyZW50Lmhhc0NoaWxkTm9kZXMoKVxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSBjaGlsZCwgcGFyZW50LmZpcnN0Q2hpbGRcbiAgICBlbHNlXG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQgY2hpbGRcbiAgICByZXR1cm4gY2hpbGRcblxuXG4gIERPT00ucmVtb3ZlID0gKGVsbSwgY2hpbGQpLT5cbiAgICBpZiBjaGlsZD9cbiAgICAgIGVsbS5yZW1vdmVDaGlsZCBjaGlsZCBpZiBjaGlsZC5wYXJlbnROb2RlIGlzIGVsbVxuICAgICAgcmV0dXJuIGNoaWxkXG4gICAgZWxzZVxuICAgICAgZWxtLnJlbW92ZSgpXG4gICAgICByZXR1cm4gZWxtXG5cblxuICBET09NLmVtcHR5ID0gKGVsbSktPlxuICAgIGVsbS5pbm5lckhUTUwgPSBcIlwiXG5cblxuICAjIEF0dGFjaCB0byB0aGlzXG4gIEBET09NID0gRE9PTSBpZiBAP1xuXG4gICMgQXR0YWNoIHRvIHRoZSB3aW5kb3dcbiAgd2luZG93LkRPT00gPSBET09NIGlmIHdpbmRvdz9cblxuICAjIEludGVncmF0ZSB3aXRoIFRha2UgJiBNYWtlXG4gIE1ha2UgXCJET09NXCIsIERPT00gaWYgTWFrZT9cblxuXG4jIGxpYi9maWxlLXRyZWUuY29mZmVlXG5UYWtlIFtcIlJlYWRcIl0sIChSZWFkKS0+XG5cbiAgc29ydCA9IChhLCBiKS0+IGEubmFtZS5sb2NhbGVDb21wYXJlIGIubmFtZVxuXG4gIHBvcHVsYXRlVHJlZSA9ICh0cmVlKS0+XG4gICAgaWYgYXdhaXQgUmVhZC5leGlzdHMgdHJlZS5wYXRoXG4gICAgICBkaXJlbnRzID0gYXdhaXQgUmVhZC53aXRoRmlsZVR5cGVzIHRyZWUucGF0aFxuICAgICAgZGlyZW50cy5zb3J0IHNvcnRcbiAgICAgIHRyZWUuY2hpbGRyZW4gPSBhd2FpdCBQcm9taXNlLmFsbCBkaXJlbnRzLm1hcCAoZGlyZW50KS0+XG4gICAgICAgIGlmIGRpcmVudC5pc0RpcmVjdG9yeSgpXG4gICAgICAgICAgY2hpbGRUcmVlID0gRmlsZVRyZWUubmV3RW1wdHkgdHJlZS5wYXRoLCBkaXJlbnQubmFtZVxuICAgICAgICAgIGNoaWxkVHJlZS5yZWxwYXRoID0gUmVhZC5wYXRoIHRyZWUucmVscGF0aCwgZGlyZW50Lm5hbWVcbiAgICAgICAgICBhd2FpdCBwb3B1bGF0ZVRyZWUgY2hpbGRUcmVlXG4gICAgICAgICAgdHJlZS5jb3VudCArPSBjaGlsZFRyZWUuY291bnRcbiAgICAgICAgICBjaGlsZFRyZWVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRyZWUuY291bnQgKz0gMVxuICAgICAgICAgIHBhcnRzID0gZGlyZW50Lm5hbWUuc3BsaXQgXCIuXCJcbiAgICAgICAgICBjaGlsZEZpbGUgPVxuICAgICAgICAgICAgbmFtZTogZGlyZW50Lm5hbWVcbiAgICAgICAgICAgIGJhc2VuYW1lOiBBcnJheS5idXRMYXN0KHBhcnRzKS5qb2luIFwiLlwiXG4gICAgICAgICAgICBleHQ6IGlmIHBhcnRzLmxlbmd0aCA+IDEgdGhlbiBBcnJheS5sYXN0KHBhcnRzKS50b0xvd2VyQ2FzZSgpIGVsc2UgbnVsbFxuICAgICAgICAgICAgcGF0aDogUmVhZC5wYXRoIHRyZWUucGF0aCwgZGlyZW50Lm5hbWVcbiAgICAgICAgICAgIHJlbHBhdGg6IFJlYWQucGF0aCB0cmVlLnJlbHBhdGgsIGRpcmVudC5uYW1lXG4gICAgdHJlZVxuXG4gIE1ha2UgXCJGaWxlVHJlZVwiLCBGaWxlVHJlZSA9XG4gICAgbmV3RW1wdHk6IChwYXJlbnRQYXRoLCBuYW1lKS0+XG4gICAgICBuYW1lOiBuYW1lXG4gICAgICBiYXNlbmFtZTogbmFtZVxuICAgICAgZXh0OiBudWxsXG4gICAgICBwYXRoOiBSZWFkLnBhdGggcGFyZW50UGF0aCwgbmFtZSAjIGFic29sdXRlIHBhdGggb24gdGhlIGxvY2FsIEhEXG4gICAgICByZWxwYXRoOiBuYW1lICMgcGF0aCByZWxhdGl2ZSB0byB0aGUgcGFyZW50IG9mIHRoZSB0cmVlIHJvb3RcbiAgICAgIGNvdW50OiAwXG4gICAgICBjaGlsZHJlbjogW11cblxuICAgIG5ld1BvcHVsYXRlZDogKHBhcmVudFBhdGgsIG5hbWUpLT5cbiAgICAgIHJvb3QgPSBGaWxlVHJlZS5uZXdFbXB0eSBwYXJlbnRQYXRoLCBuYW1lXG4gICAgICBhd2FpdCBwb3B1bGF0ZVRyZWUgcm9vdFxuICAgICAgcm9vdFxuXG4gICAgZmxhdDogKHRyZWUsIGssIGludG8gPSBbXSktPlxuICAgICAgZm9yIGNoaWxkIGluIHRyZWUuY2hpbGRyZW5cbiAgICAgICAgaWYgbm90IGs/ICMgY29sbGVjdGluZyBjaGlsZHJlblxuICAgICAgICAgIGludG8ucHVzaCBjaGlsZFxuICAgICAgICBlbHNlIGlmIGNoaWxkW2tdPyAjIGNvbGxlY3RpbmcgY2hpbGRyZW4ncyBwcm9wZXJ0aWVzXG4gICAgICAgICAgaW50by5wdXNoIGNoaWxkW2tdXG4gICAgICAgIEZpbGVUcmVlLmZsYXQgY2hpbGQsIGssIGludG8gaWYgY2hpbGQuY2hpbGRyZW5cbiAgICAgIGludG9cblxuICAgIGZpbmQ6ICh0cmVlLCBrLCB2KS0+XG4gICAgICByZXR1cm4gdHJlZSBpZiB0cmVlW2tdIGlzIHZcbiAgICAgIGlmIHRyZWUuY2hpbGRyZW5cbiAgICAgICAgZm9yIGNoaWxkIGluIHRyZWUuY2hpbGRyZW5cbiAgICAgICAgICByZXR1cm4gcmVzIGlmIHJlcyA9IEZpbGVUcmVlLmZpbmQgY2hpbGQsIGssIHZcbiAgICAgIG51bGxcblxuXG4jIGxpYi9mcnVzdHJhdGlvbi5jb2ZmZWVcblRha2UgW10sICgpLT5cbiAgYXJyID0gW1xuICAgIFwi4oCiX+KAomAgXCIsXG4gICAgXCJg4oCiX+KAomBcIixcbiAgICBcIiBg4oCiX+KAolwiLFxuICAgIFwiICBvLm9cIixcbiAgICBcIiBvLm8gXCIsXG4gICAgXCJvLm8gIFwiLFxuICAgIFwi4oCi4oia4oCiICBcIixcbiAgICBcIiDigKLiiJrigKIgXCIsXG4gICAgXCIgIOKAouKImuKAolwiLFxuICAgIFwiICDCsGXCsFwiLFxuICAgIFwiIMKwb8KwIFwiLFxuICAgIFwiwrAzwrAgIFwiLFxuICAgIFwidl92ICBcIixcbiAgICBcIiB2X3YgXCIsXG4gICAgXCIgIHZfdlwiLFxuICAgIFwiIGDigKLPieKAolwiLFxuICAgIFwiYOKAos+J4oCiYFwiLFxuICAgIFwi4oCiz4nigKJgIFwiLFxuICAgIFwi4oCYXuKAmCAgXCIsXG4gICAgXCIgJ14nIFwiLFxuICAgIFwiICBgXmBcIixcbiAgICBcIiAgVOKInlRcIixcbiAgICBcIiBU4oieVCBcIixcbiAgICBcIlTiiJ5UICBcIixcbiAgICBcIsKhXsKhICBcIixcbiAgICBcIiDCoV7CoSBcIixcbiAgICBcIiAgwqFewqFcIixcbiAgICBcIiAgO187XCIsXG4gICAgXCIgO187IFwiLFxuICAgIFwiO187ICBcIlxuICBdXG5cbiAgTWFrZSBcIkZydXN0cmF0aW9uXCIsIChpKS0+XG4gICAgaWYgaT9cbiAgICAgIGkgJT0gYXJyLmxlbmd0aFxuICAgIGVsc2VcbiAgICAgIGkgPSBNYXRoLnJhbmQgMCwgYXJyLmxlbmd0aFxuICAgIGFycltpfDBdXG5cblxuIyBsaWIvaXRlcmF0ZWQuY29mZmVlXG5UYWtlIFtdLCAoKS0+XG5cbiAgTWFrZSBcIkl0ZXJhdGVkXCIsIEl0ZXJhdGVkID0gKC4uLlt0aW1lTGltaXQgPSA1XSwgaXRlcmF0ZWRGdW5jdGlvbiktPlxuXG4gICAgbmV4dEZyYW1lUmVxdWVzdGVkID0gZmFsc2VcbiAgICBydW5BZ2Fpbk5leHRGcmFtZSA9IGZhbHNlXG4gICAgZGlkUnVuVGhpc0ZyYW1lID0gZmFsc2VcbiAgICByYW5PdXRPZlRpbWUgPSBmYWxzZVxuICAgIHN0YXJ0VGltZSA9IG51bGxcblxuICAgIHJ1biA9ICgpLT5cbiAgICAgICMgT25seSBydW4gb25jZSBwZXIgZnJhbWUuIElmIHdlJ3ZlIGFscmVhZHkgcnVuLCBtYXJrIHRoYXQgd2Ugd2FudCB0byBydW4gYWdhaW4gbmV4dCBmcmFtZS5cbiAgICAgIHJldHVybiBydW5BZ2Fpbk5leHRGcmFtZSA9IHRydWUgaWYgZGlkUnVuVGhpc0ZyYW1lXG4gICAgICBkaWRSdW5UaGlzRnJhbWUgPSB0cnVlXG5cbiAgICAgICMgV2hlbmV2ZXIgd2UgcnVuLCB3ZSBuZWVkIHRvIGRvIHNvbWUgYWRkaXRpb25hbCB3b3JrIG5leHQgZnJhbWUuXG4gICAgICByZXF1ZXN0TmV4dEZyYW1lKClcblxuICAgICAgIyBEZWZlciB0aGUgZXhlY3V0aW9uIG9mIHRoZSBmdW5jdGlvbiAqc2xpZ2h0bHkqLCB0byBpbXByb3ZlIGJhdGNoaW5nIGJlaGF2aW91clxuICAgICAgIyB3aGVuIGFuIGl0ZXJhdGVkIGZ1bmN0aW9uIGlzIGNhbGxlZCByZXBlYXRlZGx5IGluc2lkZSBhIGxvb3AgKGVnOiBieSBsaWIvam9iLmNvZmZlZSkuXG4gICAgICBxdWV1ZU1pY3JvdGFzayAoKS0+XG5cbiAgICAgICAgIyBOb3cgd2UgY2FuIGFjdHVhbGx5IHJ1biB0aGUgaXRlcmF0ZWQgZnVuY3Rpb24hXG4gICAgICAgIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgIGl0ZXJhdGVkRnVuY3Rpb24gbW9yZVxuXG4gICAgICAjIEl0ZXJhdGVkIGZ1bmN0aW9ucyBhcmUganVzdCBmb3Igc2lkZSBlZmZlY3RzIOKAlCBhIHJldHVybiB2YWx1ZSBpcyBub3QgbmVlZGVkLlxuICAgICAgbnVsbFxuXG5cbiAgICByZXF1ZXN0TmV4dEZyYW1lID0gKCktPlxuICAgICAgcmV0dXJuIGlmIG5leHRGcmFtZVJlcXVlc3RlZFxuICAgICAgbmV4dEZyYW1lUmVxdWVzdGVkID0gdHJ1ZVxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIG5leHRGcmFtZVxuXG4gICAgIyBXaGVuZXZlciBzb21lb25lIGNhbGxzIHJ1bigpLCB3ZSAqYWx3YXlzKiBuZWVkIHRvIGRvIHNvbWUgY2xlYW51cCB3b3JrLCBhbmQgbWUgbWlnaHRcbiAgICAjIGFsc28gbmVlZCB0byBjYWxsIHJ1bigpIGFnYWluIG91cnNlbHZlcyBpZiB0aGVyZSdzIG1vcmUgaXRlcmF0ZWQgd29yayB0byBiZSBkb25lLlxuICAgIG5leHRGcmFtZSA9ICgpLT5cbiAgICAgIGRvUnVuID0gcnVuQWdhaW5OZXh0RnJhbWVcbiAgICAgIG5leHRGcmFtZVJlcXVlc3RlZCA9IGZhbHNlXG4gICAgICBydW5BZ2Fpbk5leHRGcmFtZSA9IGZhbHNlXG4gICAgICBkaWRSdW5UaGlzRnJhbWUgPSBmYWxzZVxuICAgICAgcmFuT3V0T2ZUaW1lID0gZmFsc2VcbiAgICAgIHJ1bigpIGlmIGRvUnVuXG5cbiAgICAjIFRoaXMgZnVuY3Rpb24gd2lsbCB0ZWxsIHRoZSBjYWxsZXIgd2hldGhlciB0aGV5J3JlIHNhZmUgdG8gZG8gbW9yZSB3b3JrIHRoaXMgZnJhbWUuXG4gICAgIyBUaGV5J2xsIGNhbGwgaXQgcmVwZWF0ZWRseSBpbiBhIGxvb3AgKHdoaWxlIGRvaW5nIG90aGVyIHdvcmspIHVudGlsIGVpdGhlciB0aGV5XG4gICAgIyBydW4gb3V0IG9mIHRpbWUgYW5kIGJyZWFrIG91dCBvZiB0aGUgbG9vcCwgb3IgcnVuIG91dCBvZiB3b3JrIHRvIGRvIGFuZCBqdXN0IHN0b3BcbiAgICAjIGNhbGxpbmcgdXMuXG4gICAgbW9yZSA9IChjdXN0b21MaW1pdCktPlxuICAgICAgcmFuT3V0T2ZUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUgPiAoY3VzdG9tTGltaXQgb3IgdGltZUxpbWl0KVxuXG4gICAgICBpZiByYW5PdXRPZlRpbWVcbiAgICAgICAgIyBNYXJrIHRoYXQgd2Ugd2FudCB0byBhY3R1YWxseSBkbyBhIHJ1bigpIG5leHQgZnJhbWUsIG5vdCBqdXN0IHRoZSB1c3VhbCBjbGVhbnVwLlxuICAgICAgICBydW5BZ2Fpbk5leHRGcmFtZSA9IHRydWVcblxuICAgICAgICAjIFdlIGFsd2F5cyBuZWVkIHRvIHJlcXVlc3QgYSBuZXcgZnJhbWUsIHNpbmNlIHRoZSBjYWxsIHRvIG1vcmUoKSBtaWdodCBjb21lXG4gICAgICAgICMgbG9uZyBhZnRlciB0aGUgbGFzdCBjYWxsIHRvIHJ1bigpIGlmIHRoZSBpdGVyYXRlZCBmdW5jdGlvbiBpcyBkb2luZyBzb21ldGhpbmcgYXN5bmMuXG4gICAgICAgIHJlcXVlc3ROZXh0RnJhbWUoKVxuXG4gICAgICByZXR1cm4gbm90IHJhbk91dE9mVGltZVxuXG4gICAgcmV0dXJuIHJ1blxuXG5cbiMgbGliL2pvYi5jb2ZmZWVcblRha2UgW10sICgpLT5cblxuICBoYW5kbGVycyA9IHt9XG4gIHdhdGNoZXJzID0gW11cbiAgcnVubmluZyA9IGZhbHNlXG4gIGxhc3RUaW1lID0gbnVsbFxuICBsYXN0TiA9IFtdXG5cbiAgTWFrZS5hc3luYyBcIkpvYlwiLCBKb2IgPSAocHJpb3JpdHksIHR5cGUsIC4uLmFyZ3MpLT5cbiAgICAjIFByaW9yaXR5IGlzIG9wdGlvbmFsLCBhbmQgZGVmYXVsdHMgdG8gMFxuICAgIGlmIFN0cmluZy50eXBlIHByaW9yaXR5XG4gICAgICByZXR1cm4gSm9iIDAsIHByaW9yaXR5LCB0eXBlLCAuLi5hcmdzXG5cbiAgICB0aHJvdyBFcnJvciBcIk5vIGhhbmRsZXIgZm9yIGpvYiB0eXBlOiAje3R5cGV9XCIgdW5sZXNzIGhhbmRsZXJzW3R5cGVdP1xuXG4gICAgbmV3IFByb21pc2UgKHJlc29sdmUpLT5cbiAgICAgIEpvYi5xdWV1ZXNbcHJpb3JpdHldID89IFtdXG4gICAgICBKb2IucXVldWVzW3ByaW9yaXR5XS5wdXNoIHt0eXBlLCBhcmdzLCByZXNvbHZlfVxuICAgICAgSm9iLmNvdW50KytcbiAgICAgIEpvYi5ydW5Kb2JzKClcblxuICBKb2IucXVldWVzID0gW11cbiAgSm9iLmNvdW50ID0gMFxuICBKb2IuZGVsYXkgPSAwXG5cbiAgSm9iLmhhbmRsZXIgPSAodHlwZSwgaGFuZGxlciktPlxuICAgIGlmIGhhbmRsZXJzW3R5cGVdIHRoZW4gdGhyb3cgRXJyb3IgXCJBIGpvYiBoYW5kbGVyIGZvciAje3R5cGV9IGFscmVhZHkgZXhpc3RzXCJcbiAgICBoYW5kbGVyc1t0eXBlXSA9IGhhbmRsZXJcblxuICBKb2Iud2F0Y2hlciA9ICh3YXRjaGVyKS0+XG4gICAgd2F0Y2hlcnMucHVzaCB3YXRjaGVyXG5cbiAgSm9iLnJ1bkpvYnMgPSAoKS0+XG4gICAgcmV0dXJuIGlmIHJ1bm5pbmdcbiAgICBydW5uaW5nID0gdHJ1ZVxuICAgIGxhc3RUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBKb2IuZGVsYXkgPSAxNlxuICAgIHVwZGF0ZVdhdGNoZXJzKClcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcnVuXG5cbiAgcnVuID0gKCktPlxuICAgIGRpcnR5ID0gZmFsc2VcbiAgICBmb3IgcXVldWUsIHByaW9yaXR5IGluIEpvYi5xdWV1ZXMgYnkgLTFcbiAgICAgIHdoaWxlIHF1ZXVlPy5sZW5ndGggPiAwXG4gICAgICAgIGRpcnR5ID0gdHJ1ZVxuICAgICAgICB7dGltZSwgdHlwZSwgYXJncywgcmVzb2x2ZX0gPSBxdWV1ZS5zaGlmdCgpXG4gICAgICAgIEpvYi5jb3VudC0tXG4gICAgICAgIHJlc29sdmUgaGFuZGxlcnNbdHlwZV0gLi4uYXJncyAjIFdlIGNhbid0IGF3YWl0LCBvciBlbHNlIGlmIGEgSm9iIGNyZWF0ZXMgYSBuZXcgSm9iIGluc2lkZSBpdHNlbGYsIHdlJ2xsIGdldCBzdHVja1xuICAgICAgICBKb2IuZGVsYXkgPSAocGVyZm9ybWFuY2Uubm93KCkgLSBsYXN0VGltZSkgKiAwLjEgKyBKb2IuZGVsYXkgKiAwLjlcbiAgICAgICAgcmV0dXJuIGJhaWwoKSBpZiBKb2IuZGVsYXkgPiAzMCAjIERvbid0IGxldCB0aGUgZnJhbWUgcmF0ZSBjcmF0ZXJcbiAgICBydW5uaW5nID0gZmFsc2VcbiAgICAjIElmIGFueSBqb2JzIHJhbiB0aGlzIGZyYW1lLCB3ZSBzaG91bGQgcnVuIGF0IGxlYXN0IG9uZSBtb3JlIHRpbWUsIGluIGNhc2UgYW55IGpvYnMgdGhhdCB3ZSByYW4gY3JlYXRlZCBuZXcgam9icyBhdCBhIGhpZ2hlciBwcmlvcml0eS5cbiAgICBKb2IucnVuSm9icygpIGlmIGRpcnR5XG4gICAgdXBkYXRlV2F0Y2hlcnMoKVxuXG4gIGJhaWwgPSAoKS0+XG4gICAgbGFzdFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSBydW5cbiAgICB1cGRhdGVXYXRjaGVycygpXG5cbiAgdXBkYXRlV2F0Y2hlcnMgPSAoKS0+XG4gICAgZm9yIHdhdGNoZXIgaW4gd2F0Y2hlcnNcbiAgICAgIHdhdGNoZXIgSm9iLmNvdW50LCBKb2IuZGVsYXlcbiAgICBudWxsXG5cblxuIyBsaWIvbG9nLWluaXRpYWxpemF0aW9uLXRpbWUuY29mZmVlXG5kbyAoKS0+XG4gIHsgcGVyZm9ybWFuY2UgfSA9IHJlcXVpcmUgXCJwZXJmX2hvb2tzXCIgdW5sZXNzIHBlcmZvcm1hbmNlP1xuXG4gIHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuXG4gIExvZyA9IGF3YWl0IFRha2UuYXN5bmMgXCJMb2dcIlxuXG4gIExvZyBcIkluaXRpYWxpemF0aW9uIFRpbWVcIiwgbnVsbCwgdGltZVxuXG5cbiMgbGliL2xvZy5jb2ZmZWVcblRha2UgW10sICgpLT5cbiAgeyBwZXJmb3JtYW5jZSB9ID0gcmVxdWlyZSBcInBlcmZfaG9va3NcIiB1bmxlc3MgcGVyZm9ybWFuY2U/XG5cbiAgIyBXZSBjYW4ndCAvIHNob3VsZG4ndCBUYWtlIGFueXRoaW5nLCBzaW5jZSBMb2cgbWlnaHQgbmVlZCB0byBiZSB1c2VkICphbnl3aGVyZSpcbiAgREIgPSBFbnYgPSBJUEMgPSBQcmludGVyID0gbnVsbFxuXG4gIE1ha2UuYXN5bmMgXCJMb2dcIiwgTG9nID0gKG1zZywgYXR0cnMsIHRpbWUpLT5cbiAgICBFbnYgPz0gVGFrZSBcIkVudlwiXG5cbiAgICAjIFNlbmQgbG9ncyB0byB0aGUgbG9jYWwgcHJpbnRlclxuICAgIGlmIFByaW50ZXIgPz0gVGFrZSBcIlByaW50ZXJcIlxuICAgICAgUHJpbnRlciBtc2csIGF0dHJzLCB0aW1lXG5cbiAgICAjIElmIHdlIGhhdmUgYSBwb3J0IHRvIHRoZSBEQiwgc2VuZCBsb2dzIHRvIHRoZSBEQiBQcmludGVyXG4gICAgaWYgREIgPz0gVGFrZSBcIkRCXCJcbiAgICAgIERCLnNlbmQgXCJwcmludGVyXCIsIG1zZywgYXR0cnMsIHRpbWVcblxuICAgICMgSWYgd2UncmUgaW4gZGV2LCBhbmQgaW4gYSByZW5kZXIgcHJvY2Vzcywgc2VuZCBsb2dzIHRvIHRoZSBtYWluIHByb2Nlc3MgUHJpbnRlclxuICAgIGlmIEVudj8uaXNEZXYgYW5kIEVudj8uaXNSZW5kZXIgYW5kIElQQyA/PSBUYWtlIFwiSVBDXCJcbiAgICAgIElQQy5zZW5kIFwicHJpbnRlclwiLCBtc2csIGF0dHJzLCB0aW1lXG5cbiAgICByZXR1cm4gbXNnXG5cbiAgTG9nLnRpbWUgPSAobXNnLCBmbiktPlxuICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICB2ID0gZm4oKVxuICAgIExvZy50aW1lLmZvcm1hdHRlZCBtc2csIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRcbiAgICByZXR1cm4gdlxuXG4gIExvZy50aW1lLmFzeW5jID0gKG1zZywgZm4pLT5cbiAgICBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgdiA9IGF3YWl0IGZuKClcbiAgICBMb2cudGltZS5mb3JtYXR0ZWQgbXNnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0XG4gICAgcmV0dXJuIHZcblxuICBMb2cudGltZS5jdXN0b20gPSAocHJlTXNnKS0+XG4gICAgTG9nIHByZU1zZyBpZiBwcmVNc2dcbiAgICBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgKHBvc3RNc2cpLT4gTG9nLnRpbWUuZm9ybWF0dGVkIHBvc3RNc2csIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRcblxuICBMb2cudGltZS5mb3JtYXR0ZWQgPSAobXNnLCB0aW1lKS0+XG4gICAgTG9nIHRpbWUudG9GaXhlZCgxKS5wYWRTdGFydCg2KSArIFwiIFwiICsgbXNnXG5cbiAgTG9nLmVyciA9IChtc2cpLT5cbiAgICBMb2cgbXNnLCBjb2xvcjogXCIjRjAwXCJcblxuXG4jIGxpYi9wYXRocy5jb2ZmZWVcblRha2UgW1wiUmVhZFwiXSwgKFJlYWQpLT5cblxuICBNYWtlIFwiUGF0aHNcIiwgUGF0aHMgPVxuICAgIGZpbGVzOiAoYXNzZXQpLT4gICAgICAgICAgICAgICBSZWFkLnBhdGggYXNzZXQucGF0aCwgXCJGaWxlc1wiXG4gICAgbmFtZXM6IChhc3NldCktPiAgICAgICAgICAgICAgIFJlYWQucGF0aCBhc3NldC5wYXRoLCBcIk5hbWVcIlxuICAgIHNob3RzOiAoYXNzZXQpLT4gICAgICAgICAgICAgICBSZWFkLnBhdGggYXNzZXQucGF0aCwgXCJTaG90XCJcbiAgICBuZXdTaG90czogKGFzc2V0KS0+ICAgICAgICAgICAgUmVhZC5wYXRoIGFzc2V0LnBhdGgsIFwiU2hvdCAoTmV3KVwiXG4gICAgdGFnczogKGFzc2V0KS0+ICAgICAgICAgICAgICAgIFJlYWQucGF0aCBhc3NldC5wYXRoLCBcIlRhZ3NcIlxuICAgIHRodW1ibmFpbHM6IChhc3NldCktPiAgICAgICAgICBSZWFkLnBhdGggYXNzZXQucGF0aCwgXCJUaHVtYm5haWwgQ2FjaGVcIlxuXG4gICAgZmlsZTogKGFzc2V0LCBmaWxlbmFtZSktPiAgICAgIFJlYWQucGF0aCBQYXRocy5maWxlcyhhc3NldCksIGZpbGVuYW1lXG4gICAgbmFtZTogKGFzc2V0KS0+ICAgICAgICAgICAgICAgIFJlYWQucGF0aCBQYXRocy5uYW1lcyhhc3NldCksIGFzc2V0Lm5hbWVcbiAgICBzaG90OiAoYXNzZXQpLT4gICAgICAgICAgICAgICAgUmVhZC5wYXRoIFBhdGhzLnNob3RzKGFzc2V0KSwgYXNzZXQuc2hvdFxuICAgIG5ld1Nob3Q6IChhc3NldCktPiAgICAgICAgICAgICBSZWFkLnBhdGggUGF0aHMubmV3U2hvdHMoYXNzZXQpLCBhc3NldC5uZXdTaG90XG4gICAgdGh1bWJuYWlsOiAoYXNzZXQsIGZpbGVuYW1lKS0+IFJlYWQucGF0aCBQYXRocy50aHVtYm5haWxzKGFzc2V0KSwgZmlsZW5hbWVcbiAgICB0YWc6IChhc3NldCwgdGFnKS0+ICAgICAgICAgICAgUmVhZC5wYXRoIFBhdGhzLnRhZ3MoYXNzZXQpLCB0YWdcblxuICAgIHRodW1ibmFpbE5hbWU6IChmaWxlLCBzaXplKS0+ICBcIiN7U3RyaW5nLmhhc2ggZmlsZS5yZWxwYXRofS0je3NpemV9LmpwZ1wiXG5cbiAgICBleHQ6XG4gICAgICBpY29uOiB7XCJhc1wiLCBcImNwdHhcIiwgXCJjc3NcIiwgXCJkd2dcIiwgXCJleGVcIiwgXCJmbGFcIiwgXCJpZGxrXCIsIFwiaW5kYlwiLCBcImluZGRcIiwgXCJzd2ZcIiwgbnVsbDp0cnVlLCB1bmRlZmluZWQ6dHJ1ZX0gIyBJbmNsdWRlIG51bGwgLyB1bmRlZmluZWQgYmVjYXVzZSB3ZSB3YW50IHRob3NlIHRvIGdldCBhbiBpY29uLCBub3QgYSB0aHVtYm5haWxcbiAgICAgIHNpcHM6IHtcIjNmclwiLFwiYXJ3XCIsXCJhc3RjXCIsXCJhdmNpXCIsXCJibXBcIixcImNyMlwiLFwiY3IzXCIsXCJjcndcIixcImRjclwiLFwiZGRzXCIsXCJkbmdcIixcImR4b1wiLFwiZXJmXCIsXCJleHJcIixcImZmZlwiLFwiZ2lmXCIsXCJoZWljXCIsXCJoZWljc1wiLFwiaGVpZlwiLFwiaWNuc1wiLFwiaWNvXCIsXCJpaXFcIixcImpwMlwiLFwianBlZ1wiLFwianBnXCIsXCJrdHhcIixcIm1vc1wiLFwibXBvXCIsXCJtcndcIixcIm5lZlwiLFwibnJ3XCIsXCJvcmZcIixcIm9yZlwiLFwib3JmXCIsXCJwYm1cIixcInBkZlwiLFwicGVmXCIsXCJwaWNcIixcInBpY3RcIixcInBuZ1wiLFwicHNkXCIsXCJwdnJcIixcInJhZlwiLFwicmF3XCIsXCJydzJcIixcInJ3bFwiLFwic2dpXCIsXCJzcjJcIixcInNyZlwiLFwic3J3XCIsXCJ0Z2FcIixcInRpZmZcIixcIndlYnBcIn1cbiAgICAgIHZpZGVvOiB7XCJhdmNoZFwiLCBcImF2aVwiLCBcIm00cFwiLCBcIm00dlwiLCBcIm1vdlwiLCBcIm1wMlwiLCBcIm1wNFwiLCBcIm1wZVwiLCBcIm1wZWdcIiwgXCJtcGdcIiwgXCJtcHZcIiwgXCJvZ2dcIiwgXCJxdFwiLCBcIndlYm1cIiwgXCJ3bXZcIn1cblxuXG4jIGxpYi9wcmludGVyLmNvZmZlZVxuVGFrZSBbXSwgKCktPlxuICByZXR1cm4gaWYgd2luZG93Py5pc0RCICMgREIgaGFzIGl0cyBvd24gUHJpbnRlclxuXG4gIHsgcGVyZm9ybWFuY2UgfSA9IHJlcXVpcmUgXCJwZXJmX2hvb2tzXCIgdW5sZXNzIHBlcmZvcm1hbmNlP1xuXG4gIE1ha2UgXCJQcmludGVyXCIsIFByaW50ZXIgPSAobXNnLCBhdHRycywgdGltZSktPlxuICAgIHRpbWUgPSAodGltZSBvciBwZXJmb3JtYW5jZS5ub3coKSkudG9GaXhlZCgwKS5wYWRTdGFydCg1KVxuICAgIGNvbnNvbGUubG9nIHRpbWUgKyBcIiAgXCIgKyBtc2dcblxuXG4jIGxpYi9wdWItc3ViLmNvZmZlZVxuVGFrZSBbXSwgKCktPlxuXG4gIHN1YnMgPSB7fVxuXG4gIFN1YiA9IChuYW1lLCBjYiktPlxuICAgIChzdWJzW25hbWVdID89IFtdKS5wdXNoIGNiXG5cbiAgUHViID0gKG5hbWUsIGFyZ3MuLi4pLT5cbiAgICBpZiBzdWJzW25hbWVdP1xuICAgICAgZm9yIGhhbmRsZXIgaW4gc3Vic1tuYW1lXVxuICAgICAgICBoYW5kbGVyIGFyZ3MuLi5cbiAgICBudWxsXG5cbiAgTWFrZSBcIlB1YlN1YlwiLCB7UHViLCBTdWJ9XG5cblxuIyBsaWIvcmVhZC5jb2ZmZWVcbiMgVE9ETzogQ2xlYXIgdXAgdGhlIG5hbWluZyBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgZXhwbGljaXRseSBSZWFkLnN5bmMuZm9vIG9yIFJlYWQuYXN5bmMuZm9vXG5cblRha2UgW10sICgpLT5cbiAgZnMgPSByZXF1aXJlIFwiZnNcIlxuICBwYXRoID0gcmVxdWlyZSBcInBhdGhcIlxuXG4gIHZhbGlkRmlsZU5hbWUgPSAodiktPlxuICAgIHJldHVybiBmYWxzZSBpZiAwIGlzIHYuaW5kZXhPZiBcIi5cIiAjIEV4Y2x1ZGUgZG90ZmlsZXNcbiAgICByZXR1cm4gZmFsc2UgaWYgLTEgaXNudCB2LnNlYXJjaCAvWzw+OjssP1wiKnwvXFxcXF0vICMgRXhjbHVkZSBuYW1lcyB3ZSB3b24ndCBiZSBhYmxlIHRvIHJvdW5kdHJpcFxuICAgIHJldHVybiB0cnVlICMgRXZlcnl0aGluZyBlbHNlIGlzIGdvb2RcblxuICB2YWxpZERpcmVudE5hbWUgPSAodiktPlxuICAgIHZhbGlkRmlsZU5hbWUgdi5uYW1lXG5cbiAgZmlsdGVyVmFsaWREaXJlbnROYW1lID0gKHZzKS0+XG4gICAgdnMuZmlsdGVyIHZhbGlkRGlyZW50TmFtZVxuXG4gIFJlYWQgPSAoZm9sZGVyUGF0aCktPlxuICAgIHRyeVxuICAgICAgZmlsZU5hbWVzID0gZnMucmVhZGRpclN5bmMgZm9sZGVyUGF0aFxuICAgICAgZmlsZU5hbWVzLmZpbHRlciB2YWxpZEZpbGVOYW1lXG4gICAgY2F0Y2hcbiAgICAgIG51bGxcblxuICAjIFRlbXBvcmFyeSBoYWNrIHVudGlsIHdlIGZ1bGx5IHN3aXRjaCBSZWFkIG92ZXIgdG8gc3BsaXQgc3luYyBhbmQgYXN5bmMuXG4gICMgTm90ZSB0aGF0IHdlIGNhbid0IGp1c3Qgc2F5IFJlYWQuc3luYyA9IFJlYWQsIG9yIHRoYXQgYnJlYWtzIFJlYWQuc3luYy5leGlzdHMhXG4gIFJlYWQuc3luYyA9IChwKS0+IFJlYWQgcFxuXG4gIFJlYWQuc3luYy5leGlzdHMgPSAocGF0aCktPlxuICAgIGZzLmV4aXN0c1N5bmMgcGF0aFxuXG4gIFJlYWQuYXN5bmMgPSAoZm9sZGVyUGF0aCktPlxuICAgIG5ldyBQcm9taXNlIChyZXNvbHZlKS0+XG4gICAgICBmcy5yZWFkZGlyIGZvbGRlclBhdGgsIChlcnIsIGZpbGVOYW1lcyktPlxuICAgICAgICBpZiBlcnI/XG4gICAgICAgICAgcmVzb2x2ZSBudWxsXG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXNvbHZlIGZpbGVOYW1lcy5maWx0ZXIgdmFsaWRGaWxlTmFtZVxuXG4gIFJlYWQud2l0aEZpbGVUeXBlcyA9IChmb2xkZXJQYXRoKS0+XG4gICAgZnMucHJvbWlzZXMucmVhZGRpciBmb2xkZXJQYXRoLCB7d2l0aEZpbGVUeXBlczp0cnVlfVxuICAgIC50aGVuIGZpbHRlclZhbGlkRGlyZW50TmFtZVxuXG4gIFJlYWQuaXNGb2xkZXIgPSAoZm9sZGVyUGF0aCktPlxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgZm9sZGVyUGF0aD8ubGVuZ3RoXG4gICAgbmV3IFByb21pc2UgKHJlc29sdmUpLT5cbiAgICAgIGZzLnN0YXQgZm9sZGVyUGF0aCwgKGVyciwgc3RhdCktPlxuICAgICAgICByZXNvbHZlIHN0YXQ/LmlzRGlyZWN0b3J5KClcblxuICBSZWFkLnN0YXQgPSAocGF0aCktPlxuICAgIG5ldyBQcm9taXNlIChyZXNvbHZlKS0+XG4gICAgICBmcy5zdGF0IHBhdGgsIChlcnIsIHN0YXQpLT5cbiAgICAgICAgcmVzb2x2ZSBzdGF0XG5cbiAgUmVhZC5leGlzdHMgPSAoZmlsZVBhdGgpLT5cbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIGZpbGVQYXRoPy5sZW5ndGhcbiAgICBuZXcgUHJvbWlzZSAocmVzb2x2ZSktPlxuICAgICAgZnMuYWNjZXNzIGZpbGVQYXRoLCAoZXJyKS0+XG4gICAgICAgIHJlc29sdmUgbm90IGVycj9cblxuICBSZWFkLmZpbGUgPSAoZmlsZVBhdGgpLT5cbiAgICB0cnlcbiAgICAgIGZpbGUgPSBmcy5yZWFkRmlsZVN5bmMgZmlsZVBhdGhcbiAgICBjYXRjaFxuICAgICAgbnVsbFxuXG4gIFJlYWQuc2VwID0gcGF0aC5zZXBcbiAgUmVhZC53YXRjaCA9IGZzLndhdGNoXG5cbiAgUmVhZC5wYXRoID0gKC4uLnNlZ3MpLT4gc2Vncy5qb2luIHBhdGguc2VwXG4gIFJlYWQuc3BsaXQgPSAocCktPiBBcnJheS5wdWxsIHAuc3BsaXQocGF0aC5zZXApLCBcIlwiXG4gIFJlYWQubGFzdCA9IChwKS0+IEFycmF5Lmxhc3QgUmVhZC5zcGxpdCBwXG4gIFJlYWQucGFyZW50UGF0aCA9IChwKS0+IFJlYWQucGF0aCAuLi5BcnJheS5idXRMYXN0IFJlYWQuc3BsaXQgcFxuXG4gIE1ha2UgXCJSZWFkXCIsIFJlYWRcblxuXG4jIGxpYi9zaXplLW9uLWRpc2suY29mZmVlXG5UYWtlIFtcIlJlYWRcIl0sIChSZWFkKS0+XG5cbiAgTWFrZS5hc3luYyBcIlNpemVPbkRpc2tcIiwgU2l6ZU9uRGlzayA9IChwYXRoKS0+XG4gICAgbmV3IFByb21pc2UgKHJlc29sdmUpLT5cbiAgICAgIHN0YXRzID0gYXdhaXQgUmVhZC5zdGF0IHBhdGhcbiAgICAgIGlmIG5vdCBzdGF0cz9cbiAgICAgICAgcmVzb2x2ZSAwXG4gICAgICBlbHNlIGlmIG5vdCBzdGF0cy5pc0RpcmVjdG9yeSgpXG4gICAgICAgIHJlc29sdmUgc3RhdHMuc2l6ZVxuICAgICAgZWxzZVxuICAgICAgICB0b3RhbCA9IDBcbiAgICAgICAgY2hpbGRyZW4gPSBhd2FpdCBSZWFkLmFzeW5jIHBhdGhcbiAgICAgICAgc2l6ZXMgPSBmb3IgY2hpbGROYW1lIGluIGNoaWxkcmVuXG4gICAgICAgICAgU2l6ZU9uRGlzayBSZWFkLnBhdGggcGF0aCwgY2hpbGROYW1lXG4gICAgICAgIGZvciBzaXplIGluIHNpemVzXG4gICAgICAgICAgdG90YWwgKz0gYXdhaXQgc2l6ZVxuICAgICAgICByZXNvbHZlIHRvdGFsXG5cbiAgU2l6ZU9uRGlzay5wcmV0dHkgPSAocGF0aCktPlxuICAgIHNpemUgPSBhd2FpdCBTaXplT25EaXNrIHBhdGhcbiAgICBsZW4gPSBzaXplLnRvU3RyaW5nKCkubGVuZ3RoXG4gICAgY29uc29sZS5sb2cgc2l6ZS8xMDAwXG4gICAgY29uc29sZS5sb2cgbGVuXG5cbiAgICBzd2l0Y2hcbiAgICAgIHdoZW4gbGVuIDwgM1xuICAgICAgICBzdWZmaXggPSBcIkJcIlxuICAgICAgICBleHAgPSAwXG4gICAgICB3aGVuIGxlbiA8IDdcbiAgICAgICAgc3VmZml4ID0gXCJLQlwiXG4gICAgICAgIGV4cCA9IDFcbiAgICAgIHdoZW4gbGVuIDwgMTFcbiAgICAgICAgc3VmZml4ID0gXCJNQlwiXG4gICAgICAgIGV4cCA9IDJcbiAgICAgIGVsc2VcbiAgICAgICAgc3VmZml4ID0gXCJHQlwiXG4gICAgICAgIGV4cCA9IDNcblxuICAgIChzaXplIC8gTWF0aC5wb3coMTAwMCwgZXhwKSkudG9GaXhlZCgxKSArIFwiIFwiICsgc3VmZml4XG5cblxuIyBsaWIvc3RhdGUuY29mZmVlXG5UYWtlIFtdLCAoKS0+XG5cbiAgc3RhdGUgPSB7fVxuICBzdWJzY3JpcHRpb25zID0ge19jYnM6W119XG5cbiAgZ2V0QXQgPSAobm9kZSwgcGF0aCktPlxuICAgIHJldHVybiBbe1wiXCI6bm9kZX0sIFwiXCJdIGlmIHBhdGggaXMgXCJcIlxuICAgIHBhcnRzID0gcGF0aC5zcGxpdCBcIi5cIlxuICAgIGsgPSBwYXJ0cy5wb3AoKVxuICAgIGZvciBwYXJ0IGluIHBhcnRzXG4gICAgICBub2RlID0gbm9kZVtwYXJ0XSA/PSB7fVxuICAgIFtub2RlLCBrXVxuXG5cbiAgTWFrZS5hc3luYyBcIlN0YXRlXCIsIFN0YXRlID0gKHBhdGggPSBcIlwiLCB2LCB7aW1tdXRhYmxlID0gZmFsc2V9ID0ge30pLT5cbiAgICBbbm9kZSwga10gPSBnZXRBdCBzdGF0ZSwgcGF0aFxuXG4gICAgcmV0dXJuIG5vZGVba10gaWYgdiBpcyB1bmRlZmluZWQgIyBKdXN0IGEgcmVhZFxuXG4gICAgIyBJdCdzIG5vdCBzYWZlIHRvIHRha2Ugc29tZXRoaW5nIG91dCBvZiBTdGF0ZSwgbXV0YXRlIGl0LCBhbmQgY29tbWl0IGl0IGFnYWluLlxuICAgICMgVGhlIGltbXV0YWJsZSBvcHRpb24gdGVsbHMgdXMgdGhlIGNhbGxlciBwcm9taXNlcyB0aGV5J3JlIG5vdCBkb2luZyB0aGF0LlxuICAgICMgT3RoZXJ3aXNlLCB3ZSBjbG9uZSB2YWx1ZXMgYmVmb3JlIHJlYWRpbmcgb3Igd3JpdGluZyB0aGVtLlxuICAgIHYgPSBGdW5jdGlvbi5jbG9uZSB2IHVubGVzcyBpbW11dGFibGVcblxuICAgIGlmIG5vdCBpbW11dGFibGUgYW5kIHYgaXMgbm9kZVtrXSBhbmQgKE9iamVjdC50eXBlKHYpIG9yIEFycmF5LnR5cGUodikpXG4gICAgICB0aHJvdyBcIkRpZCB5b3UgdGFrZSBzb21ldGhpbmcgb3V0IG9mIFN0YXRlLCBtdXRhdGUgaXQsIGFuZCBjb21taXQgaXQgYWdhaW4/XCJcblxuICAgIHRocm93IEVycm9yIFwiWW91J3JlIG5vdCBhbGxvd2VkIHRvIHNldCB0aGUgU3RhdGUgcm9vdFwiIGlmIHBhdGggaXMgXCJcIlxuXG4gICAgb2xkID0gbm9kZVtrXVxuXG4gICAgaWYgdj8gdGhlbiBub2RlW2tdID0gdiBlbHNlIGRlbGV0ZSBub2RlW2tdXG5cbiAgICBpZiBGdW5jdGlvbi5ub3RFcXVpdmFsZW50IHYsIG9sZFxuICAgICAgcXVldWVNaWNyb3Rhc2sgKCktPlxuICAgICAgICBsb2NhbE5vdGlmeSBwYXRoLCB2XG5cbiAgICByZXR1cm4gdlxuXG4gIGNvbmRpdGlvbmFsU2V0ID0gKHBhdGgsIHYsIHByZWQpLT5cbiAgICBbbm9kZSwga10gPSBnZXRBdCBzdGF0ZSwgcGF0aFxuICAgIGRvU2V0ID0gcHJlZCBub2RlW2tdLCB2XG4gICAgU3RhdGUgcGF0aCwgdiBpZiBkb1NldFxuICAgIHJldHVybiBkb1NldFxuXG4gICMgVGhlc2UgYXJlIHVzZWZ1bCBiZWNhdXNlIHRoZXkgcmV0dXJuIHRydWUgaWYgYSBjaGFuZ2Ugd2FzIG1hZGVcbiAgU3RhdGUuY2hhbmdlID0gKHBhdGgsIHYpLT4gY29uZGl0aW9uYWxTZXQgcGF0aCwgdiwgRnVuY3Rpb24ubm90RXF1aXZhbGVudFxuICBTdGF0ZS5kZWZhdWx0ID0gKHBhdGgsIHYpLT4gY29uZGl0aW9uYWxTZXQgcGF0aCwgdiwgRnVuY3Rpb24ubm90RXhpc3RzXG5cbiAgIyBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGl0IHJlZHVjZXMgdGhlIG5lZWQgdG8gdXBkYXRlIFN0YXRlIGluIGEgbG9vcCxcbiAgIyB3aGljaCB0cmlnZ2VycyBhIGxvdCBvZiAocG9zc2libHkgcG9pbnRsZXNzKSBub3RpZmljYXRpb25zLlxuICAjIFJlbWluZGVyIHRoYXQgT2JqZWN0Lm1lcmdlIGRvZXNuJ3QgaGFuZGxlIGFycmF5cywgc28gbWF5YmVcbiAgIyBsaW1pdCB0aGUgdXNlIG9mIHRoaXMgZnVuY3Rpb24gdG8gcHJpbWl0aXZlcyAoc2luY2UgaXQgaW1wbGllcyBpbW11dGFibGUpLlxuICBTdGF0ZS5tZXJnZSA9IChwYXRoLCB2KS0+IFN0YXRlIHBhdGgsIChPYmplY3QubWVyZ2UgdiwgU3RhdGUgcGF0aCksIGltbXV0YWJsZTogdHJ1ZVxuXG4gICMgVGhlc2UgYXJlIHVzZWZ1bCBiZWNhdXNlIGl0IG9mZmVycyBhIG5pY2Ugc3ludGF4IGZvciB1cGRhdGluZyBleGlzdGluZyB2YWx1ZXMgaW4gU3RhdGUsXG4gICMgd2l0aCBzdXBwb3J0IGZvciBhc3luYywgZWl0aGVyIG11dGFibHkgb3IgaW1tdXRhYmx5LlxuICBTdGF0ZS51cGRhdGUgPSAocGF0aCwgZm4pLT4gU3RhdGUgcGF0aCwgKGF3YWl0IGZuIFN0YXRlIHBhdGgpLCBpbW11dGFibGU6IHRydWVcbiAgU3RhdGUubXV0YXRlID0gKHBhdGgsIGZuKS0+IFN0YXRlLmNsb25lIHBhdGgsIChhd2FpdCBmbiBTdGF0ZSBwYXRoKSwgaW1tdXRhYmxlOiB0cnVlXG5cbiAgIyBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIHJlYWRpbmcgc29tZXRoaW5nIGZyb20gU3RhdGUgdGhhdCBpcyBwcmUtY2xvbmVkXG4gICMgKGlmIG5lY2Vzc2FyeSkgdG8gYXZvaWQgbXV0YWJpbGl0eSBpc3N1ZXMuXG4gIFN0YXRlLmNsb25lID0gKHBhdGgpLT4gRnVuY3Rpb24uY2xvbmUgU3RhdGUgcGF0aFxuXG4gIFN0YXRlLnN1YnNjcmliZSA9ICguLi5bcGF0aCA9IFwiXCIsIHJ1bk5vdyA9IHRydWUsIHdlYWsgPSBmYWxzZV0sIGNiKS0+XG4gICAgdGhyb3cgXCJJbnZhbGlkIHN1YnNjcmliZSBwYXRoXCIgdW5sZXNzIFN0cmluZy50eXBlIHBhdGggIyBBdm9pZCBlcnJvcnMgaWYgeW91IHRyeSBzYXkgc3Vic2NyaWJlKHJ1bk5vdywgY2IpXG4gICAgW25vZGUsIGtdID0gZ2V0QXQgc3Vic2NyaXB0aW9ucywgcGF0aFxuICAgICgobm9kZVtrXSA/PSB7fSkuX2NicyA/PSBbXSkucHVzaCBjYlxuICAgIGNiLl9zdGF0ZV93ZWFrID0gd2VhayAjIC4uLiB0aGlzIGlzIGZpbmUg8J+QleKYle+4j/CflKVcbiAgICBjYiBTdGF0ZSBwYXRoIGlmIHJ1bk5vd1xuXG4gIFN0YXRlLnVuc3Vic2NyaWJlID0gKC4uLltwYXRoID0gXCJcIl0sIGNiKS0+XG4gICAgW25vZGUsIGtdID0gZ2V0QXQgc3Vic2NyaXB0aW9ucywgcGF0aFxuICAgIHRocm93IEVycm9yIFwiVW5zdWJzY3JpYmUgZmFpbGVkXCIgdW5sZXNzIGNiIGluIG5vZGVba10uX2Nic1xuICAgIEFycmF5LnB1bGwgbm9kZVtrXS5fY2JzLCBjYlxuICAgIG51bGxcblxuICBsb2NhbE5vdGlmeSA9IChwYXRoLCB2KS0+XG4gICAgW25vZGUsIGtdID0gZ2V0QXQgc3Vic2NyaXB0aW9ucywgcGF0aFxuICAgIHJ1bkNic1dpdGhpbiBub2RlW2tdLCB2XG4gICAgcnVuQ2JzIG5vZGVba10sIHYsIHZcbiAgICBjaGFuZ2VzID0gcnVuQ2JzQWJvdmUgcGF0aCwgdlxuICAgIHJ1bkNicyBzdWJzY3JpcHRpb25zLCBzdGF0ZSwgY2hhbmdlc1xuXG4gIHJ1bkNic1dpdGhpbiA9IChwYXJlbnQsIHYpLT5cbiAgICByZXR1cm4gdW5sZXNzIE9iamVjdC50eXBlIHBhcmVudFxuICAgIGZvciBrLCBjaGlsZCBvZiBwYXJlbnQgd2hlbiBrIGlzbnQgXCJfY2JzXCJcbiAgICAgIF92ID0gdj9ba11cbiAgICAgIHJ1bkNic1dpdGhpbiBjaGlsZCwgX3ZcbiAgICAgIHJ1bkNicyBjaGlsZCwgX3YsIF92XG4gICAgbnVsbFxuXG4gIHJ1bkNic0Fib3ZlID0gKHBhdGgsIGNoYW5nZXMpLT5cbiAgICBwYXJ0cyA9IHBhdGguc3BsaXQgXCIuXCJcbiAgICBwID0gcGFydHMucG9wKClcbiAgICBjaGFuZ2VzQWJvdmUgPSB7fVxuICAgIGNoYW5nZXNBYm92ZVtwXSA9IGNoYW5nZXNcbiAgICByZXR1cm4gY2hhbmdlc0Fib3ZlIHVubGVzcyBwYXJ0cy5sZW5ndGggPiAwXG4gICAgcGF0aEFib3ZlID0gcGFydHMuam9pbiBcIi5cIlxuICAgIFtub2RlLCBrXSA9IGdldEF0IHN1YnNjcmlwdGlvbnMsIHBhdGhBYm92ZVxuICAgIHJ1bkNicyBub2RlW2tdLCBTdGF0ZShwYXRoQWJvdmUpLCBjaGFuZ2VzQWJvdmVcbiAgICBydW5DYnNBYm92ZSBwYXRoQWJvdmUsIGNoYW5nZXNBYm92ZVxuXG4gIHJ1bkNicyA9IChub2RlLCB2LCBjaGFuZ2VkKS0+XG4gICAgaWYgbm9kZT8uX2Nic1xuICAgICAgZGVhZCA9IFtdXG4gICAgICBmb3IgY2IgaW4gbm9kZS5fY2JzXG4gICAgICAgIGlmIGNiLl9zdGF0ZV93ZWFrIGFuZCBub3Qgdj9cbiAgICAgICAgICBkZWFkLnB1c2ggY2JcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNiIHYsIGNoYW5nZWRcbiAgICAgIEFycmF5LnB1bGwgbm9kZS5fY2JzLCBjYiBmb3IgY2IgaW4gZGVhZFxuICAgIG51bGxcblxuXG4jIGxpYi93cml0ZS5jb2ZmZWVcblRha2UgW1wiRW52XCIsIFwiTG9nXCIsIFwiUmVhZFwiXSwgKEVudiwgTG9nLCBSZWFkKS0+XG4gIGZzID0gcmVxdWlyZSBcImZzXCJcblxuICB2YWxpZFBhdGggPSAodiktPlxuICAgIHZhbGlkID0gdHJ1ZVxuICAgIHYgPSB2LnJlcGxhY2UgL15cXFxcKltBLVpdOi8sIFwiXCIgIyBJZ25vcmUgdGhlIGRyaXZlIGxldHRlciBvbiBXaW5kb3dzXG4gICAgdmFsaWQgPSBmYWxzZSBpZiAtMSBpc250IHYuc2VhcmNoIC9bPD46Oyw/XCIqfF0vICMgRXhjbHVkZSBuYW1lcyB3ZSB3b24ndCBiZSBhYmxlIHRvIHJvdW5kdHJpcFxuICAgIHZhbGlkID0gZmFsc2UgaWYgdi5sZW5ndGggPD0gMVxuICAgIGlmIG5vdCB2YWxpZCB0aGVuIExvZy5lcnIgXCIje3Z9IGlzIG5vdCBhIHZhbGlkIGZpbGUgcGF0aFwiXG4gICAgcmV0dXJuIHZhbGlkXG5cblxuICBNYWtlLmFzeW5jIFwiV3JpdGVcIiwgV3JpdGUgPSAoKS0+XG4gICAgdGhyb3cgXCJOb3QgSW1wbGVtZW50ZWRcIlxuXG4gIFdyaXRlLmxvZ2dpbmcgPSB0cnVlXG5cbiAgV3JpdGUuc3luYyA9IHt9XG4gIFdyaXRlLmFzeW5jID0ge31cblxuICBNZW1vcnkgPSBudWxsXG5cbiAgbG9nV3JpdGUgPSAoZm4sIHAsIG9wdHMgPSB7fSktPlxuICAgIHJldHVybiBpZiBvcHRzLnF1aWV0XG4gICAgcmV0dXJuIHVubGVzcyBXcml0ZS5sb2dnaW5nXG4gICAgaWYgTWVtb3J5ID89IFRha2UgXCJNZW1vcnlcIlxuICAgICAgcCA9IHAucmVwbGFjZSBNZW1vcnkoXCJhc3NldHNGb2xkZXJcIikgKyBSZWFkLnNlcCwgXCJcIiB1bmxlc3MgcCBpcyBNZW1vcnkoXCJhc3NldHNGb2xkZXJcIilcbiAgICAgIHAgPSBwLnJlcGxhY2UgTWVtb3J5KFwiZGF0YUZvbGRlclwiKSArIFJlYWQuc2VwLCBcIlwiIHVubGVzcyBwIGlzIE1lbW9yeShcImRhdGFGb2xkZXJcIilcbiAgICBwID0gcC5yZXBsYWNlIEVudi5ob21lICsgUmVhZC5zZXAsIFwiXCIgdW5sZXNzIHAgaXMgRW52LmhvbWVcbiAgICBMb2cgXCJXUklURSAje2ZufSAje3B9XCJcblxuICBXcml0ZS5zeW5jLmZpbGUgPSAocGF0aCwgZGF0YSwgb3B0cyktPlxuICAgIGlmIHZhbGlkID0gdmFsaWRQYXRoIHBhdGhcbiAgICAgIGxvZ1dyaXRlIFwiZmlsZVwiLCBwYXRoLCBvcHRzXG4gICAgICBmcy53cml0ZUZpbGVTeW5jIHBhdGgsIGRhdGFcbiAgICByZXR1cm4gdmFsaWRcblxuICBXcml0ZS5zeW5jLm1rZGlyID0gKHBhdGgsIG9wdHMpLT5cbiAgICByZXR1cm4gdHJ1ZSBpZiBmcy5leGlzdHNTeW5jIHBhdGhcbiAgICBpZiB2YWxpZCA9IHZhbGlkUGF0aCBwYXRoXG4gICAgICBsb2dXcml0ZSBcIm1rZGlyXCIsIHBhdGgsIG9wdHNcbiAgICAgIGZzLm1rZGlyU3luYyBwYXRoLCByZWN1cnNpdmU6IHRydWVcbiAgICByZXR1cm4gdmFsaWRcblxuICBXcml0ZS5zeW5jLnJlbmFtZSA9IChwYXRoLCBuZXdOYW1lLCBvcHRzKS0+XG4gICAgbmV3UGF0aCA9IFJlYWQuc2VwICsgUmVhZC5wYXRoIFJlYWQucGFyZW50UGF0aChwYXRoKSwgbmV3TmFtZVxuICAgIHJldHVybiB0cnVlIGlmIHBhdGggaXMgbmV3UGF0aFxuICAgIGlmIHZhbGlkID0gdmFsaWRQYXRoKHBhdGgpIGFuZCB2YWxpZFBhdGgobmV3UGF0aClcbiAgICAgIGxvZ1dyaXRlIFwicmVuYW1lXCIsIFwiI3twYXRofSAtPiAje25ld1BhdGh9XCIsIG9wdHNcbiAgICAgIGZzLnJlbmFtZVN5bmMgcGF0aCwgbmV3UGF0aFxuICAgIHJldHVybiB2YWxpZFxuXG4gIFdyaXRlLnN5bmMucm0gPSAocGF0aCwgb3B0cyktPlxuICAgIHJldHVybiB0cnVlIGlmIG5vdCBmcy5leGlzdHNTeW5jIHBhdGhcbiAgICBpZiB2YWxpZCA9IHZhbGlkUGF0aCBwYXRoXG4gICAgICBsb2dXcml0ZSBcInJtXCIsIHBhdGgsIG9wdHNcbiAgICAgIGZzLnJtU3luYyBwYXRoLCByZWN1cnNpdmU6IHRydWVcbiAgICByZXR1cm4gdmFsaWRcblxuICBXcml0ZS5zeW5jLmNvcHlGaWxlID0gKHNyYywgZGVzdCwgb3B0cyktPlxuICAgIGlmIHZhbGlkID0gdmFsaWRQYXRoKHNyYykgYW5kIHZhbGlkUGF0aChkZXN0KVxuICAgICAgbG9nV3JpdGUgXCJjb3B5RmlsZVwiLCBcIiN7c3JjfSAtPiAje2Rlc3R9XCIsIG9wdHNcbiAgICAgIGZzLmNvcHlGaWxlU3luYyBzcmMsIGRlc3RcbiAgICByZXR1cm4gdmFsaWRcblxuICBXcml0ZS5zeW5jLmpzb24gPSAocGF0aCwgZGF0YSwgb3B0cyktPlxuICAgIFdyaXRlLnN5bmMuZmlsZSBwYXRoLCBKU09OLnN0cmluZ2lmeShkYXRhKSwgb3B0c1xuXG4gIFdyaXRlLnN5bmMuYXJyYXkgPSAocGF0aCwgYXJyLCBvcHRzKS0+XG4gICAgY3VycmVudCA9IFJlYWQgcGF0aFxuICAgIGN1cnJlbnQgPz0gW11cbiAgICByZXR1cm4gaWYgQXJyYXkuZXF1YWwgYXJyLCBjdXJyZW50XG4gICAgIyBSZW1vdmUgYW55dGhpbmcgdGhhdCdzIGluIHRoZSBmb2xkZXIgYnV0IG5vdCBpbiBvdXIgbmV3IGFycmF5XG4gICAgV3JpdGUuc3luYy5ybSBSZWFkLnBhdGgocGF0aCwgdiksIG9wdHMgZm9yIHYgaW4gY3VycmVudCB3aGVuIHYgbm90IGluIGFyclxuICAgICMgU2F2ZSBhbnl0aGluZyB0aGF0J3MgaW4gb3VyIG5ldyBhcnJheSBidXQgbm90IGluIHRoZSBmb2xkZXJcbiAgICBXcml0ZS5zeW5jLm1rZGlyIFJlYWQucGF0aChwYXRoLCB2KSwgb3B0cyBmb3IgdiBpbiBhcnIgd2hlbiB2IG5vdCBpbiBjdXJyZW50XG4gICAgbnVsbFxuXG5cbiAgV3JpdGUuYXN5bmMuY29weUludG8gPSAoc3JjLCBkZXN0Rm9sZGVyLCBvcHRzKS0+XG4gICAgc3JjTmFtZSA9IFJlYWQubGFzdCBzcmNcbiAgICBpZiBhd2FpdCBSZWFkLmlzRm9sZGVyIHNyY1xuICAgICAgY2hpbGREZXN0Rm9sZGVyID0gUmVhZC5wYXRoIGRlc3RGb2xkZXIsIHNyY05hbWVcbiAgICAgIFdyaXRlLnN5bmMubWtkaXIgY2hpbGREZXN0Rm9sZGVyLCBvcHRzXG4gICAgICB2YWxpZCA9IHRydWVcbiAgICAgIGZvciBpdGVtIGluIFJlYWQgc3JjXG4gICAgICAgIF92YWxpZCA9IFdyaXRlLmFzeW5jLmNvcHlJbnRvIFJlYWQucGF0aChzcmMsIGl0ZW0pLCBjaGlsZERlc3RGb2xkZXIsIG9wdHNcbiAgICAgICAgdmFsaWQgJiY9IF92YWxpZFxuICAgICAgcmV0dXJuIHZhbGlkXG4gICAgZWxzZVxuICAgICAgV3JpdGUuc3luYy5jb3B5RmlsZSBzcmMsIFJlYWQucGF0aChkZXN0Rm9sZGVyLCBzcmNOYW1lKSwgb3B0c1xuXG5cbiMgY29tbW9uL2Fkc3Itc3RhdHVzLmNvZmZlZVxuVGFrZSBbXCJBRFNSXCJdLCAoQURTUiktPlxuXG4gIGVsbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgXCJhZHNyLXN0YXR1c1wiXG4gIHJldHVybiB1bmxlc3MgZWxtP1xuXG4gIEFEU1Iud2F0Y2hlciAoY291bnQsIGRlbGF5KS0+XG4gICAgY291bnQgPSBTdHJpbmcucGx1cmFsaXplIGNvdW50LCBcIiUlIEFEU1JcIlxuICAgIGVsbS50ZXh0Q29udGVudCA9IFwiI3tjb3VudH0gQWN0aXZlXCJcblxuXG4jIGNvbW1vbi9kYi5jb2ZmZWVcblRha2UgW1wiSVBDXCIsIFwiTG9nXCJdLCAoSVBDLCBMb2cpLT5cbiAgcmV0dXJuIGlmIHdpbmRvdy5pc0RCICMgVGhlIERCIHByb2Nlc3MgZG9lc24ndCB1c2UgdGhpcyDigJQgdXNlIFBvcnRzIGluc3RlYWRcblxuICBiaW5kID0gbmV3IFByb21pc2UgKHJlc29sdmUpLT5cbiAgICBJUEMub24gXCJwb3J0XCIsICh7cG9ydHN9LCB7aWR9KS0+XG4gICAgICByZXNvbHZlIFtwb3J0c1swXSwgaWRdXG5cbiAgSVBDLnNlbmQgXCJiaW5kLWRiXCJcblxuICBbZGIsIGlkXSA9IGF3YWl0IGJpbmRcblxuICByZXF1ZXN0cyA9IHt9XG4gIGxpc3RlbmVycyA9IHt9XG4gIGlnbm9yZUxpc3QgPSB7XCJtZW1vcnktYnJvYWRjYXN0XCJ9XG4gIHJlcXVlc3RJRCA9IDBcblxuICBkYi5vbm1lc3NhZ2UgPSAoe2RhdGE6IFttc2csIC4uLmRhdGFdfSktPlxuICAgIGlmIG1zZyBpcyBcInJldHVyblwiXG4gICAgICByZXR1cm5lZCAuLi5kYXRhXG4gICAgZWxzZSBpZiBsID0gbGlzdGVuZXJzW21zZ11cbiAgICAgIGNiIC4uLmRhdGEgZm9yIGNiIGluIGxcbiAgICBlbHNlIGlmIG5vdCBpZ25vcmVMaXN0W21zZ10/ICMgV2UgY2FuIHNhZmVseSBpZ25vcmUgY2VydGFpbiBtZXNzYWdlcyBkcm9wcGluZ1xuICAgICAgTG9nIFwiTWVzc2FnZSBmcm9tIERCIGRyb3BwZWQ6ICN7bXNnfVwiXG5cbiAgcmV0dXJuZWQgPSAocmVxdWVzdElELCByZXNwKS0+XG4gICAgcmVzb2x2ZSA9IHJlcXVlc3RzW3JlcXVlc3RJRF1cbiAgICBkZWxldGUgcmVxdWVzdHNbcmVxdWVzdElEXVxuICAgIHJlc29sdmUgcmVzcFxuXG4gIE1ha2UgXCJEQlwiLCBEQiA9XG4gICAgb246IChtc2csIGNiKS0+IChsaXN0ZW5lcnNbbXNnXSA/PSBbXSkucHVzaCBjYlxuICAgIHNlbmQ6IChtc2csIC4uLmFyZ3MpLT5cbiAgICAgIHJlcXVlc3RJRCsrICUgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICAgIHJlc3BvbnNlID0gbmV3IFByb21pc2UgKHJlc29sdmUpLT4gcmVxdWVzdHNbcmVxdWVzdElEXSA9IHJlc29sdmVcbiAgICAgIGRiLnBvc3RNZXNzYWdlIFtyZXF1ZXN0SUQsIG1zZywgLi4uYXJnc11cbiAgICAgIHJlc3BvbnNlXG5cblxuIyBjb21tb24vZWRpdGFibGUtZmllbGQuY29mZmVlXG5UYWtlIFtcIkRPT01cIl0sIChET09NKS0+XG5cbiAgTWFrZSBcIkVkaXRhYmxlRmllbGRcIiwgRWRpdGFibGVGaWVsZCA9IChlbG0sIGNiLCBvcHRzID0ge30pLT5cbiAgICByZXR1cm4gaWYgRE9PTShlbG0sIFwiZWRpdGFibGVGaWVsZFwiKT9cblxuICAgIHN0YXJ0VmFsdWUgPSBudWxsXG5cbiAgICBET09NIGVsbSxcbiAgICAgIGVkaXRhYmxlRmllbGQ6IFwiXCJcbiAgICAgIGNvbnRlbnRlZGl0YWJsZTogXCJcIlxuICAgICAgYXV0b2NvbXBsZXRlOiBcIm9mZlwiXG4gICAgICBhdXRvY29ycmVjdDogXCJvZmZcIlxuICAgICAgYXV0b2NhcGl0YWxpemU6IFwib2ZmXCJcbiAgICAgIHNwZWxsY2hlY2s6IFwiZmFsc2VcIlxuXG4gICAgc2V0VmFsdWUgPSAoKS0+XG4gICAgICB2YWxpZGF0ZSgpXG4gICAgICBjYiBlbG0udGV4dENvbnRlbnQgaWYgZWxtLl92YWxpZFxuXG4gICAgdmFsaWRhdGUgPSAoKS0+XG4gICAgICBlbG0udGV4dENvbnRlbnQgPSBlbG0udGV4dENvbnRlbnQudHJpbSgpXG4gICAgICBpZiBvcHRzLnZhbGlkYXRlP1xuICAgICAgICBlbG0uX3ZhbGlkID0gb3B0cy52YWxpZGF0ZSBlbG0udGV4dENvbnRlbnRcbiAgICAgICAgRE9PTSBlbG0sIGZpZWxkSW52YWxpZDogaWYgZWxtLl92YWxpZCB0aGVuIG51bGwgZWxzZSBcIlwiXG4gICAgICBlbHNlXG4gICAgICAgIGVsbS5fdmFsaWQgPSB0cnVlXG5cbiAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lciBcImlucHV0XCIsIChlKS0+XG4gICAgICBzZXRWYWx1ZSgpIGlmIG9wdHMuc2F2ZU9uSW5wdXRcblxuICAgIGVsbS5hZGRFdmVudExpc3RlbmVyIFwiZm9jdXNcIiwgKCktPlxuICAgICAgdmFsaWRhdGUoKVxuICAgICAgc3RhcnRWYWx1ZSA9IGVsbS50ZXh0Q29udGVudFxuXG4gICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIgXCJibHVyXCIsICgpLT5cbiAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5lbXB0eSgpXG4gICAgICBzZXRWYWx1ZSgpXG5cbiAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lciBcImtleWRvd25cIiwgKGUpLT5cbiAgICAgIHN3aXRjaCBlLmtleUNvZGVcbiAgICAgICAgd2hlbiAxM1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgIGVsbS5ibHVyKClcblxuICAgICAgICB3aGVuIDI3XG4gICAgICAgICAgZWxtLnRleHRDb250ZW50ID0gc3RhcnRWYWx1ZVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgIGVsbS5ibHVyKClcblxuXG4jIGNvbW1vbi9lbnYtc3R5bGUuY29mZmVlXG5UYWtlIFtcIkRPT01cIiwgXCJFbnZcIl0sIChET09NLCBFbnYpLT5cblxuICBET09NIGRvY3VtZW50LmJvZHksXG4gICAgZW52RGV2OiBFbnYuaXNEZXZcbiAgICBlbnZNYWM6IEVudi5pc01hY1xuXG5cbiMgY29tbW9uL2Vudi5jb2ZmZWVcblRha2UgW1wiSVBDXCJdLCAoSVBDKS0+XG4gIEVudiA9IGF3YWl0IElQQy5pbnZva2UgXCJlbnZcIlxuXG4gIEVudi5pc01haW4gPSBmYWxzZVxuICBFbnYuaXNSZW5kZXIgPSB0cnVlXG5cbiAgTWFrZSBcIkVudlwiLCBFbnZcblxuXG4jIGNvbW1vbi9maW5kLmNvZmZlZVxuIyBUaGUgbWFpbiB3aW5kb3cgc2V0cyB1cCBhIGdsb2JhbCBDb21tYW5kLUYgbWVudSBpdGVtLCB3aGljaCB3aWxsIGZvcndhcmRcbiMgYSBcImZpbmRcIiBJUEMgZXZlbnQgdG8gdGhlIGZyb250bW9zdCB3aW5kb3cuIEhlcmUgd2UgY2F0Y2ggaXQgYW5kIHBhc3MgaXQgYWxvbmdcbiMgdG8gYW55IGludGVyZXN0ZWQgcGFydGllcyBpbiB0aGlzIHdpbmRvdy5cblxuVGFrZSBbXCJJUENcIiwgXCJQdWJTdWJcIl0sIChJUEMsIHtQdWIsIFN1Yn0pLT5cbiAgSVBDLm9uIFwiZmluZFwiLCAoKS0+IFB1YiBcImZpbmRcIlxuXG5cbiMgY29tbW9uL2dlYXItdmlldy5jb2ZmZWVcblRha2UgW1wiRE9PTVwiLCBcIkRPTUNvbnRlbnRMb2FkZWRcIl0sIChET09NKS0+XG5cbiAgTWFrZSBcIkdlYXJWaWV3XCIsIChkZXB0aCA9IDMwLCBvZmZzZXQgPSAtMTAsIGF0dHJzID0ge30pLT5cbiAgICBnZWFyc0VsbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgXCJnZWFyLXZpZXdcIlxuXG4gICAgZ2VhckVsbSA9IGdlYXJzRWxtXG4gICAgZm9yIGkgaW4gWzAuLmRlcHRoXVxuICAgICAgZ2VhckVsbSA9IERPT00uY3JlYXRlIFwic3BhblwiLCBnZWFyRWxtICMgRm9yIHNwZWNpYWwgZWZmZWN0c1xuICAgICAgZ2VhckVsbSA9IERPT00uY3JlYXRlIFwiZGl2XCIsIGdlYXJFbG0sIHN0eWxlOiBcImFuaW1hdGlvbi1kZWxheTogI3tvZmZzZXR9c1wiXG5cbiAgICBET09NIGdlYXJzRWxtLCBhdHRyc1xuXG5cbiMgY29tbW9uL2hvbGQtdG8tcnVuLmNvZmZlZVxuVGFrZSBbXCJET09NXCIsIFwiRE9NQ29udGVudExvYWRlZFwiXSwgKERPT00pLT5cblxuICBpc0Rvd24gPSBudWxsXG4gIHRpbWVvdXQgPSBudWxsXG5cbiAgZG93biA9IChlbG0sIHRpbWUsIGNiKS0+IChlKS0+XG4gICAgaWYgbm90IGlzRG93bj8gYW5kIGUuYnV0dG9uIGlzIDBcbiAgICAgIGlzRG93biA9IGVsbVxuICAgICAgRE9PTSBpc0Rvd24sIGhvbGRBY3RpdmU6IFwiXCIsIGhvbGRMb25nZXI6IG51bGxcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0IHJ1bihjYiksIHRpbWVcblxuICB1cCA9ICgpLT5cbiAgICBpZiBpc0Rvd24/XG4gICAgICBET09NIGlzRG93biwgaG9sZEFjdGl2ZTogbnVsbCwgaG9sZExvbmdlcjogXCJcIlxuICAgICAgY2xlYXJUaW1lb3V0IHRpbWVvdXRcbiAgICAgIGlzRG93biA9IG51bGxcblxuICBydW4gPSAoY2IpLT4gKCktPlxuICAgIGlzRG93biA9IG51bGxcbiAgICBjYigpXG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgXCJtb3VzZXVwXCIsIHVwXG5cbiAgTWFrZSBcIkhvbGRUb1J1blwiLCBIb2xkVG9SdW4gPSAoZWxtLCB0aW1lLCBjYiktPlxuICAgIERPT00gZWxtLCBob2xkVG9SdW46IFwiXCJcbiAgICBlbG0uc3R5bGUuc2V0UHJvcGVydHkgXCItLWhvbGQtdGltZVwiLCB0aW1lICsgXCJtc1wiXG4gICAgZWxtLm9ubW91c2Vkb3duID0gZG93biBlbG0sIHRpbWUsIGNiXG5cblxuIyBjb21tb24vaWNvbnMuY29mZmVlXG5UYWtlIFtcIkRPT01cIiwgXCJET01Db250ZW50TG9hZGVkXCJdLCAoRE9PTSktPlxuICBET09NLmNyZWF0ZSBcInN2Z1wiLCBkb2N1bWVudC5ib2R5LFxuICAgIGlkOiBcImljb25zXCJcbiAgICBpbm5lckhUTUw6XCJcIlwiXG4gICAgICA8ZGVmcz5cbiAgICAgICAgPHBhdGggaWQ9XCJpLWNoZWNrXCIgZD1cIk0yMCAxMDBMNzUgMTU1IDE4NSA0NVwiLz5cbiAgICAgICAgPHBhdGggaWQ9XCJpLWV4XCIgZD1cIk0zNSAxNjUgTDE2NSAzNSBNMzUgMzUgTDE2NSAxNjVcIi8+XG4gICAgICAgIDxwYXRoIGlkPVwiaS1hcnJvd1wiIGQ9XCJNNDAgMTAwIEwxODAgMTAwIE0xMTAgMzAgTDQwIDEwMCAxMTAgMTcwXCIvPlxuICAgICAgICA8cGF0aCBpZD1cImktZGlhbW9uZFwiIGQ9XCJNMTY1IDEwMEwxMDAgMTY1IDM1IDEwMCAxMDAgMzV6XCIvPlxuICAgICAgICA8ZyBpZD1cImktZXllXCIgdHJhbnNmb3JtPVwic2NhbGUoMS44LCAxLjgpIHRyYW5zbGF0ZSgwLCAxNSlcIiBzdHJva2Utd2lkdGg9XCIxMFwiPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNNTUuNSA1YzE5IDAgMzUuNCAxMS45IDQ5LjYgMzQuNUM5MSA2Mi4xIDc0LjUgNzQgNTUuNSA3NFMyMC4xIDYyLjEgNS45IDM5LjVDMjAgMTYuOSAzNi41IDUgNTUuNSA1elwiLz5cbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiNTUuNVwiIGN5PVwiMzkuNVwiIHI9XCIxOC41XCIvPlxuICAgICAgICA8L2c+XG4gICAgICAgIDxnIGlkPVwiaS1maWxlXCIgc3Ryb2tlLXdpZHRoPVwiMThcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTTM4LDE5IEwxMDgsMTkgQzExMCwxOSAxMTIsMTkgMTE0LDIxIEwxNTksNjUgQzE2MSw2NyAxNjIsNjkgMTYyLDcxIEwxNjIsMTgwIEwxNjIsMTgwIEwzOCwxODAgTDM4LDE5IFpcIi8+XG4gICAgICAgICAgPHBvbHlsaW5lIHBvaW50cz1cIjE2MiA3MCAxMDggNzAgMTA4IDE5XCIvPlxuICAgICAgICA8L2c+XG4gICAgICA8L2RlZnM+XG4gICAgXCJcIlwiXG5cblxuIyBjb21tb24vaXBjLmNvZmZlZVxuVGFrZSBbXSwgKCktPlxuICB7IGlwY1JlbmRlcmVyIH0gPSByZXF1aXJlIFwiZWxlY3Ryb25cIlxuXG4gIE1ha2UgXCJJUENcIiwgSVBDID1cbiAgICBzZW5kOiAoLi4uYXJncyktPiBpcGNSZW5kZXJlci5zZW5kIC4uLmFyZ3NcbiAgICBpbnZva2U6ICguLi5hcmdzKS0+IGlwY1JlbmRlcmVyLmludm9rZSAuLi5hcmdzXG5cbiAgICBvbjogKGNoYW5uZWwsIGNiKS0+IGlwY1JlbmRlcmVyLm9uIGNoYW5uZWwsIGNiXG4gICAgb25jZTogKGNoYW5uZWwsIGNiKS0+IGlwY1JlbmRlcmVyLm9uIGNoYW5uZWwsIGNiXG5cbiAgICAjIFByb21pc2UtYmFzZWQgaGFuZGxlcnMsIG9wdGltaXplZCBmb3IgdXNlIHdpdGggYXdhaXRcbiAgICBwcm9taXNlOlxuICAgICAgb25jZTogKGNoYW5uZWwpLT4gbmV3IFByb21pc2UgKHJlc29sdmUpLT4gaXBjUmVuZGVyZXIub25jZSBjaGFubmVsLCByZXNvbHZlXG5cblxuIyBjb21tb24vam9iLXN0YXR1cy5jb2ZmZWVcblRha2UgW1wiSm9iXCJdLCAoSm9iKS0+XG5cbiAgZWxtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciBcImpvYi1zdGF0dXNcIlxuICByZXR1cm4gdW5sZXNzIGVsbT9cblxuICBKb2Iud2F0Y2hlciAoY291bnQsIGRlbGF5KS0+XG4gICAgY291bnQgPSBTdHJpbmcucGx1cmFsaXplIGNvdW50LCBcIiUlIEpvYlwiXG4gICAgZWxtLmZpcnN0Q2hpbGQudGV4dENvbnRlbnQgPSBcIiN7Y291bnR9IFF1ZXVlZFwiXG4gICAgZWxtLmxhc3RDaGlsZC50ZXh0Q29udGVudCA9IFwiKCN7ZGVsYXl8MH1tcylcIlxuXG5cbiMgY29tbW9uL21lbW9yeS1maWVsZC5jb2ZmZWVcblRha2UgW1wiRE9PTVwiLCBcIkVkaXRhYmxlRmllbGRcIiwgXCJNZW1vcnlcIl0sIChET09NLCBFZGl0YWJsZUZpZWxkLCBNZW1vcnkpLT5cblxuICBNYWtlIFwiTWVtb3J5RmllbGRcIiwgTWVtb3J5RmllbGQgPSAobWVtb3J5S2V5LCBlbG0sIG9wdHMgPSB7fSktPlxuXG4gICAgIyBGbGFnIHdoZXRoZXIgd2UndmUgYmVlbiBzZXQgdXAgb24gYW4gZWxtIGFscmVhZHkuIFRoYXQgbWFrZXMgaXQgc2FmZSB0byBjcmVhdGUgYVxuICAgICMgTWVtb3J5RmllbGQgaW5zaWRlIGEgcmVwZWF0ZWRseS1ydW4gUmVuZGVyIGNhbGwuXG4gICAgcmV0dXJuIGlmIERPT00oZWxtLCBcIm1lbW9yeUZpZWxkXCIpP1xuICAgIERPT00gZWxtLCBtZW1vcnlGaWVsZDogXCJcIlxuXG4gICAgZm9jdXNlZCA9IGZhbHNlXG5cbiAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lciBcImZvY3VzXCIsIChlKS0+IGZvY3VzZWQgPSB0cnVlXG4gICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIgXCJibHVyXCIsIChlKS0+IGZvY3VzZWQgPSBmYWxzZVxuXG4gICAgTWVtb3J5LnN1YnNjcmliZSBcIlJlYWQgT25seVwiLCB0cnVlLCAodiktPlxuICAgICAgRE9PTSBlbG0sIGNvbnRlbnRlZGl0YWJsZTogaWYgdiB0aGVuIG51bGwgZWxzZSBcIlwiXG5cbiAgICBNZW1vcnkuc3Vic2NyaWJlIG1lbW9yeUtleSwgdHJ1ZSwgKHZhbHVlKS0+XG4gICAgICByZXR1cm4gdW5sZXNzIHZhbHVlXG4gICAgICByZXR1cm4gaWYgZm9jdXNlZFxuICAgICAgZWxtLnRleHRDb250ZW50ID0gdmFsdWVcblxuICAgIHNldFZhbHVlID0gKHZhbHVlKS0+XG4gICAgICBNZW1vcnkgbWVtb3J5S2V5LCB2YWx1ZVxuICAgICAgb3B0cy51cGRhdGU/IHZhbHVlXG5cbiAgICBFZGl0YWJsZUZpZWxkIGVsbSwgc2V0VmFsdWUsIG9wdHNcblxuXG4jIGNvbW1vbi9tZW1vcnkuY29mZmVlXG5UYWtlIFtdLCAoKS0+XG5cbiAgbWVtb3J5ID0gbnVsbCAjIFN0b3JlcyBhbGwgdGhlIHZhbHVlcyBjb21taXR0ZWQgdG8gTWVtb3J5XG4gIHN1YnNjcmlwdGlvbnMgPSB7X2NiczpbXX0gIyBOb3RpZmllZCB3aGVuIHNwZWNpZmljIHBhdGhzIGFyZSBjaGFuZ2VkXG5cblxuICBpZiB3aW5kb3cuaXNEQlxuXG4gICAgUG9ydHMgPSBhd2FpdCBUYWtlLmFzeW5jIFwiUG9ydHNcIlxuXG4gICAgIyBEQiBvd25zIHRoZSBjYW5ub25pY2FsIGNvcHkgb2YgTWVtb3J5LCBzbyB3ZSBpbml0aWFsaXplIHRvIGFuIGVtcHR5IG9iamVjdCB0byBzdG9yZSBpdCBhbGxcbiAgICBtZW1vcnkgPSB7fVxuXG4gICAgIyBPdGhlciB3aW5kb3dzIHdpbGwgd2FudCB0byBpbml0aWFsaXplIHRoZW1zZWx2ZXMgd2l0aCBhIGNsb25lIG91ciBNZW1vcnlcbiAgICBQb3J0cy5vbiBcImNsb25lLW1lbW9yeVwiLCAoKS0+IG1lbW9yeVxuXG4gICAgIyBPdGhlciB3aW5kb3dzIHdpbGwgbm90aWZ5IHVzIHdoZW4gdGhleSB3YW50IHRvIGNoYW5nZSBzb21ldGhpbmcgaW4gTWVtb3J5XG4gICAgUG9ydHMub24gXCJtZW1vcnktbm90aWZ5LWRiXCIsIChwYXRoLCB2KS0+IE1lbW9yeSBwYXRoLCB2XG5cbiAgICAjIFdoZW4gdGhlIERCJ3MgTWVtb3J5IGNoYW5nZXMsIHdlIHNob3VsZCBub3RpZnkgb3RoZXIgd2luZG93c1xuICAgIHJlbW90ZU5vdGlmeSA9IChwYXRoLCB2KS0+IFBvcnRzLnNlbmQgXCJtZW1vcnktYnJvYWRjYXN0XCIsIHBhdGgsIHZcblxuICBlbHNlXG5cbiAgICBEQiA9IGF3YWl0IFRha2UuYXN5bmMgXCJEQlwiXG5cbiAgICAjIFRoZSBEQiBvd25zIHRoZSBjYW5ub25pY2FsIGNvcHkgb2YgTWVtb3J5LCBzbyB3ZSBpbml0aWFsaXplIHRvIGEgY2xvbmUgb2Ygd2hhdGV2ZXIgaXQgaGFzXG4gICAgbWVtb3J5ID0gYXdhaXQgREIuc2VuZCBcImNsb25lLW1lbW9yeVwiXG5cbiAgICAjIE5vdGlmeSB0aGUgREIgd2hlbmV2ZXIgYW55dGhpbmcgaW4gb3VyIE1lbW9yeSBjaGFuZ2VzXG4gICAgcmVtb3RlTm90aWZ5ID0gKHBhdGgsIHYpLT4gREIuc2VuZCBcIm1lbW9yeS1ub3RpZnktZGJcIiwgcGF0aCwgdlxuXG4gICAgIyBXaGVuIHRoZSBEQidzIG1lbW9yeSBjaGFuZ2VzLCBpdCdsbCBub3RpZnkgdXNcbiAgICBEQi5vbiBcIm1lbW9yeS1icm9hZGNhc3RcIiwgKHBhdGgsIHYpLT4gTWVtb3J5IHBhdGgsIHYsIHJlbW90ZTogZmFsc2VcblxuXG4gICMgVGhpcyBpcyBob3cgd2Ugc3VwcG9ydCBcImRlZXAucGF0aHNcIjpcbiAgIyBQYXNzIGEgdHJlZS1saWtlIG9iamVjdCwgYW5kIGEgZG90LXNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5cy5cbiAgIyBXZSdsbCByZXR1cm4gdGhlIHBlbnVsdGltYXRlIG5vZGUgaW4gdGhlIHRyZWUsIGFuZCB0aGUgZmluYWwga2V5LlxuICAjIChTdG9wcGluZyBqdXN0IGFib3ZlIHRoZSBmaW5hbCBub2RlIGFsbG93cyB5b3UgdG8gZG8gYXNzaWdubWVudC4pXG4gICMgRm9yIHVuaWZvcm1pdHksIHBhc3MgXCJcIiB0byBnZXQgYmFjayB0aGUgdHJlZSByb290IHdyYXBwZWQgaW4gYSBub2RlIHdpdGggYSBcIlwiIGtleS5cbiAgZ2V0QXQgPSAobm9kZSwgcGF0aCktPlxuICAgIHJldHVybiBbe1wiXCI6bm9kZX0sIFwiXCJdIGlmIHBhdGggaXMgXCJcIlxuICAgIHBhcnRzID0gcGF0aC5zcGxpdCBcIi5cIlxuICAgIGsgPSBwYXJ0cy5wb3AoKVxuICAgIGZvciBwYXJ0IGluIHBhcnRzXG4gICAgICBub2RlID0gbm9kZVtwYXJ0XSA/PSB7fVxuICAgIFtub2RlLCBrXVxuXG5cbiAgTWFrZS5hc3luYyBcIk1lbW9yeVwiLCBNZW1vcnkgPSAocGF0aCA9IFwiXCIsIHYsIHtyZW1vdGUgPSB0cnVlLCBpbW11dGFibGUgPSBmYWxzZX0gPSB7fSktPlxuICAgIFtub2RlLCBrXSA9IGdldEF0IG1lbW9yeSwgcGF0aFxuXG4gICAgcmV0dXJuIG5vZGVba10gaWYgdiBpcyB1bmRlZmluZWQgIyBKdXN0IGEgcmVhZFxuXG4gICAgIyBJdCdzIG5vdCBzYWZlIHRvIHRha2Ugc29tZXRoaW5nIG91dCBvZiBNZW1vcnksIG11dGF0ZSBpdCwgYW5kIGNvbW1pdCBpdCBhZ2Fpbi5cbiAgICAjIFRoZSBpbW11dGFibGUgb3B0aW9uIHRlbGxzIHVzIHRoZSBjYWxsZXIgcHJvbWlzZXMgdGhleSdyZSBub3QgZG9pbmcgdGhhdC5cbiAgICAjIE90aGVyd2lzZSwgd2UgY2xvbmUgdmFsdWVzIGJlZm9yZSB3cml0aW5nIHRoZW0uXG4gICAgdiA9IEZ1bmN0aW9uLmNsb25lIHYgdW5sZXNzIGltbXV0YWJsZVxuXG4gICAgaWYgKE9iamVjdC50eXBlKHYpIG9yIEFycmF5LnR5cGUodikpIGFuZCB2IGlzIG5vZGVba11cbiAgICAgIHRocm93IFwiRGlkIHlvdSB0YWtlIHNvbWV0aGluZyBvdXQgb2YgTWVtb3J5LCBtdXRhdGUgaXQsIGFuZCBjb21taXQgaXQgYWdhaW4/XCJcblxuICAgIHRocm93IEVycm9yIFwiWW91J3JlIG5vdCBhbGxvd2VkIHRvIHNldCB0aGUgTWVtb3J5IHJvb3RcIiBpZiBwYXRoIGlzIFwiXCJcblxuICAgIG9sZCA9IG5vZGVba11cblxuICAgIGlmIHY/IHRoZW4gbm9kZVtrXSA9IHYgZWxzZSBkZWxldGUgbm9kZVtrXVxuXG4gICAgaWYgRnVuY3Rpb24ubm90RXF1aXZhbGVudCB2LCBvbGRcbiAgICAgIHF1ZXVlTWljcm90YXNrICgpLT5cbiAgICAgICAgbG9jYWxOb3RpZnkgcGF0aCwgdlxuICAgICAgICByZW1vdGVOb3RpZnkgcGF0aCwgdiBpZiByZW1vdGVcblxuICAgIHJldHVybiB2XG5cbiAgY29uZGl0aW9uYWxTZXQgPSAocGF0aCwgdiwgcHJlZCktPlxuICAgIFtub2RlLCBrXSA9IGdldEF0IG1lbW9yeSwgcGF0aFxuICAgIGRvU2V0ID0gcHJlZCBub2RlW2tdLCB2XG4gICAgTWVtb3J5IHBhdGgsIHYgaWYgZG9TZXRcbiAgICByZXR1cm4gZG9TZXRcblxuICAjIFRoZXNlIGFyZSB1c2VmdWwgYmVjYXVzZSB0aGV5IHJldHVybiB0cnVlIGlmIGEgY2hhbmdlIHdhcyBtYWRlXG4gIE1lbW9yeS5jaGFuZ2UgPSAocGF0aCwgdiktPiBjb25kaXRpb25hbFNldCBwYXRoLCB2LCBGdW5jdGlvbi5ub3RFcXVpdmFsZW50XG4gIE1lbW9yeS5kZWZhdWx0ID0gKHBhdGgsIHYpLT4gY29uZGl0aW9uYWxTZXQgcGF0aCwgdiwgRnVuY3Rpb24ubm90RXhpc3RzXG5cbiAgIyBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGl0IHJlZHVjZXMgdGhlIG5lZWQgdG8gdXBkYXRlIE1lbW9yeSBpbiBhIGxvb3AsXG4gICMgd2hpY2ggdHJpZ2dlcnMgYSBsb3Qgb2YgKHBvc3NpYmx5IHBvaW50bGVzcykgbm90aWZpY2F0aW9ucy5cbiAgIyBSZW1pbmRlciB0aGF0IE9iamVjdC5tZXJnZSBkb2Vzbid0IGhhbmRsZSBhcnJheXMsIHNvIG1heWJlXG4gICMgbGltaXQgdGhlIHVzZSBvZiB0aGlzIGZ1bmN0aW9uIHRvIHByaW1pdGl2ZXMgKHNpbmNlIGl0IGltcGxpZXMgaW1tdXRhYmxlKS5cbiAgTWVtb3J5Lm1lcmdlID0gKHBhdGgsIHYpLT4gTWVtb3J5IHBhdGgsIChPYmplY3QubWVyZ2UgdiwgTWVtb3J5IHBhdGgpLCBpbW11dGFibGU6IHRydWVcblxuICAjIFRoZXNlIGFyZSB1c2VmdWwgYmVjYXVzZSBpdCBvZmZlcnMgYSBuaWNlIHN5bnRheCBmb3IgdXBkYXRpbmcgZXhpc3RpbmcgdmFsdWVzIGluIE1lbW9yeSxcbiAgIyB3aXRoIHN1cHBvcnQgZm9yIGFzeW5jLCBlaXRoZXIgbXV0YWJseSBvciBpbW11dGFibHkuXG4gIE1lbW9yeS51cGRhdGUgPSAocGF0aCwgZm4pLT4gTWVtb3J5IHBhdGgsIChhd2FpdCBmbiBNZW1vcnkgcGF0aCksIGltbXV0YWJsZTogdHJ1ZVxuICBNZW1vcnkubXV0YXRlID0gKHBhdGgsIGZuKS0+IE1lbW9yeSBwYXRoLCAoYXdhaXQgZm4gTWVtb3J5LmNsb25lIHBhdGgpLCBpbW11dGFibGU6IHRydWVcblxuICAjIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgcmVhZGluZyBzb21ldGhpbmcgZnJvbSBNZW1vcnkgdGhhdCBpcyBwcmUtY2xvbmVkXG4gICMgKGlmIG5lY2Vzc2FyeSkgdG8gYXZvaWQgbXV0YWJpbGl0eSBpc3N1ZXMuXG4gIE1lbW9yeS5jbG9uZSA9IChwYXRoKS0+IEZ1bmN0aW9uLmNsb25lIE1lbW9yeSBwYXRoXG5cblxuICBNZW1vcnkuc3Vic2NyaWJlID0gKC4uLltwYXRoID0gXCJcIiwgcnVuTm93ID0gdHJ1ZSwgd2VhayA9IGZhbHNlXSwgY2IpLT5cbiAgICB0aHJvdyBcIkludmFsaWQgc3Vic2NyaWJlIHBhdGhcIiB1bmxlc3MgU3RyaW5nLnR5cGUgcGF0aCAjIEF2b2lkIGVycm9ycyBpZiB5b3UgdHJ5IHNheSBzdWJzY3JpYmUocnVuTm93LCBjYilcbiAgICBbbm9kZSwga10gPSBnZXRBdCBzdWJzY3JpcHRpb25zLCBwYXRoXG4gICAgKChub2RlW2tdID89IHt9KS5fY2JzID89IFtdKS5wdXNoIGNiXG4gICAgY2IuX21lbW9yeV93ZWFrID0gd2VhayAjIC4uLiB0aGlzIGlzIGZpbmUg8J+QleKYle+4j/CflKVcbiAgICBjYiBNZW1vcnkgcGF0aCBpZiBydW5Ob3dcblxuICBNZW1vcnkudW5zdWJzY3JpYmUgPSAoLi4uW3BhdGggPSBcIlwiXSwgY2IpLT5cbiAgICBbbm9kZSwga10gPSBnZXRBdCBzdWJzY3JpcHRpb25zLCBwYXRoXG4gICAgdGhyb3cgRXJyb3IgXCJVbnN1YnNjcmliZSBmYWlsZWRcIiB1bmxlc3MgY2IgaW4gbm9kZVtrXS5fY2JzXG4gICAgQXJyYXkucHVsbCBub2RlW2tdLl9jYnMsIGNiXG4gICAgbnVsbFxuXG4gIGxvY2FsTm90aWZ5ID0gKHBhdGgsIHYpLT5cbiAgICBbbm9kZSwga10gPSBnZXRBdCBzdWJzY3JpcHRpb25zLCBwYXRoXG4gICAgIyBjb25zb2xlLmxvZyBcIiAgd2l0aGluOlwiXG4gICAgcnVuQ2JzV2l0aGluIG5vZGVba10sIHZcbiAgICAjIGNvbnNvbGUubG9nIFwiICBhdCBwYXRoOlwiXG4gICAgcnVuQ2JzIG5vZGVba10sIHYsIHZcbiAgICAjIGNvbnNvbGUubG9nIFwiICBhYm92ZTpcIlxuICAgIGNoYW5nZXMgPSBydW5DYnNBYm92ZSBwYXRoLCB2XG4gICAgIyBjb25zb2xlLmxvZyBcIiAgcm9vdDpcIlxuICAgIHJ1bkNicyBzdWJzY3JpcHRpb25zLCBtZW1vcnksIGNoYW5nZXNcblxuICBydW5DYnNXaXRoaW4gPSAocGFyZW50LCB2KS0+XG4gICAgcmV0dXJuIHVubGVzcyBPYmplY3QudHlwZSBwYXJlbnRcbiAgICBmb3IgaywgY2hpbGQgb2YgcGFyZW50IHdoZW4gayBpc250IFwiX2Nic1wiXG4gICAgICBfdiA9IHY/W2tdXG4gICAgICBydW5DYnNXaXRoaW4gY2hpbGQsIF92XG4gICAgICBydW5DYnMgY2hpbGQsIF92LCBfdlxuICAgIG51bGxcblxuICBydW5DYnNBYm92ZSA9IChwYXRoLCBjaGFuZ2VzKS0+XG4gICAgcGFydHMgPSBwYXRoLnNwbGl0IFwiLlwiXG4gICAgcCA9IHBhcnRzLnBvcCgpXG4gICAgY2hhbmdlc0Fib3ZlID0ge31cbiAgICBjaGFuZ2VzQWJvdmVbcF0gPSBjaGFuZ2VzXG4gICAgcmV0dXJuIGNoYW5nZXNBYm92ZSB1bmxlc3MgcGFydHMubGVuZ3RoID4gMFxuICAgIHBhdGhBYm92ZSA9IHBhcnRzLmpvaW4gXCIuXCJcbiAgICBbbm9kZSwga10gPSBnZXRBdCBzdWJzY3JpcHRpb25zLCBwYXRoQWJvdmVcbiAgICBydW5DYnMgbm9kZVtrXSwgTWVtb3J5KHBhdGhBYm92ZSksIGNoYW5nZXNBYm92ZVxuICAgIHJ1bkNic0Fib3ZlIHBhdGhBYm92ZSwgY2hhbmdlc0Fib3ZlXG5cbiAgcnVuQ2JzID0gKG5vZGUsIHYsIGNoYW5nZWQpLT5cbiAgICBpZiBub2RlPy5fY2JzXG4gICAgICBkZWFkID0gW11cbiAgICAgIGZvciBjYiBpbiBub2RlLl9jYnNcbiAgICAgICAgaWYgY2IuX21lbW9yeV93ZWFrIGFuZCBub3Qgdj9cbiAgICAgICAgICBkZWFkLnB1c2ggY2JcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNiIHYsIGNoYW5nZWRcbiAgICAgIEFycmF5LnB1bGwgbm9kZS5fY2JzLCBjYiBmb3IgY2IgaW4gZGVhZFxuICAgIG51bGxcblxuXG4gICMgVEVTVFNcbiAgaiA9ICh4KS0+IEpTT04uc3RyaW5naWZ5IHhcbiAgc3ViID0gKHApLT5cbiAgICBjb25zb2xlLmxvZyBwXG4gICAgTWVtb3J5LnN1YnNjcmliZSBwLCBmYWxzZSwgKHYsIGNoYW5nZWQpLT4gY29uc29sZS5sb2cgXCIgICAgXCIgKyBwLCBqKHYpLCBqIGNoYW5nZWRcbiAgICAjIE1lbW9yeS5zdWJzY3JpYmUgcCwgZmFsc2UsICh2LCBjaGFuZ2VkKS0+IGNvbnNvbGUubG9nIFwiICAgIHN0cm9uZyAgXCIgKyBwLCBqKHYpLCBqIGNoYW5nZWRcbiAgICAjIE1lbW9yeS5zdWJzY3JpYmUgcCwgZmFsc2UsIHRydWUsICh2LCBjaGFuZ2VkKS0+IGNvbnNvbGUubG9nIFwiICAgIHdlYWsgICAgXCIgKyBwLCBqKHYpLCBqIGNoYW5nZWRcbiAgc2V0ID0gKHAsIHYsIG1zZyktPlxuICAgIGNvbnNvbGUubG9nIFwiXFxuXFxuXCIrbXNnIGlmIG1zZz9cbiAgICBjb25zb2xlLmxvZyBcIlxcblNFVCAje3B9IHRvXCIsIGoodilcbiAgICBNZW1vcnkgcCwgdlxuXG4gICMgTm90ZTogY2hhbmdlZCBvbmx5IGV4aXN0cyB3aGVuIHdlJ3ZlIG1vZGlmaWVkIGEgc3VicGF0aCByYXRoZXIgdGhhbiB0aGUgcGF0aCBzcGVjaWZpZWQgYnkgdGhlIGxpc3RlbmVyXG5cbiAgIyBjb25zb2xlLmxvZyBcIlNVQlNDUklCRVJTXCJcbiAgIyBzdWIgXCJhc3NldHMuQS5pZFwiXG4gICMgc3ViIFwiYXNzZXRzLkEuZmlsZXNcIlxuICAjIHN1YiBcImFzc2V0cy5BXCJcbiAgIyBzdWIgXCJhc3NldHMuQlwiXG4gICMgc3ViIFwiYXNzZXRzXCJcbiAgIyBzdWIgXCJzcXVpYnMgLSBzaG91bGQgbmV2ZXIgc2VlIHRoaXMgcnVuXCJcbiAgIyBzdWIgXCJcIlxuXG4gICMgc2V0IFwiYXNzZXRzLkFcIiwge2lkOjAsIHg6IDB9LCBcImNyZWF0ZSBhbiBvYmpcIlxuICAjIHNldCBcImFzc2V0cy5BLnlcIiwgMCwgXCJjcmVhdGUgYSBwcmltaXRpdmVcIlxuICAjIHNldCBcImFzc2V0cy5BLmlkXCIsIDEsIFwiY2hhbmdlIGEgcHJpbWl0aXZlXCJcbiAgIyAjIHNldCBcImFzc2V0cy5BLngud2F0XCIsIDAsIFwiZHJpbGwgaW50byBhIHByaW1pdGl2ZSE/XCIg4oCUIGVycm9yXG4gICMgc2V0IFwiYXNzZXRzLkEuaWRcIiwge2luOjB9LCBcInJlcGxhY2UgYSBwcmltaXRpdmUgd2l0aCBhbiBvYmpcIlxuICAjIHNldCBcImFzc2V0cy5BLmlkXCIsIG51bGwsIFwiZGVsZXRlIGFuIG9ialwiXG4gICMgc2V0IFwiYXNzZXRzLkJcIiwge2lkOjl9LCBcImNyZWF0ZSBhbm90aGVyIG9ialwiXG4gICMgc2V0IFwiZm9ya1wiLCB7fSwgXCJjcmVhdGUsIG5vIHN1YnNjcmliZXJzXCJcbiAgIyBzZXQgXCJhc3NldHNcIiwgbnVsbCwgXCJkZWxldGUgYW4gb2JqIHdpdGggbWFueSBzdWJzXCJcbiAgIyAjIHNldCBcIlwiLCAzLCBcInNldCByb290IOKAlCBzaG91bGQgZXJyb3JcIlxuXG5cbiMgY29tbW9uL29uLXNjcmVlbi5jb2ZmZWVcblRha2UgW10sICgpLT5cbiAgZWxtcyA9IG5ldyBXZWFrTWFwKClcblxuICBvYnNlcnZlckZuID0gKGVudHJpZXMpLT5cbiAgICBmb3IgZW50cnkgaW4gZW50cmllc1xuICAgICAgaWYgY2IgPSBlbG1zLmdldCBlbnRyeS50YXJnZXRcbiAgICAgICAgY2IgZW50cnkudGFyZ2V0LCBlbnRyeS5pc0ludGVyc2VjdGluZ1xuXG4gIG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyIG9ic2VydmVyRm4sXG4gICAgcm9vdDogZG9jdW1lbnQucXVlcnlTZWxlY3RvciBcIltvbi1zY3JlZW4tY29udGFpbmVyXVwiXG4gICAgcm9vdE1hcmdpbjogXCIxMDAwcHhcIiAjIFN0YXJ0IGxvYWRpbmcgaW1hZ2VzIGEgbGl0dGxlIGJlZm9yZSB0aGV5IHNjcm9sbCBpbnRvIHZpZXdcblxuICBNYWtlLmFzeW5jIFwiT25TY3JlZW5cIiwgT25TY3JlZW4gPSAoZWxtLCBjYiktPlxuICAgIHRocm93IEVycm9yIFwiT3ZlcndyaXRpbmcgZXhpc3RpbmcgT25TY3JlZW5cIiBpZiBlbG1zLmhhcyBlbG1cbiAgICBlbG1zLnNldCBlbG0sIGNiXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSBlbG1cblxuICBPblNjcmVlbi5vZmYgPSAoZWxtKS0+XG4gICAgZWxtcy5kZWxldGUgZWxtXG5cblxuIyBjb21tb24vcmFpbmJvdy1iZWZvcmUuY29mZmVlXG5UYWtlIFtcIkFEU1JcIiwgXCJSYWluYm93XCIsIFwiRE9NQ29udGVudExvYWRlZFwiXSwgKEFEU1IsIFJhaW5ib3cpLT5cblxuICBzY3JvbGwgPSBBRFNSIDEsIDEsICgpLT5cbiAgICBSYWluYm93Lm1vdmUgMC41XG5cbiAgc2Nyb2xsKClcblxuICBmb3Igc2Nyb2xsYWJsZSBpbiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsIFwiLnNjcm9sbGFibGVcIlxuICAgIHNjcm9sbGFibGUuYWRkRXZlbnRMaXN0ZW5lciBcIndoZWVsXCIsIHNjcm9sbCwgcGFzc2l2ZTogdHJ1ZVxuXG5cbiMgY29tbW9uL3JhaW5ib3ctY29sb3JzLmNvZmZlZVxuZG8gKCktPlxuXG4gIGNvbG9ycyA9IFtcbiAgICBcImhzbCgyMCwgMTAwJSwgNTAlKVwiXG4gICAgXCJoc2woMTcwLCAxMDAlLCA1MCUpXCJcbiAgICBcImhzbCgyNTAsIDEwMCUsIDUwJSlcIlxuICBdXG5cbiAgY29sb3JzID0gQXJyYXkuc2h1ZmZsZSBjb2xvcnNcbiAgZG9jdW1lbnQuYm9keS5zdHlsZS5zZXRQcm9wZXJ0eSBcIi0tcmFpbmJvdy1hXCIsIGNvbG9yc1swXVxuICBkb2N1bWVudC5ib2R5LnN0eWxlLnNldFByb3BlcnR5IFwiLS1yYWluYm93LWJcIiwgY29sb3JzWzFdXG4gIGRvY3VtZW50LmJvZHkuc3R5bGUuc2V0UHJvcGVydHkgXCItLXJhaW5ib3ctY1wiLCBjb2xvcnNbMl1cblxuXG4jIGNvbW1vbi9yYWluYm93LmNvZmZlZVxuVGFrZSBbXCJTdGF0ZVwiXSwgKFN0YXRlKS0+XG5cbiAgU3RhdGUgXCJyYWluYm93LWJlZm9yZS1kZWxheVwiLCBNYXRoLnJhbmRJbnQgMCwgLTEwMDBcblxuICBNYWtlIFwiUmFpbmJvd1wiLCBSYWluYm93ID1cbiAgICBtb3ZlOiAoZGVsdGEpLT5cbiAgICAgIGRlbGF5ID0gU3RhdGUoXCJyYWluYm93LWJlZm9yZS1kZWxheVwiKSAtIGRlbHRhXG4gICAgICBTdGF0ZSBcInJhaW5ib3ctYmVmb3JlLWRlbGF5XCIsIGRlbGF5XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnNldFByb3BlcnR5IFwiLS1yYWluYm93LWJlZm9yZS1kZWxheVwiLCBcIiN7ZGVsYXl9bXNcIlxuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5zZXRQcm9wZXJ0eSBcIi0tcmFpbmJvdy1mb2N1c1wiLCBkMy5sY2ggIDcwLCAzMCwgLWRlbGF5LzJcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciBcImtleWRvd25cIiwgKCktPlxuICAgIFJhaW5ib3cubW92ZSA0XG5cblxuIyBjb21tb24vc2VhcmNoLWJveC5jb2ZmZWVcblRha2UgW1wiQURTUlwiLCBcIlB1YlN1YlwiLCBcIlN0YXRlXCIsIFwiRE9NQ29udGVudExvYWRlZFwiXSwgKEFEU1IsIHtQdWIsIFN1Yn0sIFN0YXRlKS0+XG5cbiAgZWxtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciBcInNlYXJjaC1ib3ggaW5wdXRcIlxuICByZXR1cm4gdW5sZXNzIGVsbT9cblxuICBmb2N1c2VkID0gZmFsc2VcblxuICBjaGFuZ2UgPSBBRFNSIDEsIDEsIChlKS0+IFN0YXRlIFwic2VhcmNoXCIsIGVsbS52YWx1ZVxuXG4gIFN0YXRlLnN1YnNjcmliZSBcInNlYXJjaFwiLCBmYWxzZSwgKHYpLT5cbiAgICBlbG0udmFsdWUgPSB2IHVubGVzcyBmb2N1c2VkXG5cbiAgZWxtLmFkZEV2ZW50TGlzdGVuZXIgXCJjaGFuZ2VcIiwgY2hhbmdlXG4gIGVsbS5hZGRFdmVudExpc3RlbmVyIFwiaW5wdXRcIiwgY2hhbmdlXG4gIGVsbS5vbmZvY3VzID0gKCktPiBmb2N1c2VkID0gdHJ1ZVxuICBlbG0ub25ibHVyID0gKCktPiBmb2N1c2VkID0gZmFsc2VcblxuICBTdWIgXCJmaW5kXCIsICgpLT4gZWxtLmZvY3VzKClcblxuXG4jIGNvbW1vbi9zdWJzY3JpcHRpb25zL3NlYXJjaC1yZW5kZXIuY29mZmVlXG5UYWtlIFtcIlB1YlN1YlwiLCBcIlN0YXRlXCJdLCAoe1B1Yn0sIFN0YXRlKS0+XG5cbiAgU3RhdGUuc3Vic2NyaWJlIFwic2VhcmNoXCIsIGZhbHNlLCAoKS0+XG4gICAgUHViIFwiUmVuZGVyXCJcblxuXG4jIGNvbW1vbi90YWctbGlzdC5jb2ZmZWVcblRha2UgW1wiTWVtb3J5XCJdLCAoTWVtb3J5KS0+XG5cbiAgTWFrZS5hc3luYyBcIlRhZ0xpc3RcIiwgVGFnTGlzdCA9IChhc3NldCwgb3B0cyA9IHt9KS0+XG4gICAgc3BlY2lhbFRhZ3MgPSBNZW1vcnkgXCJzcGVjaWFsVGFnc1wiXG4gICAgc29ydGVkVGFncyA9IEFycmF5LnNvcnRBbHBoYWJldGljIGFzc2V0LnRhZ3NcblxuICAgICMgTWFrZSBhbGwgdGhlIHNwZWNpYWwgdGFncyBmaXJzdCwgc28gdGhleSBjb21lIGF0IHRoZSBzdGFydCBvZiB0aGUgbGlzdFxuICAgIGZyYWcgPSBuZXcgRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgZnJhZy5hcHBlbmQgbWFrZVRhZyB0YWcsIG9wdHMsIHRydWUgIGZvciB0YWcgaW4gc29ydGVkVGFncyB3aGVuIHNwZWNpYWxUYWdzW3RhZ10/XG4gICAgZnJhZy5hcHBlbmQgbWFrZVRhZyB0YWcsIG9wdHMsIGZhbHNlIGZvciB0YWcgaW4gc29ydGVkVGFncyB3aGVuIG5vdCBzcGVjaWFsVGFnc1t0YWddP1xuICAgIHJldHVybiBmcmFnXG5cbiAgbWFrZVRhZyA9ICh0YWcsIG9wdHMsIHNwZWNpYWwpLT5cbiAgICBlbG0gPSBET09NLmNyZWF0ZSBcInRhZy1pdGVtXCIsIG51bGwsIHRleHRDb250ZW50OiB0YWdcbiAgICBpZiBzcGVjaWFsIHRoZW4gRE9PTSBlbG0sIHNwZWNpYWw6IFwiXCJcblxuICAgIGlmIG9wdHMuY2xpY2s/XG4gICAgICBET09NIGVsbSwgY2xpY2s6IChlKS0+XG4gICAgICAgIG9wdHMuY2xpY2sgdGFnLCBlbG0gdW5sZXNzIE1lbW9yeSBcIlJlYWQgT25seVwiXG5cbiAgICBpZiBvcHRzLnJlbW92ZUZuP1xuICAgICAgRE9PTS5jcmVhdGUgXCJzcGFuXCIsIGVsbSwgdGV4dENvbnRlbnQ6IFwieFwiLCBjbGFzczogXCJyZW1vdmVcIiwgY2xpY2s6IChlKS0+XG4gICAgICAgIG9wdHMucmVtb3ZlRm4gdGFnIHVubGVzcyBNZW1vcnkgXCJSZWFkIE9ubHlcIlxuXG4gICAgZWxtXG5cblxuIyBjb21tb24vdmFsaWRhdGlvbnMuY29mZmVlXG5UYWtlIFtdLCAoKS0+XG5cbiAgTWFrZSBcIlZhbGlkYXRpb25zXCIsIFZhbGlkYXRpb25zID1cbiAgICBhc3NldDpcbiAgICAgIG5hbWU6ICh2KS0+IC0xIGlzIHYuc2VhcmNoIC9bLjovXFxcXF0vXG4gICAgZmlsZTogKHYpLT4gLTEgaXMgdi5zZWFyY2ggL1s6L1xcXFxdL1xuXG5cbiMgY29tbW9uL3dpbmRvdy1ldmVudHMuY29mZmVlXG5UYWtlIFtcIklQQ1wiXSwgKElQQyktPlxuICBJUEMub24gXCJmb2N1c1wiLCAoKS0+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlIFwiYmx1clwiXG4gIElQQy5vbiBcImJsdXJcIiwgKCktPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCBcImJsdXJcIlxuICBJUEMub24gXCJtYXhpbWl6ZVwiLCAoKS0+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkIFwibWF4aW1pemVcIlxuICBJUEMub24gXCJ1bm1heGltaXplXCIsICgpLT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUgXCJtYXhpbWl6ZVwiXG5cblxuIyBjb21tb24vd2luZG93cy1tZW51LmNvZmZlZVxuVGFrZSBbXCJJUENcIiwgXCJMb2dcIiwgXCJET01Db250ZW50TG9hZGVkXCJdLCAoSVBDLCBMb2cpLT5cblxuICBtaW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yIFwid2luZG93cy1tZW51ICNtaW5cIlxuICBtYXggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yIFwid2luZG93cy1tZW51ICNtYXhcIlxuICByZXN0b3JlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciBcIndpbmRvd3MtbWVudSAjcmVzdG9yZVwiXG4gIGNsb3NlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciBcIndpbmRvd3MtbWVudSAjY2xvc2VcIlxuICByZXR1cm4gdW5sZXNzIG1pbiBhbmQgbWF4IGFuZCByZXN0b3JlIGFuZCBjbG9zZVxuXG4gIG1pbi5hZGRFdmVudExpc3RlbmVyIFwiY2xpY2tcIiwgKGUpLT5cbiAgICBJUEMuc2VuZCBcIm1pbmltaXplLXdpbmRvd1wiXG5cbiAgbWF4LmFkZEV2ZW50TGlzdGVuZXIgXCJjbGlja1wiLCAoZSktPlxuICAgIElQQy5zZW5kIFwibWF4aW1pemUtd2luZG93XCJcblxuICByZXN0b3JlLmFkZEV2ZW50TGlzdGVuZXIgXCJjbGlja1wiLCAoZSktPlxuICAgIElQQy5zZW5kIFwidW5tYXhpbWl6ZS13aW5kb3dcIlxuXG4gIGNsb3NlLmFkZEV2ZW50TGlzdGVuZXIgXCJjbGlja1wiLCAoZSktPlxuICAgIElQQy5zZW5kIFwiY2xvc2Utd2luZG93XCJcbiJdfQ==
//# sourceURL=/Users/admin/Work/hyperzine/temp/common.coffee