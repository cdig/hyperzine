// Generated by CoffeeScript 2.5.1
// node_modules/take-and-make/source/take-and-make.coffee
// Since this is typically the first bit of code included in our big compiled and
// concatenated JS files, this is a great place to demand strictness. CoffeeScript
// does not add strict on its own, but it will permit and enforce it.
"use strict";
var DebugTakeMake, Make, Take, Test, Tests,
  splice = [].splice,
  indexOf = [].indexOf;

if (!((typeof Take !== "undefined" && Take !== null) || (typeof Make !== "undefined" && Make !== null))) {
  // We declare our globals such that they're visible everywhere within the current scope.
  // This allows for namespacing â€” all things within a given scope share a copy of Take & Make.
  Take = null;
  Make = null;
  DebugTakeMake = null;
  (function() {
    var addListener, allNeedsAreMet, alreadyChecking, alreadyWaitingToNotify, asynchronousResolve, checkWaitingTakers, clone, made, microtasksNeeded, microtasksUsed, notify, notifyTakers, register, resolve, synchronousResolve, takersToNotify, waitingTakers;
    made = {};
    waitingTakers = [];
    takersToNotify = [];
    alreadyWaitingToNotify = false;
    alreadyChecking = false;
    microtasksNeeded = 0;
    microtasksUsed = 0;
    Make = function(name, value = name) {
      if (name == null) {
        // Debug â€” call Make() in the console to see what we've regstered
        return clone(made);
      }
      // Synchronous register, returns value
      return register(name, value);
    };
    Take = function(needs, callback) {
      if (needs == null) {
        // Debug â€” call Take() in the console to see what we're waiting for
        return waitingTakers.slice();
      }
      // Synchronous and asynchronous resolve, returns value or object of values
      return resolve(needs, callback);
    };
    // A variation of Make that defers committing the value
    Make.async = function(name, value = name) {
      return queueMicrotask(function() {
        return Make(name, value);
      });
    };
    // A variation of Take that returns a promise
    Take.async = function(needs) {
      return new Promise(function(res) {
        return Take(needs, function() {
          // Resolve the promise with a value or object of values
          return res(synchronousResolve(needs));
        });
      });
    };
    DebugTakeMake = function() {
      var base, j, l, len1, len2, need, output, ref, waiting;
      output = {
        microtasksNeeded: microtasksNeeded,
        microtasksUsed: microtasksUsed,
        unresolved: {}
      };
      for (j = 0, len1 = waitingTakers.length; j < len1; j++) {
        waiting = waitingTakers[j];
        ref = waiting.needs;
        for (l = 0, len2 = ref.length; l < len2; l++) {
          need = ref[l];
          if (made[need] == null) {
            if ((base = output.unresolved)[need] == null) {
              base[need] = 0;
            }
            output.unresolved[need]++;
          }
        }
      }
      return output;
    };
    register = function(name, value) {
      if (name === "") {
        throw new Error("You may not Make(\"\") an empty string.");
      }
      if (made[name] != null) {
        throw new Error(`You may not Make() the same name twice: ${name}`);
      }
      made[name] = value;
      checkWaitingTakers();
      return value;
    };
    checkWaitingTakers = function() {
      var index, j, len1, taker;
      if (alreadyChecking) { // Prevent recursion from Make() calls inside notify()
        return;
      }
      alreadyChecking = true;
// Depends on `waitingTakers`
// Comments below are to help reason through the (potentially) recursive behaviour
      for (index = j = 0, len1 = waitingTakers.length; j < len1; index = ++j) {
        taker = waitingTakers[index];
        if (allNeedsAreMet(taker.needs)) { // Depends on `made`
          waitingTakers.splice(index, 1); // Mutates `waitingTakers`
          notify(taker); // Calls to Make() or Take() will mutate `made` or `waitingTakers`
          alreadyChecking = false;
          return checkWaitingTakers(); // Restart: `waitingTakers` (and possibly `made`) were mutated
        }
      }
      return alreadyChecking = false;
    };
    allNeedsAreMet = function(needs) {
      return needs.every(function(name) {
        return made[name] != null;
      });
    };
    resolve = function(needs, callback) {
      if (callback != null) {
        // We always try to resolve both synchronously and asynchronously
        asynchronousResolve(needs, callback);
      }
      return synchronousResolve(needs);
    };
    asynchronousResolve = function(needs, callback) {
      var taker;
      if (needs === "") {
        needs = [];
      } else if (typeof needs === "string") {
        needs = [needs];
      }
      taker = {
        needs: needs,
        callback: callback
      };
      if (allNeedsAreMet(needs)) {
        takersToNotify.push(taker);
        microtasksNeeded++;
        if (!alreadyWaitingToNotify) {
          alreadyWaitingToNotify = true;
          queueMicrotask(notifyTakers); // Preserve asynchrony
          return microtasksUsed++;
        }
      } else {
        return waitingTakers.push(taker);
      }
    };
    synchronousResolve = function(needs) {
      var j, len1, n, o;
      if (typeof needs === "string") {
        return made[needs];
      } else {
        o = {};
        for (j = 0, len1 = needs.length; j < len1; j++) {
          n = needs[j];
          o[n] = made[n];
        }
        return o;
      }
    };
    notifyTakers = function() {
      var j, len1, taker, takers;
      alreadyWaitingToNotify = false;
      takers = takersToNotify;
      takersToNotify = [];
      for (j = 0, len1 = takers.length; j < len1; j++) {
        taker = takers[j];
        notify(taker);
      }
      return null;
    };
    notify = function(taker) {
      var resolvedNeeds;
      resolvedNeeds = taker.needs.map(function(name) {
        return made[name];
      });
      return taker.callback.apply(null, resolvedNeeds);
    };
    // IE11 doesn't support Object.assign({}, obj), so we just use our own
    clone = function(obj) {
      var k, out, v;
      out = {};
      for (k in obj) {
        v = obj[k];
        out[k] = v;
      }
      return out;
    };
    // We want to add a few handy one-time events.
    // However, we don't know if we'll be running in a browser, or in node.
    // Thus, we look for the presence of a "window" object as our clue.
    if (typeof window !== "undefined" && window !== null) {
      addListener = function(eventName) {
        var handler;
        return window.addEventListener(eventName, handler = function(eventObject) {
          window.removeEventListener(eventName, handler);
          Make(eventName, eventObject);
          return void 0; // prevent unload from opening a popup
        });
      };
      addListener("beforeunload");
      addListener("click");
      addListener("unload");
      // Since we have a window object, it's probably safe to assume we have a document object
      switch (document.readyState) {
        case "loading":
          addListener("DOMContentLoaded");
          addListener("load");
          break;
        case "interactive":
          Make("DOMContentLoaded");
          addListener("load");
          break;
        case "complete":
          Make("DOMContentLoaded");
          Make("load");
          break;
        default:
          throw new Error(`Unknown document.readyState: ${document.readyState}. Cannot setup Take&Make.`);
      }
    }
    // Finally, we're ready to hand over control to module systems
    if (typeof module !== "undefined" && module !== null) {
      return module.exports = {
        Take: Take,
        Make: Make,
        DebugTakeMake: DebugTakeMake
      };
    }
  })();
}

// submodule/bucket/adsr.coffee
// ADSR
// This gives your function an "attack" phase and a "release" phase
// (borrowing terminology from ADSR on synthesizers).
// The attack phase is a debounce â€” your function will run just once after the attack phase ends,
// no matter how many times it's called until then.
// When the function runs, it'll use the args from the most recent time it was called.
// The release is a throttle â€” if your function is called during the release phase,
// then after the release phase ends the attack phase will start over again.
// This is useful if you want a function that will run shortly after it's called (good for fast reactions)
// but doesn't run again until a while later (good for reducing strain).
// Attack and release are specified in ms, and are optional.
// If you pass a time of 0 ms for either the attack, release, or both, the phase will last until the next microtask.
// If you pass a time less than 5 ms, the phase will last until the next animation frame.
// It's idiomatic to pass a time of 1 ms if you want the next frame.
// We also keep a count of how many functions are currently waiting, and support adding watchers
// that will run a callback when the count changes, just in case you want to (for example)
// wait for them all to finish before quitting / closing, or monitor their performance.
Take([], function() {
  var ADSR, active, afterAttack, afterDelay, afterRelease, updateWatchers, watchers;
  active = new Map();
  watchers = [];
  Make.async("ADSR", ADSR = function(...arg1) {
    var attack, fn, ref, release;
    ref = arg1, [...arg1] = ref, [fn] = splice.call(arg1, -1);
    [attack = 0, release = 0] = arg1;
    return function(...args) {
      if (!active.has(fn)) {
        afterDelay(attack, afterAttack(fn, attack, release));
        ADSR.count++;
        updateWatchers();
      }
      return active.set(fn, {args}); // Always use the most recent args
    };
  });
  ADSR.count = 0;
  ADSR.watcher = function(watcher) {
    return watchers.push(watcher);
  };
  afterAttack = function(fn, attack, release) {
    return function() {
      var args;
      ({args} = active.get(fn));
      active.set(fn, {});
      fn(...args);
      return afterDelay(release, afterRelease(fn, attack, release));
    };
  };
  afterRelease = function(fn, attack, release) {
    return function() {
      var args;
      ({args} = active.get(fn));
      if (args) {
        return afterDelay(attack, afterAttack(fn, attack, release));
      } else {
        active.delete(fn);
        ADSR.count--;
        return updateWatchers();
      }
    };
  };
  afterDelay = function(delay = 0, cb) {
    if (delay === 0) {
      return queueMicrotask(cb);
    } else if (delay < 5) {
      return requestAnimationFrame(cb);
    } else {
      return setTimeout(cb, delay);
    }
  };
  return updateWatchers = function() {
    var j, len1, watcher;
    for (j = 0, len1 = watchers.length; j < len1; j++) {
      watcher = watchers[j];
      watcher(ADSR.count);
    }
    return null;
  };
});

// submodule/bucket/monkey-patch.coffee
// Monkey Patch
// The JS standard library leaves a lot to be desired, so let's carefully (see bottom of file)
// modify the built-in classes to add a few helpful methods.
(function() {
  var className, classPatches, globalclass, key, monkeyPatches, results, value;
  monkeyPatches = {
    Array: {
      type: function(v) {
        return v instanceof Array;
      },
      // Sorting
      numericSortAscending: function(a, b) {
        return a - b;
      },
      numericSortDescending: function(a, b) {
        return b - a;
      },
      sortAlphabetic: function(arr) {
        return arr.sort(Array.alphabeticSort != null ? Array.alphabeticSort : Array.alphabeticSort = new Intl.Collator('en').compare);
      },
      sortNumericAscending: function(arr) {
        return arr.sort(Array.numericSortAscending);
      },
      sortNumericDescending: function(arr) {
        return arr.sort(Array.numericSortDescending);
      },
      // Accessing
      first: function(arr) {
        return arr[0];
      },
      second: function(arr) {
        return arr[1];
      },
      last: function(arr) {
        return arr[arr.length - 1];
      },
      rest: function(arr) {
        return arr.slice(1);
      },
      butLast: function(arr) {
        return arr.slice(0, -1);
      },
      // Misc
      clone: function(arr) {
        return arr.map(Function.clone);
      },
      empty: function(arr) {
        return (arr == null) || arr.length === 0;
      },
      equal: function(a, b) {
        var ai, bi, i, j, len1;
        if (Object.is(a, b)) {
          return true;
        }
        if (!(Array.type(a) && Array.type(b) && a.length === b.length)) {
          return false;
        }
        for (i = j = 0, len1 = a.length; j < len1; i = ++j) {
          ai = a[i];
          bi = b[i];
          if (Function.equal(ai, bi)) {
            continue;
          } else {
            return false;
          }
        }
        return true;
      },
      mapToObject: function(arr, fn = Function.identity) {
        var j, k, len1, o;
        o = {};
        for (j = 0, len1 = arr.length; j < len1; j++) {
          k = arr[j];
          o[k] = fn(k);
        }
        return o;
      },
      pull: function(arr, elms) {
        var elm, i, j, len1;
        if (!((arr != null) && (elms != null))) {
          return;
        }
        if (!Array.type(elms)) {
          elms = [elms];
        }
        for (j = 0, len1 = elms.length; j < len1; j++) {
          elm = elms[j];
          while ((i = arr.indexOf(elm)) > -1) {
            arr.splice(i, 1);
          }
        }
        return arr;
      },
      search: function(arr, key) {
        var j, len1, v;
        for (j = 0, len1 = arr.length; j < len1; j++) {
          v = arr[j];
          if (Array.type(v)) {
            if (Array.search(v, key)) {
              return true;
            }
          } else if (Object.type(v)) {
            if (Object.search(v, key)) {
              return true;
            }
          }
        }
        return false;
      },
      shuffle: function(arr) {
        var i, item, j, len1, newArr;
        newArr = [];
        for (i = j = 0, len1 = arr.length; j < len1; i = ++j) {
          item = arr[i];
          newArr.splice(Math.randInt(0, newArr.length), 0, item);
        }
        return newArr;
      },
      unique: function(elements) {
        return Array.from(new Set([].concat(elements)));
      }
    },
    Function: {
      type: function(v) {
        return v instanceof Function;
      },
      identity: function(v) {
        return v;
      },
      exists: function(e) {
        return e != null;
      },
      notExists: function(e) {
        return e == null;
      },
      is: function(a, b) {
        return a === b;
      },
      isnt: function(a, b) {
        return a !== b;
      },
      equal: function(a, b) {
        if (Object.is(a, b)) {
          return true;
        } else if (Array.type(a) && Array.type(b)) {
          if (Array.equal(a, b)) {
            return true;
          }
        } else if (Object.type(a) && Object.type(b)) {
          if (Object.equal(a, b)) {
            return true;
          }
        } else {
          return false;
        }
      },
      equivalent: function(a, b) {
        return a == b || Function.equal(a, b); // Like equal, but also equates null & undefined, -0 & 0, etc
      },
      notEqual: function(a, b) {
        return !Function.equal(a, b);
      },
      notEquivalent: function(a, b) {
        return !Function.equivalent(a, b);
      },
      clone: function(v) {
        if (v == null) {
          return v;
        } else if (Function.type(v)) {
          throw new Error("If you need to clone functions, use a custom cloner");
        } else if (Promise.type(v)) {
          throw new Error("If you need to clone promises, use a custom cloner");
        } else if (Array.type(v)) {
          return Array.clone(v);
        } else if (Object.type(v)) {
          return Object.clone(v);
        } else {
          return v;
        }
      }
    },
    Math: {
      TAU: Math.PI * 2,
      zero: function(v) {
        return Math.EPSILON > Math.abs(v);
      },
      nonzero: function(v) {
        return !Math.zero(v);
      },
      add: function(a, b) {
        return a + b;
      },
      div: function(a, b) {
        return a / b;
      },
      mod: function(a, b) {
        return a % b;
      },
      mul: function(a, b) {
        return a * b;
      },
      sub: function(a, b) {
        return a - b;
      },
      avg: function(a, b) {
        return (a + b) / 2;
      },
      clip: function(v, ...arg1) {
        var max, min, ref;
        ref = arg1, [...arg1] = ref, [max] = splice.call(arg1, -1);
        [min = 0] = arg1;
        if (max === void 0) {
          max = 1;
        }
        return Math.min(max, Math.max(min, v));
      },
      sat: function(v) {
        return Math.clip(v);
      },
      lerpN: function(input, outputMin = 0, outputMax = 1, clip = false) {
        input *= outputMax - outputMin;
        input += outputMin;
        if (clip) {
          input = Math.clip(input, outputMin, outputMax);
        }
        return input;
      },
      lerp: function(input, inputMin = 0, inputMax = 1, outputMin = 0, outputMax = 1, clip = true) {
        if (inputMin === inputMax) { // Avoids a divide by zero
          return outputMin;
        }
        if (inputMin > inputMax) {
          [inputMin, inputMax, outputMin, outputMax] = [inputMax, inputMin, outputMax, outputMin];
        }
        if (clip) {
          input = Math.clip(input, inputMin, inputMax);
        }
        input -= inputMin;
        input /= inputMax - inputMin;
        return Math.lerpN(input, outputMin, outputMax, false);
      },
      rand: function(min = -1, max = 1) {
        return Math.lerpN(Math.random(), min, max);
      },
      randInt: function(min, max) {
        return Math.round(Math.rand(min, max));
      },
      roundTo: function(input, precision) {
        var p;
        // Using the reciprocal avoids floating point errors. Eg: 3/10 is fine, but 3*0.1 is wrong.
        p = 1 / precision;
        return Math.round(input * p) / p;
      }
    },
    Object: {
      type: function(v) {
        return "[object Object]" === Object.prototype.toString.call(v);
      },
      // This should probably be a function on Array, as a mirror of Object.keys / Object.values.
      // In general, functions that take an array go on Array, even if they return a different type.
      by: function(k, arr) { // Object.by "name", [{name:"a"}, {name:"b"}] => {a:{name:"a"}, b:{name:"b"}}
        var j, len1, o, obj;
        o = {};
        for (j = 0, len1 = arr.length; j < len1; j++) {
          obj = arr[j];
          o[obj[k]] = obj;
        }
        return o;
      },
      clone: function(obj) {
        return Object.mapValues(obj, Function.clone);
      },
      count: function(obj) {
        return Object.keys(obj).length;
      },
      equal: function(a, b) {
        var av, bv, k, ref;
        if (Object.is(a, b)) {
          return true;
        }
        if (!(((a != null) && (b != null)) && (({}.constructor === (ref = a.constructor) && ref === b.constructor)))) {
          return false;
        }
        if (Object.keys(a).length !== Object.keys(b).length) {
          return false;
        }
        for (k in a) {
          av = a[k];
          bv = b[k];
          if (Function.equal(av, bv)) {
            continue;
          } else {
            return false;
          }
        }
        return true;
      },
      mapKeys: function(obj, fn = Function.identity) {
        var k, o;
        o = {};
        for (k in obj) {
          o[k] = fn(k);
        }
        return o;
      },
      mapValues: function(obj, fn = Function.identity) {
        var k, o, v;
        o = {};
        for (k in obj) {
          v = obj[k];
          o[k] = fn(v);
        }
        return o;
      },
      merge: function(...objs) {
        var j, k, len1, obj, out, v;
        out = {};
        for (j = 0, len1 = objs.length; j < len1; j++) {
          obj = objs[j];
          if (obj != null) {
            for (k in obj) {
              v = obj[k];
              // DO NOT add any additional logic for merging other types (like arrays),
              // or existing apps will break (Hyperzine, Hest, etc.)
              // If you want to deep merge other types, write a custom merge function.
              out[k] = Object.type(v) ? Object.merge(out[k], v) : v;
            }
          }
        }
        return out;
      },
      rmerge: function(...objs) {
        return Object.merge(...objs.reverse());
      },
      search: function(obj, key) {
        var k, v;
        if (obj[key] != null) {
          return true;
        }
        for (k in obj) {
          v = obj[k];
          if (Array.type(v)) {
            if (Array.search(v, key)) {
              return true;
            }
          } else if (Object.type(v)) {
            if (Object.search(v, key)) {
              return true;
            }
          }
        }
        return false;
      },
      subtractKeys: function(a, b) {
        var k, o;
        o = Object.mapKeys(a); // shallow clone
        for (k in b) {
          delete o[k];
        }
        return o;
      }
    },
    Promise: {
      type: function(v) {
        return v instanceof Promise;
      },
      timeout: function(t) {
        return new Promise(function(resolve) {
          return setTimeout(resolve, t);
        });
      }
    },
    String: {
      type: function(v) {
        return "string" === typeof v;
      },
      // https://stackoverflow.com/a/52171480/313576, public domain
      hash: function(str, seed = 0) {
        var c, ch, h1, h2, j, len1;
        if (str == null) {
          return 0;
        }
        h1 = 0xdeadbeef ^ seed;
        h2 = 0x41c6ce57 ^ seed;
        for (j = 0, len1 = str.length; j < len1; j++) {
          c = str[j];
          ch = c.charCodeAt(0);
          h1 = Math.imul(h1 ^ ch, 2654435761);
          h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
        h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
        return 4294967296 * (2097151 & h2) + (h1 >>> 0);
      },
      pluralize: function(count, string, suffix = "s") {
        if (count === 1) {
          suffix = "";
        }
        return (string + suffix).replace("%%", count);
      },
      toKebabCase: function(v) {
        return v.replace(/([A-Z])/g, "-$1").toLowerCase();
      }
    }
  };
// Init
  results = [];
  for (className in monkeyPatches) {
    classPatches = monkeyPatches[className];
    globalclass = globalThis[className];
    results.push((function() {
      var results1;
      results1 = [];
      for (key in classPatches) {
        value = classPatches[key];
        if (globalclass[key] != null) {
          results1.push(console.log(`Can't monkey patch ${className}.${key} because it already exists.`));
        } else {
          results1.push(globalclass[key] = value);
        }
      }
      return results1;
    })());
  }
  return results;
})();

// submodule/bucket/test.coffee
Tests = Test = null;

(function() {
  var context;
  context = null;
  Tests = function(name, test) {
    context = function() {
      console.group(`%c${name}`, "color: red");
      return context = null;
    };
    test();
    console.groupEnd();
    return context = null;
  };
  return Test = function(name, ...stuff) {
    var i, j, l, len1, len2, ref, results, thing;
// If we've been passed any functions, run them and capture the return values.
    for (i = j = 0, len1 = stuff.length; j < len1; i = ++j) {
      thing = stuff[i];
      if (Function.type(thing)) {
        stuff[i] = thing();
      }
    }
    // If there's only one thing in stuff, just compare it with true
    if (stuff.length === 1) {
      stuff.unshift(true);
    }
    ref = Array.butLast(stuff);
    // Now, all things in stuff must all be equivalent. Or else.
    // (This test framework is super casual, so we just check each neighbouring pair)
    results = [];
    for (i = l = 0, len2 = ref.length; l < len2; i = ++l) {
      thing = ref[i];
      if (!Function.equivalent(thing, stuff[i + 1])) {
        if (typeof context === "function") {
          context();
        }
        console.group(`%c${name}`, "font-weight:normal;");
        console.log("this:", thing);
        console.log("isnt:", stuff[i + 1]);
        results.push(console.groupEnd());
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
})();

// lib/file-tree.coffee
Take(["Read"], function(Read) {
  var FileTree, populateTree, sort;
  sort = function(a, b) {
    return a.name.localeCompare(b.name);
  };
  populateTree = async function(tree) {
    var dirents;
    if ((await Read.exists(tree.path))) {
      dirents = (await Read.withFileTypes(tree.path));
      dirents.sort(sort);
      tree.children = (await Promise.all(dirents.map(async function(dirent) {
        var childFile, childTree, parts;
        if (dirent.isDirectory()) {
          childTree = FileTree.newEmpty(tree.path, dirent.name);
          childTree.relpath = Read.path(tree.relpath, dirent.name);
          await populateTree(childTree);
          tree.count += childTree.count;
          return childTree;
        } else {
          tree.count += 1;
          parts = dirent.name.split(".");
          return childFile = {
            name: dirent.name,
            basename: Array.butLast(parts).join("."),
            ext: parts.length > 1 ? Array.last(parts).toLowerCase() : null,
            path: Read.path(tree.path, dirent.name),
            relpath: Read.path(tree.relpath, dirent.name)
          };
        }
      })));
    }
    return tree;
  };
  return Make("FileTree", FileTree = {
    newEmpty: function(parentPath, name) {
      return {
        name: name,
        basename: name,
        ext: null,
        path: Read.path(parentPath, name), // absolute path on the local HD
        relpath: name, // path relative to the parent of the tree root
        count: 0,
        children: []
      };
    },
    newPopulated: async function(parentPath, name) {
      var root;
      root = FileTree.newEmpty(parentPath, name);
      await populateTree(root);
      return root;
    },
    flat: function(tree, k, into = []) {
      var child, j, len1, ref;
      ref = tree.children;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        child = ref[j];
        if (k == null) { // collecting children
          into.push(child);
        } else if (child[k] != null) {
          into.push(child[k]);
        }
        if (child.children) {
          FileTree.flat(child, k, into);
        }
      }
      return into;
    },
    find: function(tree, k, v) {
      var child, j, len1, ref, res;
      if (tree[k] === v) {
        return tree;
      }
      if (tree.children) {
        ref = tree.children;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          child = ref[j];
          if (res = FileTree.find(child, k, v)) {
            return res;
          }
        }
      }
      return null;
    }
  });
});

// lib/frustration.coffee
Take([], function() {
  var arr;
  arr = ["â€¢_â€¢` ", "`â€¢_â€¢`", " `â€¢_â€¢", "  o.o", " o.o ", "o.o  ", "â€¢âˆšâ€¢  ", " â€¢âˆšâ€¢ ", "  â€¢âˆšâ€¢", "  Â°eÂ°", " Â°oÂ° ", "Â°3Â°  ", "v_v  ", " v_v ", "  v_v", " `â€¢Ï‰â€¢", "`â€¢Ï‰â€¢`", "â€¢Ï‰â€¢` ", "â€˜^â€˜  ", " '^' ", "  `^`", "  TâˆžT", " TâˆžT ", "TâˆžT  ", "Â¡^Â¡  ", " Â¡^Â¡ ", "  Â¡^Â¡", "  ;_;", " ;_; ", ";_;  "];
  return Make("Frustration", function(i) {
    if (i != null) {
      i %= arr.length;
    } else {
      i = Math.rand(0, arr.length);
    }
    return arr[i | 0];
  });
});

// lib/iterated.coffee
Take([], function() {
  var Iterated;
  return Make("Iterated", Iterated = function(...arg1) {
    var didRunThisFrame, iteratedFunction, more, nextFrame, nextFrameRequested, ranOutOfTime, ref, requestNextFrame, run, runAgainNextFrame, startTime, timeLimit;
    ref = arg1, [...arg1] = ref, [iteratedFunction] = splice.call(arg1, -1);
    [timeLimit = 5] = arg1;
    nextFrameRequested = false;
    runAgainNextFrame = false;
    didRunThisFrame = false;
    ranOutOfTime = false;
    startTime = null;
    run = function() {
      if (didRunThisFrame) {
        // Only run once per frame. If we've already run, mark that we want to run again next frame.
        return runAgainNextFrame = true;
      }
      didRunThisFrame = true;
      // Whenever we run, we need to do some additional work next frame.
      requestNextFrame();
      // Defer the execution of the function *slightly*, to improve batching behaviour
      // when an iterated function is called repeatedly inside a loop (eg: by lib/job.coffee).
      queueMicrotask(function() {
        // Now we can actually run the iterated function!
        startTime = performance.now();
        return iteratedFunction(more);
      });
      // Iterated functions are just for side effects â€” a return value is not needed.
      return null;
    };
    requestNextFrame = function() {
      if (nextFrameRequested) {
        return;
      }
      nextFrameRequested = true;
      return requestAnimationFrame(nextFrame);
    };
    // Whenever someone calls run(), we *always* need to do some cleanup work, and me might
    // also need to call run() again ourselves if there's more iterated work to be done.
    nextFrame = function() {
      var doRun;
      doRun = runAgainNextFrame;
      nextFrameRequested = false;
      runAgainNextFrame = false;
      didRunThisFrame = false;
      ranOutOfTime = false;
      if (doRun) {
        return run();
      }
    };
    // This function will tell the caller whether they're safe to do more work this frame.
    // They'll call it repeatedly in a loop (while doing other work) until either they
    // run out of time and break out of the loop, or run out of work to do and just stop
    // calling us.
    more = function(customLimit) {
      ranOutOfTime = performance.now() - startTime > (customLimit || timeLimit);
      if (ranOutOfTime) {
        // Mark that we want to actually do a run() next frame, not just the usual cleanup.
        runAgainNextFrame = true;
        // We always need to request a new frame, since the call to more() might come
        // long after the last call to run() if the iterated function is doing something async.
        requestNextFrame();
      }
      return !ranOutOfTime;
    };
    return run;
  });
});

// lib/job.coffee
Take([], function() {
  var Job, bail, handlers, lastN, lastTime, run, running, updateWatchers, watchers;
  handlers = {};
  watchers = [];
  running = false;
  lastTime = null;
  lastN = [];
  Make.async("Job", Job = function(priority, type, ...args) {
    // Priority is optional, and defaults to 0
    if (String.type(priority)) {
      return Job(0, priority, type, ...args);
    }
    if (handlers[type] == null) {
      throw Error(`No handler for job type: ${type}`);
    }
    return new Promise(function(resolve) {
      var base;
      if ((base = Job.queues)[priority] == null) {
        base[priority] = [];
      }
      Job.queues[priority].push({type, args, resolve});
      Job.count++;
      return Job.runJobs();
    });
  });
  Job.queues = [];
  Job.count = 0;
  Job.delay = 0;
  Job.handler = function(type, handler) {
    if (handlers[type]) {
      throw Error(`A job handler for ${type} already exists`);
    }
    return handlers[type] = handler;
  };
  Job.watcher = function(watcher) {
    return watchers.push(watcher);
  };
  Job.runJobs = function() {
    if (running) {
      return;
    }
    running = true;
    lastTime = performance.now();
    Job.delay = 16;
    updateWatchers();
    return requestAnimationFrame(run);
  };
  run = function() {
    var args, dirty, j, priority, queue, ref, resolve, time, type;
    dirty = false;
    ref = Job.queues;
    for (priority = j = ref.length - 1; j >= 0; priority = j += -1) {
      queue = ref[priority];
      while ((queue != null ? queue.length : void 0) > 0) {
        dirty = true;
        ({time, type, args, resolve} = queue.shift());
        Job.count--;
        resolve(handlers[type](...args)); // We can't await, or else if a Job creates a new Job inside itself, we'll get stuck
        Job.delay = (performance.now() - lastTime) * 0.1 + Job.delay * 0.9;
        if (Job.delay > 30) { // Don't let the frame rate crater
          return bail();
        }
      }
    }
    running = false;
    if (dirty) {
      // If any jobs ran this frame, we should run at least one more time, in case any jobs that we ran created new jobs at a higher priority.
      Job.runJobs();
    }
    return updateWatchers();
  };
  bail = function() {
    lastTime = performance.now();
    requestAnimationFrame(run);
    return updateWatchers();
  };
  return updateWatchers = function() {
    var j, len1, watcher;
    for (j = 0, len1 = watchers.length; j < len1; j++) {
      watcher = watchers[j];
      watcher(Job.count, Job.delay);
    }
    return null;
  };
});

// lib/log-initialization-time.coffee
(async function() {
  var Log, performance, time;
  if (typeof performance === "undefined" || performance === null) {
    ({performance} = require("perf_hooks"));
  }
  time = performance.now();
  Log = (await Take.async("Log"));
  return Log("Initialization Time", null, time);
})();

// lib/log.coffee
Take([], function() {
  var DB, Env, IPC, Log, Printer, performance;
  if (typeof performance === "undefined" || performance === null) {
    ({performance} = require("perf_hooks"));
  }
  // We can't / shouldn't Take anything, since Log might need to be used *anywhere*
  DB = Env = IPC = Printer = null;
  Make.async("Log", Log = function(msg, attrs, time) {
    if (Env == null) {
      Env = Take("Env");
    }
    // Send logs to the local printer
    if (Printer != null ? Printer : Printer = Take("Printer")) {
      Printer(msg, attrs, time);
    }
    // If we have a port to the DB, send logs to the DB Printer
    if (DB != null ? DB : DB = Take("DB")) {
      DB.send("printer", msg, attrs, time);
    }
    // If we're in dev, and in a render process, send logs to the main process Printer
    if ((Env != null ? Env.isDev : void 0) && (Env != null ? Env.isRender : void 0) && (IPC != null ? IPC : IPC = Take("IPC"))) {
      IPC.send("printer", msg, attrs, time);
    }
    return msg;
  });
  Log.time = function(msg, fn) {
    var start, v;
    start = performance.now();
    v = fn();
    Log.time.formatted(msg, performance.now() - start);
    return v;
  };
  Log.time.async = async function(msg, fn) {
    var start, v;
    start = performance.now();
    v = (await fn());
    Log.time.formatted(msg, performance.now() - start);
    return v;
  };
  Log.time.custom = function(preMsg) {
    var start;
    if (preMsg) {
      Log(preMsg);
    }
    start = performance.now();
    return function(postMsg) {
      return Log.time.formatted(postMsg, performance.now() - start);
    };
  };
  Log.time.formatted = function(msg, time) {
    return Log(time.toFixed(1).padStart(6) + " " + msg);
  };
  return Log.err = function(msg) {
    return Log(msg, {
      color: "#F00"
    });
  };
});

// lib/paths.coffee
Take(["Read"], function(Read) {
  var Paths;
  return Make("Paths", Paths = {
    files: function(asset) {
      return Read.path(asset.path, "Files");
    },
    names: function(asset) {
      return Read.path(asset.path, "Name");
    },
    shots: function(asset) {
      return Read.path(asset.path, "Shot");
    },
    newShots: function(asset) {
      return Read.path(asset.path, "Shot (New)");
    },
    tags: function(asset) {
      return Read.path(asset.path, "Tags");
    },
    thumbnails: function(asset) {
      return Read.path(asset.path, "Thumbnail Cache");
    },
    file: function(asset, filename) {
      return Read.path(Paths.files(asset), filename);
    },
    name: function(asset) {
      return Read.path(Paths.names(asset), asset.name);
    },
    shot: function(asset) {
      return Read.path(Paths.shots(asset), asset.shot);
    },
    newShot: function(asset) {
      return Read.path(Paths.newShots(asset), asset.newShot);
    },
    thumbnail: function(asset, filename) {
      return Read.path(Paths.thumbnails(asset), filename);
    },
    tag: function(asset, tag) {
      return Read.path(Paths.tags(asset), tag);
    },
    thumbnailName: function(file, size) {
      return `${String.hash(file.relpath)}-${size}.jpg`;
    },
    ext: {
      icon: {
        "as": "as",
        "cptx": "cptx",
        "css": "css",
        "dwg": "dwg",
        "exe": "exe",
        "fla": "fla",
        "idlk": "idlk",
        "indb": "indb",
        "indd": "indd",
        "swf": "swf",
        null: true,
        undefined: true // Include null / undefined because we want those to get an icon, not a thumbnail
      },
      sips: {"3fr": "3fr", "arw": "arw", "astc": "astc", "avci": "avci", "bmp": "bmp", "cr2": "cr2", "cr3": "cr3", "crw": "crw", "dcr": "dcr", "dds": "dds", "dng": "dng", "dxo": "dxo", "erf": "erf", "exr": "exr", "fff": "fff", "gif": "gif", "heic": "heic", "heics": "heics", "heif": "heif", "icns": "icns", "ico": "ico", "iiq": "iiq", "jp2": "jp2", "jpeg": "jpeg", "jpg": "jpg", "ktx": "ktx", "mos": "mos", "mpo": "mpo", "mrw": "mrw", "nef": "nef", "nrw": "nrw", "orf": "orf", "orf": "orf", "orf": "orf", "pbm": "pbm", "pdf": "pdf", "pef": "pef", "pic": "pic", "pict": "pict", "png": "png", "psd": "psd", "pvr": "pvr", "raf": "raf", "raw": "raw", "rw2": "rw2", "rwl": "rwl", "sgi": "sgi", "sr2": "sr2", "srf": "srf", "srw": "srw", "tga": "tga", "tiff": "tiff", "webp": "webp"},
      video: {"avchd": "avchd", "avi": "avi", "m4p": "m4p", "m4v": "m4v", "mov": "mov", "mp2": "mp2", "mp4": "mp4", "mpe": "mpe", "mpeg": "mpeg", "mpg": "mpg", "mpv": "mpv", "ogg": "ogg", "qt": "qt", "webm": "webm", "wmv": "wmv"}
    }
  });
});

// lib/printer.coffee
Take([], function() {
  var Printer, performance;
  if (typeof window !== "undefined" && window !== null ? window.isDB : void 0) { // DB has its own Printer
    return;
  }
  if (typeof performance === "undefined" || performance === null) {
    ({performance} = require("perf_hooks"));
  }
  return Make("Printer", Printer = function(msg, attrs, time) {
    time = (time || performance.now()).toFixed(0).padStart(5);
    return console.log(time + "  " + msg);
  });
});

// lib/pub-sub.coffee
Take([], function() {
  var Pub, Sub, subs;
  subs = {};
  Sub = function(name, cb) {
    return (subs[name] != null ? subs[name] : subs[name] = []).push(cb);
  };
  Pub = function(name, ...args) {
    var handler, j, len1, ref;
    if (subs[name] != null) {
      ref = subs[name];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        handler = ref[j];
        handler(...args);
      }
    }
    return null;
  };
  return Make("PubSub", {Pub, Sub});
});

// lib/read.coffee
// TODO: Clear up the naming so that everything is explicitly Read.sync.foo or Read.async.foo
Take([], function() {
  var Read, filterValidDirentName, fs, path, validDirentName, validFileName;
  fs = require("fs");
  path = require("path");
  validFileName = function(v) {
    if (0 === v.indexOf(".")) { // Exclude dotfiles
      return false;
    }
    if (-1 !== v.search(/[<>:;,?"*|\/\\]/)) { // Exclude names we won't be able to roundtrip
      return false;
    }
    return true; // Everything else is good
  };
  validDirentName = function(v) {
    return validFileName(v.name);
  };
  filterValidDirentName = function(vs) {
    return vs.filter(validDirentName);
  };
  Read = function(folderPath) {
    var fileNames;
    try {
      fileNames = fs.readdirSync(folderPath);
      return fileNames.filter(validFileName);
    } catch (error) {
      return null;
    }
  };
  // Temporary hack until we fully switch Read over to split sync and async.
  // Note that we can't just say Read.sync = Read, or that breaks Read.sync.exists!
  Read.sync = function(p) {
    return Read(p);
  };
  Read.sync.exists = function(path) {
    return fs.existsSync(path);
  };
  Read.async = function(folderPath) {
    return new Promise(function(resolve) {
      return fs.readdir(folderPath, function(err, fileNames) {
        if (err != null) {
          return resolve(null);
        } else {
          return resolve(fileNames.filter(validFileName));
        }
      });
    });
  };
  Read.withFileTypes = function(folderPath) {
    return fs.promises.readdir(folderPath, {
      withFileTypes: true
    }).then(filterValidDirentName);
  };
  Read.isFolder = function(folderPath) {
    if (!(folderPath != null ? folderPath.length : void 0)) {
      return false;
    }
    return new Promise(function(resolve) {
      return fs.stat(folderPath, function(err, stat) {
        return resolve(stat != null ? stat.isDirectory() : void 0);
      });
    });
  };
  Read.stat = function(path) {
    return new Promise(function(resolve) {
      return fs.stat(path, function(err, stat) {
        return resolve(stat);
      });
    });
  };
  Read.exists = function(filePath) {
    if (!(filePath != null ? filePath.length : void 0)) {
      return false;
    }
    return new Promise(function(resolve) {
      return fs.access(filePath, function(err) {
        return resolve(err == null);
      });
    });
  };
  Read.file = function(filePath) {
    var file;
    try {
      return file = fs.readFileSync(filePath);
    } catch (error) {
      return null;
    }
  };
  Read.sep = path.sep;
  Read.watch = fs.watch;
  Read.path = function(...segs) {
    return segs.join(path.sep);
  };
  Read.split = function(p) {
    return Array.pull(p.split(path.sep), "");
  };
  Read.last = function(p) {
    return Array.last(Read.split(p));
  };
  Read.parentPath = function(p) {
    return Read.path(...Array.butLast(Read.split(p)));
  };
  return Make("Read", Read);
});

// lib/size-on-disk.coffee
Take(["Read"], function(Read) {
  var SizeOnDisk;
  Make.async("SizeOnDisk", SizeOnDisk = function(path) {
    return new Promise(async function(resolve) {
      var childName, children, j, len1, size, sizes, stats, total;
      stats = (await Read.stat(path));
      if (stats == null) {
        return resolve(0);
      } else if (!stats.isDirectory()) {
        return resolve(stats.size);
      } else {
        total = 0;
        children = (await Read.async(path));
        sizes = (function() {
          var j, len1, results;
          results = [];
          for (j = 0, len1 = children.length; j < len1; j++) {
            childName = children[j];
            results.push(SizeOnDisk(Read.path(path, childName)));
          }
          return results;
        })();
        for (j = 0, len1 = sizes.length; j < len1; j++) {
          size = sizes[j];
          total += (await size);
        }
        return resolve(total);
      }
    });
  });
  return SizeOnDisk.pretty = async function(path) {
    var exp, len, size, suffix;
    size = (await SizeOnDisk(path));
    len = size.toString().length;
    console.log(size / 1000);
    console.log(len);
    switch (false) {
      case !(len < 3):
        suffix = "B";
        exp = 0;
        break;
      case !(len < 7):
        suffix = "KB";
        exp = 1;
        break;
      case !(len < 11):
        suffix = "MB";
        exp = 2;
        break;
      default:
        suffix = "GB";
        exp = 3;
    }
    return (size / Math.pow(1000, exp)).toFixed(1) + " " + suffix;
  };
});

// lib/state.coffee
Take([], function() {
  var State, conditionalSet, getAt, localNotify, runCbs, runCbsAbove, runCbsWithin, state, subscriptions;
  state = {};
  subscriptions = {
    _cbs: []
  };
  getAt = function(node, path) {
    var j, k, len1, part, parts;
    if (path === "") {
      return [
        {
          "": node
        },
        ""
      ];
    }
    parts = path.split(".");
    k = parts.pop();
    for (j = 0, len1 = parts.length; j < len1; j++) {
      part = parts[j];
      node = node[part] != null ? node[part] : node[part] = {};
    }
    return [node, k];
  };
  Make.async("State", State = function(path = "", v, {immutable = false} = {}) {
    var k, node, old;
    [node, k] = getAt(state, path);
    if (v === void 0) { // Just a read
      return node[k];
    }
    if (!immutable) {
      
      // It's not safe to take something out of State, mutate it, and commit it again.
      // The immutable option tells us the caller promises they're not doing that.
      // Otherwise, we clone values before reading or writing them.
      v = Function.clone(v);
    }
    if (!immutable && v === node[k] && (Object.type(v) || Array.type(v))) {
      throw "Did you take something out of State, mutate it, and commit it again?";
    }
    if (path === "") {
      throw Error("You're not allowed to set the State root");
    }
    old = node[k];
    if (v != null) {
      node[k] = v;
    } else {
      delete node[k];
    }
    if (Function.notEquivalent(v, old)) {
      queueMicrotask(function() {
        return localNotify(path, v);
      });
    }
    return v;
  });
  conditionalSet = function(path, v, pred) {
    var doSet, k, node;
    [node, k] = getAt(state, path);
    doSet = pred(node[k], v);
    if (doSet) {
      State(path, v);
    }
    return doSet;
  };
  // These are useful because they return true if a change was made
  State.change = function(path, v) {
    return conditionalSet(path, v, Function.notEquivalent);
  };
  State.default = function(path, v) {
    return conditionalSet(path, v, Function.notExists);
  };
  // This is useful because it reduces the need to update State in a loop,
  // which triggers a lot of (possibly pointless) notifications.
  // Reminder that Object.merge doesn't handle arrays, so maybe
  // limit the use of this function to primitives (since it implies immutable).
  State.merge = function(path, v) {
    return State(path, Object.merge(v, State(path)), {
      immutable: true
    });
  };
  // These are useful because it offers a nice syntax for updating existing values in State,
  // with support for async, either mutably or immutably.
  State.update = async function(path, fn) {
    return State(path, (await fn(State(path))), {
      immutable: true
    });
  };
  State.mutate = async function(path, fn) {
    return State.clone(path, (await fn(State(path))), {
      immutable: true
    });
  };
  // This is a convenience function for reading something from State that is pre-cloned
  // (if necessary) to avoid mutability issues.
  State.clone = function(path) {
    return Function.clone(State(path));
  };
  State.subscribe = function(...arg1) {
    var base, cb, k, node, path, ref, runNow, weak;
    ref = arg1, [...arg1] = ref, [cb] = splice.call(arg1, -1);
    [path = "", runNow = true, weak = false] = arg1;
    if (!String.type(path)) { // Avoid errors if you try say subscribe(runNow, cb)
      throw "Invalid subscribe path";
    }
    [node, k] = getAt(subscriptions, path);
    ((base = (node[k] != null ? node[k] : node[k] = {}))._cbs != null ? base._cbs : base._cbs = []).push(cb);
    cb._state_weak = weak; // ... this is fine ðŸ•â˜•ï¸ðŸ”¥
    if (runNow) {
      return cb(State(path));
    }
  };
  State.unsubscribe = function(...arg1) {
    var cb, k, node, path, ref;
    ref = arg1, [...arg1] = ref, [cb] = splice.call(arg1, -1);
    [path = ""] = arg1;
    [node, k] = getAt(subscriptions, path);
    if (indexOf.call(node[k]._cbs, cb) < 0) {
      throw Error("Unsubscribe failed");
    }
    Array.pull(node[k]._cbs, cb);
    return null;
  };
  localNotify = function(path, v) {
    var changes, k, node;
    [node, k] = getAt(subscriptions, path);
    runCbsWithin(node[k], v);
    runCbs(node[k], v, v);
    changes = runCbsAbove(path, v);
    return runCbs(subscriptions, state, changes);
  };
  runCbsWithin = function(parent, v) {
    var _v, child, k;
    if (!Object.type(parent)) {
      return;
    }
    for (k in parent) {
      child = parent[k];
      if (!(k !== "_cbs")) {
        continue;
      }
      _v = v != null ? v[k] : void 0;
      runCbsWithin(child, _v);
      runCbs(child, _v, _v);
    }
    return null;
  };
  runCbsAbove = function(path, changes) {
    var changesAbove, k, node, p, parts, pathAbove;
    parts = path.split(".");
    p = parts.pop();
    changesAbove = {};
    changesAbove[p] = changes;
    if (!(parts.length > 0)) {
      return changesAbove;
    }
    pathAbove = parts.join(".");
    [node, k] = getAt(subscriptions, pathAbove);
    runCbs(node[k], State(pathAbove), changesAbove);
    return runCbsAbove(pathAbove, changesAbove);
  };
  return runCbs = function(node, v, changed) {
    var cb, dead, j, l, len1, len2, ref;
    if (node != null ? node._cbs : void 0) {
      dead = [];
      ref = node._cbs;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        cb = ref[j];
        if (cb._state_weak && (v == null)) {
          dead.push(cb);
        } else {
          cb(v, changed);
        }
      }
      for (l = 0, len2 = dead.length; l < len2; l++) {
        cb = dead[l];
        Array.pull(node._cbs, cb);
      }
    }
    return null;
  };
});

// lib/write.coffee
Take(["Env", "Log", "Read"], function(Env, Log, Read) {
  var Memory, Write, fs, logWrite, validPath;
  fs = require("fs");
  validPath = function(v) {
    var valid;
    valid = true;
    v = v.replace(/^[A-Z]:/, ""); // Ignore the drive letter on Windows 
    if (-1 !== v.search(/[<>:;,?"*|]/)) { // Exclude names we won't be able to roundtrip
      valid = false;
    }
    if (!valid) {
      Log.err(`${v} is not a valid file path`);
    }
    return valid;
  };
  Make.async("Write", Write = function() {
    throw "Not Implemented";
  });
  Write.logging = true;
  Write.sync = {};
  Write.async = {};
  Memory = null;
  logWrite = function(fn, p, opts = {}) {
    if (opts.quiet) {
      return;
    }
    if (!Write.logging) {
      return;
    }
    if (Memory != null ? Memory : Memory = Take("Memory")) {
      if (p !== Memory("assetsFolder")) {
        p = p.replace(new RegExp(Memory("assetsFolder") + Read.sep, "g"), "");
      }
      if (p !== Memory("dataFolder")) {
        p = p.replace(new RegExp(Memory("dataFolder") + Read.sep, "g"), "");
      }
    }
    if (p !== Env.home) {
      p = p.replace(new RegExp(Env.home + Read.sep, "g"), "");
    }
    return Log(`WRITE ${fn} ${p}`);
  };
  Write.sync.file = function(path, data, opts) {
    var valid;
    if (valid = validPath(path)) {
      logWrite("file", path, opts);
      fs.writeFileSync(path, data);
    }
    return valid;
  };
  Write.sync.mkdir = function(path, opts) {
    var valid;
    if (fs.existsSync(path)) {
      return true;
    }
    if (valid = validPath(path)) {
      logWrite("mkdir", path, opts);
      fs.mkdirSync(path, {
        recursive: true
      });
    }
    return valid;
  };
  Write.sync.rename = function(path, newName, opts) {
    var newPath, valid;
    newPath = Read.sep + Read.path(Read.parentPath(path), newName);
    if (path === newPath) {
      return true;
    }
    if (valid = validPath(path) && validPath(newPath)) {
      logWrite("rename", `${path} -> ${newPath}`, opts);
      fs.renameSync(path, newPath);
    }
    return valid;
  };
  Write.sync.rm = function(path, opts) {
    var valid;
    if (!fs.existsSync(path)) {
      return true;
    }
    if (valid = validPath(path)) {
      logWrite("rm", path, opts);
      fs.rmSync(path, {
        recursive: true
      });
    }
    return valid;
  };
  Write.sync.copyFile = function(src, dest, opts) {
    var valid;
    if (valid = validPath(src) && validPath(dest)) {
      logWrite("copyFile", `${src} -> ${dest}`, opts);
      fs.copyFileSync(src, dest);
    }
    return valid;
  };
  Write.sync.json = function(path, data, opts) {
    return Write.sync.file(path, JSON.stringify(data), opts);
  };
  Write.sync.array = function(path, arr, opts) {
    var current, j, l, len1, len2, v;
    current = Read(path);
    if (current == null) {
      current = [];
    }
    if (Array.equal(arr, current)) {
      return;
    }
    for (j = 0, len1 = current.length; j < len1; j++) {
      v = current[j];
      if (indexOf.call(arr, v) < 0) {
        // Remove anything that's in the folder but not in our new array
        Write.sync.rm(Read.path(path, v), opts);
      }
    }
    for (l = 0, len2 = arr.length; l < len2; l++) {
      v = arr[l];
      if (indexOf.call(current, v) < 0) {
        // Save anything that's in our new array but not in the folder
        Write.sync.mkdir(Read.path(path, v), opts);
      }
    }
    return null;
  };
  return Write.async.copyInto = async function(src, destFolder, opts) {
    var _valid, childDestFolder, item, j, len1, ref, srcName, valid;
    srcName = Read.last(src);
    if ((await Read.isFolder(src))) {
      childDestFolder = Read.path(destFolder, srcName);
      Write.sync.mkdir(childDestFolder, opts);
      valid = true;
      ref = Read(src);
      for (j = 0, len1 = ref.length; j < len1; j++) {
        item = ref[j];
        _valid = Write.async.copyInto(Read.path(src, item), childDestFolder, opts);
        valid && (valid = _valid);
      }
      return valid;
    } else {
      return Write.sync.copyFile(src, Read.path(destFolder, srcName), opts);
    }
  };
});

// main/coffee/db.coffee
Take(["Window", "DBWindowReady"], function(Window) {
  var DB;
  return Make("DB", DB = {
    send: function(fn, ...args) {
      return Window.getDB().webContents.send("mainPort", fn, ...args);
    }
  });
});

// main/coffee/env.coffee
Take([], function() {
  var Env, app, childProcess, os, path;
  ({app} = require("electron"));
  childProcess = require("child_process");
  os = require("os");
  path = require("path");
  Env = {
    isDev: !app.isPackaged,
    isMac: process.platform === "darwin",
    isDef: process.defaultApp,
    isMain: true,
    isRender: false,
    userData: app.getPath("userData"),
    home: app.getPath("home"),
    version: app.getVersion(),
    versions: process.versions
  };
  Env.computerName = Env.isMac ? childProcess.execSync("scutil --get ComputerName").toString().replace("\n", "") : os.hostname();
  // Persisted user preferences and other per-install app state that will be managed by the DB window
  Env.configPath = path.join(Env.userData, "Config.json");
  // Persisted per-install app state that will be managed by the DB process
  Env.dbStatePath = path.join(Env.userData, "DB State.json");
  // Persisted per-install app state that will be managed by the Main process
  Env.mainStatePath = path.join(Env.userData, "Main State.json");
  // Where the assets and other globally-shared data managed by Hyperzine will live
  Env.defaultDataFolder = path.join(Env.home, "Dropbox", "System", "Hyperzine");
  return Make("Env", Env);
});

// main/coffee/ipc-handlers.coffee
(async function() {
  var BrowserWindow, Env, Handlers, IPC, Log, MessageChannelMain, Printer, Window, app, dialog;
  ({app, BrowserWindow, dialog, MessageChannelMain} = require("electron"));
  // In additon to the IPC handlers below, we also set up some app event handlers for our windows
  app.on("browser-window-focus", function(event, win) {
    return win.webContents.send("focus");
  });
  app.on("browser-window-blur", function(event, win) {
    return win.webContents.send("blur");
  });
  ({Env, IPC, Log, Printer, Window} = (await Take.async(["Env", "IPC", "Log", "Printer", "Window"])));
  return Make("Handlers", Handlers = {
    setup: function() {
      // SYSTEM
      IPC.handle("env", function() {
        return Env;
      });
      IPC.on("quit", function({sender}, msg) {
        return app.quit();
      });
      IPC.on("fatal", function({sender}, msg) {
        dialog.showErrorBox("Fatal Error", msg);
        return app.quit();
      });
      IPC.on("alert", function({sender}, opts) { // See: https://www.electronjs.org/docs/latest/api/dialog/#dialogshowmessageboxbrowserwindow-options
        return dialog.showMessageBox(opts);
      });
      IPC.on("printer", function(e, ...args) {
        return Printer(...args);
      });
      IPC.on("bind-db", function({processId, sender}) {
        var db, port1, port2;
        db = Window.getDB();
        ({port1, port2} = new MessageChannelMain());
        sender.postMessage("port", {
          id: processId
        }, [port1]);
        return db.webContents.postMessage("port", {
          id: processId
        }, [port2]);
      });
      // WINDOWING
      IPC.on("close-window", function({sender}) {
        var ref;
        return (ref = BrowserWindow.fromWebContents(sender)) != null ? ref.close() : void 0;
      });
      IPC.on("set-window-title", function({sender}, name) {
        return BrowserWindow.fromWebContents(sender).setTitle(name);
      });
      IPC.handle("showOpenDialog", function({sender}, opts) {
        return dialog.showOpenDialog(BrowserWindow.fromWebContents(sender), opts);
      });
      IPC.on("open-asset", function(e, assetId) {
        return Window.open.asset(assetId);
      });
      IPC.handle("whats-my-asset", function({sender}) {
        var win;
        win = BrowserWindow.fromWebContents(sender);
        return Window.data[win.webContents.id].assetId;
      });
      // FEATURES
      IPC.on("drag-file", async function({sender}, path) {
        return sender.startDrag({
          file: path,
          icon: (await app.getFileIcon(path))
        });
      });
      IPC.handle("get-file-icon", async function({sender}, path) {
        var img;
        img = (await app.getFileIcon(path));
        return img.toDataURL();
      });
      return IPC.on("preview-file", function({sender}, path) {
        var win;
        win = BrowserWindow.fromWebContents(sender);
        return win.previewFile(path);
      });
    }
  });
})();

// main/coffee/ipc.coffee
Take(["Window"], function(Window) {
  var BrowserWindow, IPC, ipcMain;
  ({BrowserWindow, ipcMain} = require("electron"));
  return Make("IPC", IPC = {
    on: function(channel, cb) {
      return ipcMain.on(channel, cb);
    },
    once: function(channel, cb) {
      return ipcMain.once(channel, cb);
    },
    handle: function(channel, cb) {
      return ipcMain.handle(channel, cb);
    },
    promise: {
      once: function(channel) {
        return new Promise(function(resolve) {
          return ipcMain.once(channel, function(e, arg) {
            return resolve(arg);
          });
        });
      },
      handle: function(channel) {
        return new Promise(function(resolve) {
          return ipcMain.handle(channel, function(e, arg) {
            return resolve(arg);
          });
        });
      }
    },
    // Send a message to the frontmost window
    toFocusedWindow: function(msg) {
      var win;
      win = BrowserWindow.getFocusedWindow();
      if (win == null) {
        win = BrowserWindow.getAllWindows()[0];
      }
      if (win == null) {
        win = Window.open.browser(); // No windows, so open a new window
      }
      return win.webContents.send(msg);
    }
  });
});

// main/coffee/main-state.coffee
// This file manages any state that needs to be persisted to the local filesystem
// just for the main process.
Take(["ADSR", "Env", "Log", "Read", "Write"], function(ADSR, Env, Log, Read, Write) {
  var MainState, save, state;
  // This lists all the keys we'll persist in the main state file, with their default values
  state = {
    windowBounds: {
      asset: [],
      browser: [],
      db: [],
      "setup-assistant": []
    }
  };
  save = ADSR(0, 2000, function() {
    return Write.sync.json(Env.mainStatePath, state, {
      quiet: true
    });
  });
  Make.async("MainState", MainState = function(k, v) {
    if (state[k] == null) {
      throw Error(`Unknown MainState key: ${k}`);
    }
    if (v !== void 0) {
      if (v != null) {
        state[k] = v;
      } else {
        delete state[k];
      }
      save();
    }
    return state[k];
  });
  return MainState.init = function() {
    var data, json, k, results, v;
    try {
      json = Read.file(Env.mainStatePath);
      data = JSON.parse(json);
      results = [];
      for (k in data) {
        v = data[k];
        // Only accept keys we explicitly list in the defaults.
        // This lets us drop obsolete values.
        if (state[k] != null) {
          results.push(state[k] = v);
        } else {
          results.push(void 0);
        }
      }
      return results;
    } catch (error) {}
  };
});

// main/coffee/menu.coffee
Take(["Env", "IPC", "Window"], function(Env, IPC, Window) {
  var Menu, app, shell, template;
  ({app, Menu, shell} = require("electron"));
  template = [];
  if (Env.isMac) {
    template.push({
      label: app.name,
      submenu: [
        {
          role: "about"
        },
        {
          type: "separator"
        },
        {
          label: "Preferences",
          accelerator: "CmdOrCtrl+,",
          click: Window.open.setupAssistant
        },
        {
          type: "separator"
        },
        {
          role: "services"
        },
        {
          type: "separator"
        },
        {
          role: "hide"
        },
        {
          role: "hideothers"
        },
        {
          role: "unhide"
        },
        {
          type: "separator"
        },
        {
          role: "quit"
        }
      ]
    });
  }
  template.push({
    label: "File",
    submenu: [
      {
        label: "New Asset",
        accelerator: "CmdOrCtrl+N",
        click: function() {
          var ref;
          return (ref = Take("DB")) != null ? ref.send("New Asset") : void 0;
        }
      },
      {
        label: "New Browser Window",
        accelerator: "CmdOrCtrl+Shift+N",
        click: Window.open.browser
      },
      {
        type: "separator"
      },
      {
        label: "Show Config File",
        click: function() {
          return shell.showItemInFolder(Env.configPath);
        }
      },
      {
        type: "separator"
      },
      {
        role: Env.isMac ? "close" : "quit"
      }
    ]
  });
  template.push({
    label: "Edit",
    submenu: [
      {
        role: "undo"
      },
      {
        role: "redo"
      },
      {
        type: "separator"
      },
      {
        role: "cut"
      },
      {
        role: "copy"
      },
      {
        role: "paste"
      },
      {
        role: "delete"
      },
      {
        role: "selectAll"
      },
      {
        type: "separator"
      },
      {
        label: "Find",
        accelerator: "CmdOrCtrl+F",
        click: function() {
          return IPC.toFocusedWindow("find");
        }
      },
      {
        type: "separator"
      },
      ...(!Env.isMac ? [
        {
          type: "separator"
        },
        {
          label: "Settings",
          click: Window.open.setupAssistant
        }
      ] : [])
    ]
  });
  template.push({
    label: "View",
    submenu: [
      ...(Env.isDev || !Env.isMac ? [
        {
          role: "reload"
        },
        {
          role: "forceReload"
        },
        {
          role: "toggleDevTools"
        },
        {
          type: "separator"
        }
      ] : []),
      {
        role: "togglefullscreen"
      }
    ]
  });
  template.push({
    role: "windowMenu",
    submenu: [
      {
        role: "minimize"
      },
      {
        role: "zoom"
      },
      ...(Env.isMac ? [
        {
          type: "separator"
        },
        {
          role: "front"
        }
      ] : [
        {
          role: "close"
        }
      ]),
      {
        type: "separator"
      },
      {
        label: "Show Debug Log",
        accelerator: "CmdOrCtrl+Shift+D",
        click: Window.open.db
      }
    ]
  });
  template.push({
    role: "help",
    submenu: [
      ...(!Env.isMac ? [
        {
          role: "about"
        },
        {
          type: "separator"
        }
      ] : []),
      {
        label: "Hyperzine Guide",
        click: function() {
          return shell.openExternal("https://github.com/cdig/hyperzine/wiki/Hyperzine-Guide");
        }
      },
      {
        type: "separator"
      },
      {
        label: "Report a Problem or Feature Requestâ€¦",
        click: function() {
          return shell.openExternal("https://github.com/cdig/hyperzine/issues/new");
        }
      },
      {
        label: "Beep for Good Luck",
        click: function() {
          return shell.beep();
        }
      }
    ]
  });
  return Make("Menu", {
    setup: function() {
      return Menu.setApplicationMenu(Menu.buildFromTemplate(template));
    }
  });
});

// main/coffee/updates.coffee
Take(["Env", "Log", "Window"], function(Env, Log, Window) {
  var Updates, app, autoUpdater, dialog;
  ({app, autoUpdater, dialog} = require("electron"));
  return Make("Updates", Updates = {
    setup: function() {
      var checkForUpdates, doCheckForUpdates;
      if (Env.isDev) {
        return;
      }
      doCheckForUpdates = true;
      autoUpdater.setFeedURL({
        url: `https://update.electronjs.org/cdig/hyperzine/${process.platform}-${process.arch}/${app.getVersion()}`
      });
      autoUpdater.on("checking-for-update", function() {
        return Log("Checking for update");
      });
      autoUpdater.on("update-not-available", function() {
        return Log("Update not available");
      });
      autoUpdater.on("update-available", function() {
        doCheckForUpdates = false;
        return Log("Downloading update...");
      });
      autoUpdater.on("error", function(err) {
        doCheckForUpdates = false;
        return Log.err(err);
      });
      autoUpdater.on("update-downloaded", async function(e, releaseNotes, releaseName) {
        var res;
        Log(`Update Downloaded: ${releaseName}`);
        res = (await dialog.showMessageBox({
          type: "info",
          buttons: ["Restart Hyperzine", "Later"],
          defaultId: 0,
          title: "Application Update",
          message: `Hyperzine has been updated to ${releaseName.replace("v", "version ")}.\n\nWould you like to restart and use the updated version now?`
        }));
        Log(`Response: ${res.response}`);
        if (res.response === 0) {
          Window.aboutToQuit();
          autoUpdater.quitAndInstall();
          return Log("Quitting");
        }
      });
      checkForUpdates = function() {
        if (doCheckForUpdates) {
          return autoUpdater.checkForUpdates();
        }
      };
      checkForUpdates();
      return setInterval(checkForUpdates, 60 * 60 * 1000);
    }
  });
});

// main/coffee/window.coffee
Take(["Env", "MainState"], function(Env, MainState) {
  var BrowserWindow, Window, aboutToQuit, app, checkBounds, clearIndex, db, defaultBounds, defaultWindow, dialog, getBounds, getNextIndex, nativeTheme, newWindow, openAsset, openBrowser, openDb, openSetupAssistant, screen, setupAssistant, updateBounds, windowBounds, windowData, windowIndexes;
  ({app, BrowserWindow, dialog, nativeTheme, screen} = require("electron"));
  defaultWindow = {
    title: "Hyperzine",
    titleBarStyle: Env.isMac ? "hiddenInset" : "hidden",
    titleBarOverlay: true,
    minWidth: 340,
    minHeight: 340,
    webPreferences: {
      contextIsolation: false,
      nodeIntegration: true,
      scrollBounce: true,
      backgroundThrottling: false,
      nativeWindowOpen: false // This is changing to true by default in Electron 15
    }
  };
  defaultBounds = {
    asset: {
      width: 960,
      height: 540
    },
    browser: {
      width: 1280,
      height: 720
    },
    db: {
      width: 640,
      height: 480
    },
    "setup-assistant": {
      width: 480,
      height: 540
    }
  };
  windowIndexes = {};
  windowBounds = null;
  windowData = {};
  // Single instance windows
  db = null;
  setupAssistant = null;
  aboutToQuit = false;
  app.on("before-quit", function() {
    return aboutToQuit = true;
  });
  // We want to track whether this window is the 1st, 2nd, 3rd (etc) instance of its type.
  // That way, whenever we open a new window, we can assign it to the most recently used
  // position for that instance of that type of window. Closing a window will leave a null
  // in the list of windows, which will be filled next time that type of window is opened.
  // Here, "index" means the 1st, 2nd, 3rd (etc) instance
  getNextIndex = function(type) {
    var index, indexes;
    indexes = windowIndexes[type] != null ? windowIndexes[type] : windowIndexes[type] = [];
    index = indexes.indexOf(null); // Find the position of the first null, if any
    if (index < 0) { // No nulls, so add to the end of the list
      index = indexes.length;
    }
    windowIndexes[type][index] = true; // Save that this index is now being used
    return index;
  };
  clearIndex = function(type, index) {
    return windowIndexes[type][index] = null;
  };
  getBounds = function(type, index) {
    var bounds, cursor, display;
    // We do some special logic to position windows based on the position of the
    // mouse cursor, to avoid frustration when working with multiple monitors.
    // We regard the mouse to be occupying the "current" monitor.
    cursor = screen.getCursorScreenPoint();
    display = screen.getDisplayNearestPoint(cursor).bounds;
    // The Setup Assistant is handled specially.
    // It should always appear centered on the current monitor.
    if (type === "setup-assistant") {
      bounds = defaultBounds[type];
      bounds.x = display.x + display.width / 2 - bounds.width / 2;
      bounds.y = display.y + display.height / 2 - bounds.height / 2;
      return bounds;
    }
    // For other types of windows, we'll first try to load the
    // last-used position for this instance (by index) of this type of window
    bounds = windowBounds[type][index];
    if (bounds != null) {
      return bounds;
    }
    // We don't have a last-used position, so let's set up a new one.
    bounds = defaultBounds[type];
    if (type === "db") {
      // By default, the db should appear in the top left of the current monitor.
      bounds.x = display.x;
      bounds.y = display.y;
    } else if (type === "browser" && index === 0) {
      // The first instance of the browser window should appear centered on the current monitor.
      bounds.x = display.x + display.width / 2 - bounds.width / 2;
      bounds.y = display.y + display.height / 2 - bounds.height / 2;
    } else {
      // All other windows should appear near the mouse cursor.
      bounds.x = cursor.x - 74;
      bounds.y = cursor.y - 16;
    }
    return bounds;
  };
  checkBounds = function(win) {
    var bounds, j, len1, otherBounds, otherWindow, ref;
    bounds = win.getBounds();
    ref = BrowserWindow.getAllWindows();
    for (j = 0, len1 = ref.length; j < len1; j++) {
      otherWindow = ref[j];
      if (!(otherWindow !== win && otherWindow !== db)) {
        continue;
      }
      otherBounds = otherWindow.getBounds();
      if (bounds.x === otherBounds.x && bounds.y === otherBounds.y) {
        bounds.x += 22;
        bounds.y += 22;
        // We've moved our window, so we need to start checking all over again
        // TODO: There's a small risk of an infine loop here if the behaviour of
        // setBounds followed by getBounds changes and starts clipping to the window.
        // Also, we aren't matching OSX behaviour, which is to wrap.
        win.setBounds(bounds);
        checkBounds(win);
        return;
      }
    }
  };
  updateBounds = function(type, index, win) {
    windowBounds[type][index] = win.getBounds();
    return MainState("windowBounds", windowBounds);
  };
  newWindow = function(type, {tools}, props = {}) {
    var background, bounds, deferPaint, index, win;
    if (props.show !== false) {
      deferPaint = true;
      props.show = false;
    }
    index = getNextIndex(type);
    bounds = getBounds(type, index);
    background = {
      backgroundColor: nativeTheme.shouldUseDarkColors ? "#1b1b1b" : "#f2f2f2"
    };
    win = new BrowserWindow(Object.assign({}, defaultWindow, bounds, background, props));
    checkBounds(win);
    updateBounds(type, index, win);
    win.loadFile(`target/${type}.html`).catch(function(err) {
      return dialog.showMessageBox({
        message: err.message
      });
    });
    if (deferPaint) {
      win.once("ready-to-show", win.show);
    }
    win.on("move", function(e) {
      return updateBounds(type, index, win);
    });
    win.on("resize", function(e) {
      return updateBounds(type, index, win);
    });
    win.on("closed", function(e) {
      return clearIndex(type, index);
    });
    return win;
  };
  openAsset = function(assetId) {
    var win;
    win = newWindow("asset", {
      tools: false
    }, {
      title: "Asset"
    });
    windowData[win.webContents.id] = {
      assetId: assetId
    };
    return win;
  };
  openBrowser = function() {
    return newWindow("browser", {
      tools: false
    }, {
      title: "Browser",
      minWidth: 400
    });
  };
  openDb = function() {
    if (db != null) {
      db.show();
    } else {
      db = newWindow("db", {
        tools: false
      }, {
        title: "Debug Log",
        show: false //or Env.isDev
      });
      db.on("close", function(e) {
        if (!aboutToQuit) {
          e.preventDefault();
          return db.hide();
        }
      });
      Make("DBWindowReady");
    }
    return db;
  };
  openSetupAssistant = function() {
    if (setupAssistant != null) {
      setupAssistant.show();
    } else {
      setupAssistant = newWindow("setup-assistant", {
        tools: false
      }, {
        title: "Setup Assistant",
        resizable: false,
        fullscreenable: false,
        frame: false,
        titleBarStyle: "default"
      });
      setupAssistant.on("close", function(e) {
        return setupAssistant = null;
      });
    }
    return setupAssistant;
  };
  return Make("Window", Window = {
    init: function() {
      return windowBounds = MainState("windowBounds");
    },
    data: windowData,
    getDB: function() {
      if (db == null) {
        throw Error("DB window doesn't exist");
      }
      return db;
    },
    open: {
      asset: openAsset,
      browser: openBrowser,
      db: openDb,
      setupAssistant: openSetupAssistant
    },
    activate: function() {
      if (!(BrowserWindow.getAllWindows().length > 1)) {
        // TODO: If we're not done setup, open the Setup Assistant instead
        return Window.open.browser();
      }
    },
    aboutToQuit: function() {
      return aboutToQuit = true;
    }
  });
});

// main/main.coffee
Take(["Env", "Handlers", "IPC", "Log", "Menu", "MainState", "Updates", "Window"], async function(Env, Handlers, IPC, Log, Menu, MainState, Updates, Window) {
  var app;
  ({app} = require("electron"));
  if (require("electron-squirrel-startup")) {
    // Windows will launch the app multiple times during an update. We just need to quit.
    return app.quit();
  }
  // Just guessing that these might be nice. Haven't tested them at all.
  app.commandLine.appendSwitch("disable-renderer-backgrounding");
  // app.commandLine.appendSwitch "force_low_power_gpu" # Disabled while we test on Windows

  // Here's our custom config for the About box
  app.setAboutPanelOptions({
    applicationName: `Hyperzine ${Env.version.replace(/(\d\.\d)\.0/, "$1")}`,
    applicationVersion: [`Electron ${Env.versions.electron.split(".")[0]}`, `Chrome ${Env.versions.chrome.split(".")[0]}`, `Node ${Env.versions.node.split(".")[0]}`].join(" â€¢ "),
    version: "",
    copyright: "Created by Ivan Reese\nÂ© CD Industrial Group Inc."
  });
  // While we're waiting for electron to get ready, we can load our persisted main state (if any).
  MainState.init();
  Window.init();
  // Wait for ready before doing anything substantial.
  await app.whenReady();
  // For now, we just roll with a static menu bar. In the future, we might want to change it
  // depending on which window is active.
  Menu.setup();
  // There's about to be a lot of inter-process communication (IPC). Much of it is going to be
  // windows asking the main process to do things on their behalf. So let's set up those handlers.
  Handlers.setup();
  // The first window we open is the DB, which handles all filesystem access and stores global state.
  // The instant the DB opens, it'll be ready to receive ports from other windows and help them.
  // The DB window should never be reloaded or closed, until the app quits, or it'll lose all the ports,
  // and we haven't designed the other windows to function (even temporarily) without a port to the db.
  // We queue it so that the below IPC listeners will be ready when the window actually opens.
  // (We could just call them first, but it reads better this way)
  queueMicrotask(Window.open.db);
  // When the DB window is open, we can begin logging lots of stuff
  await IPC.promise.once("db-open");
  Log(`Env.version: ${Env.version}`);
  Log(`Env.isDev: ${Env.isDev}`);
  Log(`Env.isMac: ${Env.isMac}`);
  Log(`Env.userData: ${Env.userData}`);
  Log(`Env.home: ${Env.home}`);
  // When the DB window first wakes up, it'll attempt to load saved user preferences.
  // If the DB fails to load this data, we need to open the Setup Assistant.
  // The Setup Assistant will collect user preferences and save them via the DB.
  IPC.once("open-setup-assistant", Window.open.setupAssistant);
  // Wait until either the DB has loaded the saved prefs, or the Setup Assistant has finished
  await IPC.promise.once("config-ready");
  // Everything is ready â€” open a browser window.
  // Eventually, we might want to restore whichever windows were open when we last quit
  Window.open.browser();
  // Whenever we switch to the app, let the window manager know.
  app.on("activate", Window.activate);
  // Don't move the `unless` outside the handler â€” we need to subscribe to this event to stop the default auto-close behaviour
  app.on("window-all-closed", function() {
    if (!Env.isMac) {
      return app.quit();
    }
  });
  // Set up automatic updates
  return Updates.setup();
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIuLiIsInNvdXJjZXMiOlsidGVtcC9tYWluLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBS29FOzs7O0FBQ3BFO0FBRG9FLElBQUEsYUFBQSxFQUFBLElBQUEsRUFBQSxJQUFBLEVBQUEsSUFBQSxFQUFBLEtBQUE7RUFBQTs7O0FBSXBFLE1BQU8sOENBQUEsSUFBUywrQ0FBaEI7OztFQUlFLElBQUEsR0FBTztFQUNQLElBQUEsR0FBTztFQUNQLGFBQUEsR0FBZ0I7RUFFYixDQUFBLFFBQUEsQ0FBQSxDQUFBO0FBRUwsUUFBQSxXQUFBLEVBQUEsY0FBQSxFQUFBLGVBQUEsRUFBQSxzQkFBQSxFQUFBLG1CQUFBLEVBQUEsa0JBQUEsRUFBQSxLQUFBLEVBQUEsSUFBQSxFQUFBLGdCQUFBLEVBQUEsY0FBQSxFQUFBLE1BQUEsRUFBQSxZQUFBLEVBQUEsUUFBQSxFQUFBLE9BQUEsRUFBQSxrQkFBQSxFQUFBLGNBQUEsRUFBQTtJQUFJLElBQUEsR0FBTyxDQUFBO0lBQ1AsYUFBQSxHQUFnQjtJQUNoQixjQUFBLEdBQWlCO0lBQ2pCLHNCQUFBLEdBQXlCO0lBQ3pCLGVBQUEsR0FBa0I7SUFDbEIsZ0JBQUEsR0FBbUI7SUFDbkIsY0FBQSxHQUFpQjtJQUVqQixJQUFBLEdBQU8sUUFBQSxDQUFDLElBQUQsRUFBTyxRQUFRLElBQWYsQ0FBQTtNQUVMLElBQXlCLFlBQXpCOztBQUFBLGVBQU8sS0FBQSxDQUFNLElBQU4sRUFBUDtPQUROOzthQUlNLFFBQUEsQ0FBUyxJQUFULEVBQWUsS0FBZjtJQUxLO0lBUVAsSUFBQSxHQUFPLFFBQUEsQ0FBQyxLQUFELEVBQVEsUUFBUixDQUFBO01BRUwsSUFBb0MsYUFBcEM7O0FBQUEsZUFBTyxhQUFhLENBQUMsS0FBZCxDQUFBLEVBQVA7T0FETjs7YUFJTSxPQUFBLENBQVEsS0FBUixFQUFlLFFBQWY7SUFMSyxFQWhCWDs7SUF5QkksSUFBSSxDQUFDLEtBQUwsR0FBYSxRQUFBLENB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SSxDQUFBLFVBQUEsQ0FBQSxDQUFhLEdBQUcsQ0FBQyxJQUFqQixDQUFBLENBQUosRUFqREY7Ozs7RUFzREUsR0FBRyxDQUFDLElBQUosQ0FBUyxzQkFBVCxFQUFpQyxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQTdDLEVBdERGOztFQXlERSxNQUFNLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBWixDQUFpQixjQUFqQixFQXpEUjs7O0VBNkRFLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBWixDQUFBLEVBN0RGOztFQWdFRSxHQUFHLENBQUMsRUFBSixDQUFPLFVBQVAsRUFBbUIsTUFBTSxDQUFDLFFBQTFCLEVBaEVGOztFQW1FRSxHQUFHLENBQUMsRUFBSixDQUFPLG1CQUFQLEVBQTRCLFFBQUEsQ0FBQSxDQUFBO0lBQUssS0FBa0IsR0FBRyxDQUFDLEtBQXRCO2FBQUEsR0FBRyxDQUFDLElBQUosQ0FBQSxFQUFBOztFQUFMLENBQTVCLEVBbkVGOztTQXNFRSxPQUFPLENBQUMsS0FBUixDQUFBO0FBdkVnRixDQUFsRiIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4jIG5vZGVfbW9kdWxlcy90YWtlLWFuZC1tYWtlL3NvdXJjZS90YWtlLWFuZC1tYWtlLmNvZmZlZVxuIyBTaW5jZSB0aGlzIGlzIHR5cGljYWxseSB0aGUgZmlyc3QgYml0IG9mIGNvZGUgaW5jbHVkZWQgaW4gb3VyIGJpZyBjb21waWxlZCBhbmRcbiMgY29uY2F0ZW5hdGVkIEpTIGZpbGVzLCB0aGlzIGlzIGEgZ3JlYXQgcGxhY2UgdG8gZGVtYW5kIHN0cmljdG5lc3MuIENvZmZlZVNjcmlwdFxuIyBkb2VzIG5vdCBhZGQgc3RyaWN0IG9uIGl0cyBvd24sIGJ1dCBpdCB3aWxsIHBlcm1pdCBhbmQgZW5mb3JjZSBpdC5cblwidXNlIHN0cmljdFwiO1xuXG4jIEJhaWwgaWYgVGFrZSZNYWtlIGlzIGFscmVhZHkgcnVubmluZyBpbiB0aGlzIHNjb3BlLCBvciBpZiBzb21ldGhpbmcgZWxzZSBpcyB1c2luZyBvdXIgbmFtZXNcbnVubGVzcyBUYWtlPyBvciBNYWtlP1xuXG4gICMgV2UgZGVjbGFyZSBvdXIgZ2xvYmFscyBzdWNoIHRoYXQgdGhleSdyZSB2aXNpYmxlIGV2ZXJ5d2hlcmUgd2l0aGluIHRoZSBjdXJyZW50IHNjb3BlLlxuICAjIFRoaXMgYWxsb3dzIGZvciBuYW1lc3BhY2luZyDigJQgYWxsIHRoaW5ncyB3aXRoaW4gYSBnaXZlbiBzY29wZSBzaGFyZSBhIGNvcHkgb2YgVGFrZSAmIE1ha2UuXG4gIFRha2UgPSBudWxsXG4gIE1ha2UgPSBudWxsXG4gIERlYnVnVGFrZU1ha2UgPSBudWxsXG5cbiAgZG8gKCktPlxuXG4gICAgbWFkZSA9IHt9XG4gICAgd2FpdGluZ1Rha2VycyA9IFtdXG4gICAgdGFrZXJzVG9Ob3RpZnkgPSBbXVxuICAgIGFscmVhZHlXYWl0aW5nVG9Ob3RpZnkgPSBmYWxzZVxuICAgIGFscmVhZHlDaGVja2luZyA9IGZhbHNlXG4gICAgbWljcm90YXNrc05lZWRlZCA9IDBcbiAgICBtaWNyb3Rhc2tzVXNlZCA9IDBcblxuICAgIE1ha2UgPSAobmFtZSwgdmFsdWUgPSBuYW1lKS0+XG4gICAgICAjIERlYnVnIOKAlCBjYWxsIE1ha2UoKSBpbiB0aGUgY29uc29sZSB0byBzZWUgd2hhdCB3ZSd2ZSByZWdzdGVyZWRcbiAgICAgIHJldHVybiBjbG9uZSBtYWRlIGlmIG5vdCBuYW1lP1xuXG4gICAgICAjIFN5bmNocm9ub3VzIHJlZ2lzdGVyLCByZXR1cm5zIHZhbHVlXG4gICAgICByZWdpc3RlciBuYW1lLCB2YWx1ZVxuXG5cbiAgICBUYWtlID0gKG5lZWRzLCBjYWxsYmFjayktPlxuICAgICAgIyBEZWJ1ZyDigJQgY2FsbCBUYWtlKCkgaW4gdGhlIGNvbnNvbGUgdG8gc2VlIHdoYXQgd2UncmUgd2FpdGluZyBmb3JcbiAgICAgIHJldHVybiB3YWl0aW5nVGFrZXJzLnNsaWNlKCkgaWYgbm90IG5lZWRzP1xuXG4gICAgICAjIFN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXMgcmVzb2x2ZSwgcmV0dXJucyB2YWx1ZSBvciBvYmplY3Qgb2YgdmFsdWVzXG4gICAgICByZXNvbHZlIG5lZWRzLCBjYWxsYmFja1xuXG5cbiAgICAjIEEgdmFyaWF0aW9uIG9mIE1ha2UgdGhhdCBkZWZlcnMgY29tbWl0dGluZyB0aGUgdmFsdWVcbiAgICBNYWtlLmFzeW5jID0gKG5hbWUsIHZhbHVlID0gbmFtZSktPlxuICAgICAgcXVldWVNaWNyb3Rhc2sgKCktPlxuICAgICAgICBNYWtlIG5hbWUsIHZhbHVlXG5cblxuICAgICMgQSB2YXJpYXRpb24gb2YgVGFrZSB0aGF0IHJldHVybnMgYSBwcm9taXNlXG4gICAgVGFrZS5hc3luYyA9IChuZWVkcyktPlxuICAgICAgbmV3IFByb21pc2UgKHJlcyktPlxuICAgICAgICBUYWtlIG5lZWRzLCAoKS0+XG4gICAgICAgICAgIyBSZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggYSB2YWx1ZSBvciBvYmplY3Qgb2YgdmFsdWVzXG4gICAgICAgICAgcmVzIHN5bmNocm9ub3VzUmVzb2x2ZSBuZWVkc1xuXG5cbiAgICBEZWJ1Z1Rha2VNYWtlID0gKCktPlxuICAgICAgb3V0cHV0ID1cbiAgICAgICAgbWljcm90YXNrc05lZWRlZDogbWljcm90YXNrc05lZWRlZFxuICAgICAgICBtaWNyb3Rhc2tzVXNlZDogbWljcm90YXNrc1VzZWRcbiAgICAgICAgdW5yZXNvbHZlZDoge31cbiAgICAgIGZvciB3YWl0aW5nIGluIHdhaXRpbmdUYWtlcnNcbiAgICAgICAgZm9yIG5lZWQgaW4gd2FpdGluZy5uZWVkc1xuICAgICAgICAgIHVubGVzcyBtYWRlW25lZWRdP1xuICAgICAgICAgICAgb3V0cHV0LnVucmVzb2x2ZWRbbmVlZF0gPz0gMFxuICAgICAgICAgICAgb3V0cHV0LnVucmVzb2x2ZWRbbmVlZF0rK1xuICAgICAgcmV0dXJuIG91dHB1dFxuXG5cbiAgICByZWdpc3RlciA9IChuYW1lLCB2YWx1ZSktPlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG1heSBub3QgTWFrZShcXFwiXFxcIikgYW4gZW1wdHkgc3RyaW5nLlwiKSBpZiBuYW1lIGlzIFwiXCJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtYXkgbm90IE1ha2UoKSB0aGUgc2FtZSBuYW1lIHR3aWNlOiAje25hbWV9XCIpIGlmIG1hZGVbbmFtZV0/XG4gICAgICBtYWRlW25hbWVdID0gdmFsdWVcbiAgICAgIGNoZWNrV2FpdGluZ1Rha2VycygpXG4gICAgICB2YWx1ZVxuXG5cbiAgICBjaGVja1dhaXRpbmdUYWtlcnMgPSAoKS0+XG4gICAgICByZXR1cm4gaWYgYWxyZWFkeUNoZWNraW5nICMgUHJldmVudCByZWN1cnNpb24gZnJvbSBNYWtlKCkgY2FsbHMgaW5zaWRlIG5vdGlmeSgpXG4gICAgICBhbHJlYWR5Q2hlY2tpbmcgPSB0cnVlXG5cbiAgICAgICMgQ29tbWVudHMgYmVsb3cgYXJlIHRvIGhlbHAgcmVhc29uIHRocm91Z2ggdGhlIChwb3RlbnRpYWxseSkgcmVjdXJzaXZlIGJlaGF2aW91clxuXG4gICAgICBmb3IgdGFrZXIsIGluZGV4IGluIHdhaXRpbmdUYWtlcnMgIyBEZXBlbmRzIG9uIGB3YWl0aW5nVGFrZXJzYFxuICAgICAgICBpZiBhbGxOZWVkc0FyZU1ldCh0YWtlci5uZWVkcykgIyBEZXBlbmRzIG9uIGBtYWRlYFxuICAgICAgICAgIHdhaXRpbmdUYWtlcnMuc3BsaWNlKGluZGV4LCAxKSAjIE11dGF0ZXMgYHdhaXRpbmdUYWtlcnNgXG4gICAgICAgICAgbm90aWZ5KHRha2VyKSAjIENhbGxzIHRvIE1ha2UoKSBvciBUYWtlKCkgd2lsbCBtdXRhdGUgYG1hZGVgIG9yIGB3YWl0aW5nVGFrZXJzYFxuICAgICAgICAgIGFscmVhZHlDaGVja2luZyA9IGZhbHNlXG4gICAgICAgICAgcmV0dXJuIGNoZWNrV2FpdGluZ1Rha2VycygpICMgUmVzdGFydDogYHdhaXRpbmdUYWtlcnNgIChhbmQgcG9zc2libHkgYG1hZGVgKSB3ZXJlIG11dGF0ZWRcblxuICAgICAgYWxyZWFkeUNoZWNraW5nID0gZmFsc2VcblxuXG4gICAgYWxsTmVlZHNBcmVNZXQgPSAobmVlZHMpLT5cbiAgICAgIHJldHVybiBuZWVkcy5ldmVyeSAobmFtZSktPiBtYWRlW25hbWVdP1xuXG5cbiAgICByZXNvbHZlID0gKG5lZWRzLCBjYWxsYmFjayktPlxuICAgICAgIyBXZSBhbHdheXMgdHJ5IHRvIHJlc29sdmUgYm90aCBzeW5jaHJvbm91c2x5IGFuZCBhc3luY2hyb25vdXNseVxuICAgICAgYXN5bmNocm9ub3VzUmVzb2x2ZSBuZWVkcywgY2FsbGJhY2sgaWYgY2FsbGJhY2s/XG4gICAgICBzeW5jaHJvbm91c1Jlc29sdmUgbmVlZHNcblxuXG4gICAgYXN5bmNocm9ub3VzUmVzb2x2ZSA9IChuZWVkcywgY2FsbGJhY2spLT5cbiAgICAgIGlmIG5lZWRzIGlzIFwiXCJcbiAgICAgICAgbmVlZHMgPSBbXVxuICAgICAgZWxzZSBpZiB0eXBlb2YgbmVlZHMgaXMgXCJzdHJpbmdcIlxuICAgICAgICBuZWVkcyA9IFtuZWVkc11cblxuICAgICAgdGFrZXIgPSBuZWVkczogbmVlZHMsIGNhbGxiYWNrOiBjYWxsYmFja1xuXG4gICAgICBpZiBhbGxOZWVkc0FyZU1ldCBuZWVkc1xuICAgICAgICB0YWtlcnNUb05vdGlmeS5wdXNoIHRha2VyXG4gICAgICAgIG1pY3JvdGFza3NOZWVkZWQrK1xuICAgICAgICB1bmxlc3MgYWxyZWFkeVdhaXRpbmdUb05vdGlmeVxuICAgICAgICAgIGFscmVhZHlXYWl0aW5nVG9Ob3RpZnkgPSB0cnVlXG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2sgbm90aWZ5VGFrZXJzICMgUHJlc2VydmUgYXN5bmNocm9ueVxuICAgICAgICAgIG1pY3JvdGFza3NVc2VkKytcbiAgICAgIGVsc2VcbiAgICAgICAgd2FpdGluZ1Rha2Vycy5wdXNoIHRha2VyXG5cblxuICAgIHN5bmNocm9ub3VzUmVzb2x2ZSA9IChuZWVkcyktPlxuICAgICAgaWYgdHlwZW9mIG5lZWRzIGlzIFwic3RyaW5nXCJcbiAgICAgICAgcmV0dXJuIG1hZGVbbmVlZHNdXG4gICAgICBlbHNlXG4gICAgICAgIG8gPSB7fVxuICAgICAgICBvW25dID0gbWFkZVtuXSBmb3IgbiBpbiBuZWVkc1xuICAgICAgICByZXR1cm4gb1xuXG5cbiAgICBub3RpZnlUYWtlcnMgPSAoKS0+XG4gICAgICBhbHJlYWR5V2FpdGluZ1RvTm90aWZ5ID0gZmFsc2VcbiAgICAgIHRha2VycyA9IHRha2Vyc1RvTm90aWZ5XG4gICAgICB0YWtlcnNUb05vdGlmeSA9IFtdXG4gICAgICBub3RpZnkgdGFrZXIgZm9yIHRha2VyIGluIHRha2Vyc1xuICAgICAgbnVsbFxuXG5cbiAgICBub3RpZnkgPSAodGFrZXIpLT5cbiAgICAgIHJlc29sdmVkTmVlZHMgPSB0YWtlci5uZWVkcy5tYXAgKG5hbWUpLT4gbWFkZVtuYW1lXVxuICAgICAgdGFrZXIuY2FsbGJhY2suYXBwbHkobnVsbCwgcmVzb2x2ZWROZWVkcylcblxuXG4gICAgIyBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBPYmplY3QuYXNzaWduKHt9LCBvYmopLCBzbyB3ZSBqdXN0IHVzZSBvdXIgb3duXG4gICAgY2xvbmUgPSAob2JqKS0+XG4gICAgICBvdXQgPSB7fVxuICAgICAgb3V0W2tdID0gdiBmb3Igayx2IG9mIG9ialxuICAgICAgb3V0XG5cblxuICAgICMgV2Ugd2FudCB0byBhZGQgYSBmZXcgaGFuZHkgb25lLXRpbWUgZXZlbnRzLlxuICAgICMgSG93ZXZlciwgd2UgZG9uJ3Qga25vdyBpZiB3ZSdsbCBiZSBydW5uaW5nIGluIGEgYnJvd3Nlciwgb3IgaW4gbm9kZS5cbiAgICAjIFRodXMsIHdlIGxvb2sgZm9yIHRoZSBwcmVzZW5jZSBvZiBhIFwid2luZG93XCIgb2JqZWN0IGFzIG91ciBjbHVlLlxuICAgIGlmIHdpbmRvdz9cblxuICAgICAgYWRkTGlzdGVuZXIgPSAoZXZlbnROYW1lKS0+XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIGV2ZW50TmFtZSwgaGFuZGxlciA9IChldmVudE9iamVjdCktPlxuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyIGV2ZW50TmFtZSwgaGFuZGxlclxuICAgICAgICAgIE1ha2UgZXZlbnROYW1lLCBldmVudE9iamVjdFxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQgIyBwcmV2ZW50IHVubG9hZCBmcm9tIG9wZW5pbmcgYSBwb3B1cFxuXG4gICAgICBhZGRMaXN0ZW5lciBcImJlZm9yZXVubG9hZFwiXG4gICAgICBhZGRMaXN0ZW5lciBcImNsaWNrXCJcbiAgICAgIGFkZExpc3RlbmVyIFwidW5sb2FkXCJcblxuICAgICAgIyBTaW5jZSB3ZSBoYXZlIGEgd2luZG93IG9iamVjdCwgaXQncyBwcm9iYWJseSBzYWZlIHRvIGFzc3VtZSB3ZSBoYXZlIGEgZG9jdW1lbnQgb2JqZWN0XG4gICAgICBzd2l0Y2ggZG9jdW1lbnQucmVhZHlTdGF0ZVxuICAgICAgICB3aGVuIFwibG9hZGluZ1wiXG4gICAgICAgICAgYWRkTGlzdGVuZXIgXCJET01Db250ZW50TG9hZGVkXCJcbiAgICAgICAgICBhZGRMaXN0ZW5lciBcImxvYWRcIlxuICAgICAgICB3aGVuIFwiaW50ZXJhY3RpdmVcIlxuICAgICAgICAgIE1ha2UgXCJET01Db250ZW50TG9hZGVkXCJcbiAgICAgICAgICBhZGRMaXN0ZW5lciBcImxvYWRcIlxuICAgICAgICB3aGVuIFwiY29tcGxldGVcIlxuICAgICAgICAgIE1ha2UgXCJET01Db250ZW50TG9hZGVkXCJcbiAgICAgICAgICBNYWtlIFwibG9hZFwiXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IgXCJVbmtub3duIGRvY3VtZW50LnJlYWR5U3RhdGU6ICN7ZG9jdW1lbnQucmVhZHlTdGF0ZX0uIENhbm5vdCBzZXR1cCBUYWtlJk1ha2UuXCJcblxuXG4gICAgIyBGaW5hbGx5LCB3ZSdyZSByZWFkeSB0byBoYW5kIG92ZXIgY29udHJvbCB0byBtb2R1bGUgc3lzdGVtc1xuICAgIGlmIG1vZHVsZT9cbiAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBUYWtlOiBUYWtlLFxuICAgICAgICBNYWtlOiBNYWtlLFxuICAgICAgICBEZWJ1Z1Rha2VNYWtlOiBEZWJ1Z1Rha2VNYWtlXG4gICAgICB9XG5cblxuIyBzdWJtb2R1bGUvYnVja2V0L2Fkc3IuY29mZmVlXG4jIEFEU1JcbiMgVGhpcyBnaXZlcyB5b3VyIGZ1bmN0aW9uIGFuIFwiYXR0YWNrXCIgcGhhc2UgYW5kIGEgXCJyZWxlYXNlXCIgcGhhc2VcbiMgKGJvcnJvd2luZyB0ZXJtaW5vbG9neSBmcm9tIEFEU1Igb24gc3ludGhlc2l6ZXJzKS5cbiMgVGhlIGF0dGFjayBwaGFzZSBpcyBhIGRlYm91bmNlIOKAlCB5b3VyIGZ1bmN0aW9uIHdpbGwgcnVuIGp1c3Qgb25jZSBhZnRlciB0aGUgYXR0YWNrIHBoYXNlIGVuZHMsXG4jIG5vIG1hdHRlciBob3cgbWFueSB0aW1lcyBpdCdzIGNhbGxlZCB1bnRpbCB0aGVuLlxuIyBXaGVuIHRoZSBmdW5jdGlvbiBydW5zLCBpdCdsbCB1c2UgdGhlIGFyZ3MgZnJvbSB0aGUgbW9zdCByZWNlbnQgdGltZSBpdCB3YXMgY2FsbGVkLlxuIyBUaGUgcmVsZWFzZSBpcyBhIHRocm90dGxlIOKAlCBpZiB5b3VyIGZ1bmN0aW9uIGlzIGNhbGxlZCBkdXJpbmcgdGhlIHJlbGVhc2UgcGhhc2UsXG4jIHRoZW4gYWZ0ZXIgdGhlIHJlbGVhc2UgcGhhc2UgZW5kcyB0aGUgYXR0YWNrIHBoYXNlIHdpbGwgc3RhcnQgb3ZlciBhZ2Fpbi5cbiMgVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcnVuIHNob3J0bHkgYWZ0ZXIgaXQncyBjYWxsZWQgKGdvb2QgZm9yIGZhc3QgcmVhY3Rpb25zKVxuIyBidXQgZG9lc24ndCBydW4gYWdhaW4gdW50aWwgYSB3aGlsZSBsYXRlciAoZ29vZCBmb3IgcmVkdWNpbmcgc3RyYWluKS5cbiMgQXR0YWNrIGFuZCByZWxlYXNlIGFyZSBzcGVjaWZpZWQgaW4gbXMsIGFuZCBhcmUgb3B0aW9uYWwuXG4jIElmIHlvdSBwYXNzIGEgdGltZSBvZiAwIG1zIGZvciBlaXRoZXIgdGhlIGF0dGFjaywgcmVsZWFzZSwgb3IgYm90aCwgdGhlIHBoYXNlIHdpbGwgbGFzdCB1bnRpbCB0aGUgbmV4dCBtaWNyb3Rhc2suXG4jIElmIHlvdSBwYXNzIGEgdGltZSBsZXNzIHRoYW4gNSBtcywgdGhlIHBoYXNlIHdpbGwgbGFzdCB1bnRpbCB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuXG4jIEl0J3MgaWRpb21hdGljIHRvIHBhc3MgYSB0aW1lIG9mIDEgbXMgaWYgeW91IHdhbnQgdGhlIG5leHQgZnJhbWUuXG4jIFdlIGFsc28ga2VlcCBhIGNvdW50IG9mIGhvdyBtYW55IGZ1bmN0aW9ucyBhcmUgY3VycmVudGx5IHdhaXRpbmcsIGFuZCBzdXBwb3J0IGFkZGluZyB3YXRjaGVyc1xuIyB0aGF0IHdpbGwgcnVuIGEgY2FsbGJhY2sgd2hlbiB0aGUgY291bnQgY2hhbmdlcywganVzdCBpbiBjYXNlIHlvdSB3YW50IHRvIChmb3IgZXhhbXBsZSlcbiMgd2FpdCBmb3IgdGhlbSBhbGwgdG8gZmluaXNoIGJlZm9yZSBxdWl0dGluZyAvIGNsb3NpbmcsIG9yIG1vbml0b3IgdGhlaXIgcGVyZm9ybWFuY2UuXG5cblRha2UgW10sICgpLT5cblxuICBhY3RpdmUgPSBuZXcgTWFwKClcbiAgd2F0Y2hlcnMgPSBbXVxuXG4gIE1ha2UuYXN5bmMgXCJBRFNSXCIsIEFEU1IgPSAoLi4uW2F0dGFjayA9IDAsIHJlbGVhc2UgPSAwXSwgZm4pLT4gKC4uLmFyZ3MpLT5cbiAgICBpZiBub3QgYWN0aXZlLmhhcyBmblxuICAgICAgYWZ0ZXJEZWxheSBhdHRhY2ssIGFmdGVyQXR0YWNrIGZuLCBhdHRhY2ssIHJlbGVhc2VcbiAgICAgIEFEU1IuY291bnQrK1xuICAgICAgdXBkYXRlV2F0Y2hlcnMoKVxuICAgIGFjdGl2ZS5zZXQgZm4sIHthcmdzfSAjIEFsd2F5cyB1c2UgdGhlIG1vc3QgcmVjZW50IGFyZ3NcblxuICBBRFNSLmNvdW50ID0gMFxuXG4gIEFEU1Iud2F0Y2hlciA9ICh3YXRjaGVyKS0+XG4gICAgd2F0Y2hlcnMucHVzaCB3YXRjaGVyXG5cbiAgYWZ0ZXJBdHRhY2sgPSAoZm4sIGF0dGFjaywgcmVsZWFzZSktPiAoKS0+XG4gICAge2FyZ3N9ID0gYWN0aXZlLmdldCBmblxuICAgIGFjdGl2ZS5zZXQgZm4sIHt9XG4gICAgZm4gLi4uYXJnc1xuICAgIGFmdGVyRGVsYXkgcmVsZWFzZSwgYWZ0ZXJSZWxlYXNlIGZuLCBhdHRhY2ssIHJlbGVhc2VcblxuICBhZnRlclJlbGVhc2UgPSAoZm4sIGF0dGFjaywgcmVsZWFzZSktPiAoKS0+XG4gICAge2FyZ3N9ID0gYWN0aXZlLmdldCBmblxuICAgIGlmIGFyZ3NcbiAgICAgIGFmdGVyRGVsYXkgYXR0YWNrLCBhZnRlckF0dGFjayBmbiwgYXR0YWNrLCByZWxlYXNlXG4gICAgZWxzZVxuICAgICAgYWN0aXZlLmRlbGV0ZSBmblxuICAgICAgQURTUi5jb3VudC0tXG4gICAgICB1cGRhdGVXYXRjaGVycygpXG5cbiAgYWZ0ZXJEZWxheSA9IChkZWxheSA9IDAsIGNiKS0+XG4gICAgaWYgZGVsYXkgaXMgMFxuICAgICAgcXVldWVNaWNyb3Rhc2sgY2JcbiAgICBlbHNlIGlmIGRlbGF5IDwgNVxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGNiXG4gICAgZWxzZVxuICAgICAgc2V0VGltZW91dCBjYiwgZGVsYXlcblxuICB1cGRhdGVXYXRjaGVycyA9ICgpLT5cbiAgICB3YXRjaGVyIEFEU1IuY291bnQgZm9yIHdhdGNoZXIgaW4gd2F0Y2hlcnNcbiAgICBudWxsXG5cblxuIyBzdWJtb2R1bGUvYnVja2V0L21vbmtleS1wYXRjaC5jb2ZmZWVcbiMgTW9ua2V5IFBhdGNoXG4jIFRoZSBKUyBzdGFuZGFyZCBsaWJyYXJ5IGxlYXZlcyBhIGxvdCB0byBiZSBkZXNpcmVkLCBzbyBsZXQncyBjYXJlZnVsbHkgKHNlZSBib3R0b20gb2YgZmlsZSlcbiMgbW9kaWZ5IHRoZSBidWlsdC1pbiBjbGFzc2VzIHRvIGFkZCBhIGZldyBoZWxwZnVsIG1ldGhvZHMuXG5cbmRvICgpLT5cbiAgbW9ua2V5UGF0Y2hlcyA9XG5cbiAgICBBcnJheTpcbiAgICAgIHR5cGU6ICh2KS0+IHYgaW5zdGFuY2VvZiBBcnJheVxuXG4gICAgICAjIFNvcnRpbmdcbiAgICAgIG51bWVyaWNTb3J0QXNjZW5kaW5nOiAoYSwgYiktPiBhIC0gYlxuICAgICAgbnVtZXJpY1NvcnREZXNjZW5kaW5nOiAoYSwgYiktPiBiIC0gYVxuICAgICAgc29ydEFscGhhYmV0aWM6IChhcnIpLT4gYXJyLnNvcnQgQXJyYXkuYWxwaGFiZXRpY1NvcnQgPz0gbmV3IEludGwuQ29sbGF0b3IoJ2VuJykuY29tcGFyZVxuICAgICAgc29ydE51bWVyaWNBc2NlbmRpbmc6IChhcnIpLT4gYXJyLnNvcnQgQXJyYXkubnVtZXJpY1NvcnRBc2NlbmRpbmdcbiAgICAgIHNvcnROdW1lcmljRGVzY2VuZGluZzogKGFyciktPiBhcnIuc29ydCBBcnJheS5udW1lcmljU29ydERlc2NlbmRpbmdcblxuICAgICAgIyBBY2Nlc3NpbmdcbiAgICAgIGZpcnN0OiAoYXJyKS0+IGFyclswXVxuICAgICAgc2Vjb25kOiAoYXJyKS0+IGFyclsxXVxuICAgICAgbGFzdDogKGFyciktPiBhcnJbYXJyLmxlbmd0aC0xXVxuICAgICAgcmVzdDogKGFyciktPiBhcnJbMS4uLl1cbiAgICAgIGJ1dExhc3Q6IChhcnIpLT4gYXJyWy4uLi0xXVxuXG4gICAgICAjIE1pc2NcblxuICAgICAgY2xvbmU6IChhcnIpLT5cbiAgICAgICAgYXJyLm1hcCBGdW5jdGlvbi5jbG9uZVxuXG4gICAgICBlbXB0eTogKGFyciktPlxuICAgICAgICBub3QgYXJyPyBvciBhcnIubGVuZ3RoIGlzIDBcblxuICAgICAgZXF1YWw6IChhLCBiKS0+XG4gICAgICAgIHJldHVybiB0cnVlIGlmIE9iamVjdC5pcyBhLCBiXG4gICAgICAgIHJldHVybiBmYWxzZSB1bmxlc3MgQXJyYXkudHlwZShhKSBhbmQgQXJyYXkudHlwZShiKSBhbmQgYS5sZW5ndGggaXMgYi5sZW5ndGhcbiAgICAgICAgZm9yIGFpLCBpIGluIGFcbiAgICAgICAgICBiaSA9IGJbaV1cbiAgICAgICAgICBpZiBGdW5jdGlvbi5lcXVhbCBhaSwgYmlcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgIG1hcFRvT2JqZWN0OiAoYXJyLCBmbiA9IEZ1bmN0aW9uLmlkZW50aXR5KS0+XG4gICAgICAgIG8gPSB7fVxuICAgICAgICBvW2tdID0gZm4gayBmb3IgayBpbiBhcnJcbiAgICAgICAgb1xuXG4gICAgICBwdWxsOiAoYXJyLCBlbG1zKS0+XG4gICAgICAgIHJldHVybiB1bmxlc3MgYXJyPyBhbmQgZWxtcz9cbiAgICAgICAgZWxtcyA9IFtlbG1zXSB1bmxlc3MgQXJyYXkudHlwZSBlbG1zXG4gICAgICAgIGZvciBlbG0gaW4gZWxtc1xuICAgICAgICAgIHdoaWxlIChpID0gYXJyLmluZGV4T2YgZWxtKSA+IC0xXG4gICAgICAgICAgICBhcnIuc3BsaWNlIGksIDFcbiAgICAgICAgYXJyXG5cbiAgICAgIHNlYXJjaDogKGFyciwga2V5KS0+XG4gICAgICAgIGZvciB2IGluIGFyclxuICAgICAgICAgIGlmIEFycmF5LnR5cGUgdlxuICAgICAgICAgICAgcmV0dXJuIHRydWUgaWYgQXJyYXkuc2VhcmNoIHYsIGtleVxuICAgICAgICAgIGVsc2UgaWYgT2JqZWN0LnR5cGUgdlxuICAgICAgICAgICAgcmV0dXJuIHRydWUgaWYgT2JqZWN0LnNlYXJjaCB2LCBrZXlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgIHNodWZmbGU6IChhcnIpLT5cbiAgICAgICAgbmV3QXJyID0gW11cbiAgICAgICAgZm9yIGl0ZW0sIGkgaW4gYXJyXG4gICAgICAgICAgbmV3QXJyLnNwbGljZSBNYXRoLnJhbmRJbnQoMCwgbmV3QXJyLmxlbmd0aCksIDAsIGl0ZW1cbiAgICAgICAgcmV0dXJuIG5ld0FyclxuXG4gICAgICB1bmlxdWU6IChlbGVtZW50cyktPlxuICAgICAgICBBcnJheS5mcm9tIG5ldyBTZXQgW10uY29uY2F0IGVsZW1lbnRzXG5cblxuICAgIEZ1bmN0aW9uOlxuICAgICAgdHlwZTogKHYpLT4gdiBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICBpZGVudGl0eTogKHYpLT4gdlxuXG4gICAgICBleGlzdHM6IChlKS0+IGU/XG4gICAgICBub3RFeGlzdHM6IChlKS0+ICFlP1xuICAgICAgaXM6IChhLCBiKS0+IGEgaXMgYlxuICAgICAgaXNudDogKGEsIGIpLT4gYSBpc250IGJcbiAgICAgIGVxdWFsOiAoYSwgYiktPlxuICAgICAgICBpZiBPYmplY3QuaXMgYSwgYlxuICAgICAgICAgIHRydWVcbiAgICAgICAgZWxzZSBpZiBBcnJheS50eXBlKGEpIGFuZCBBcnJheS50eXBlKGIpXG4gICAgICAgICAgdHJ1ZSBpZiBBcnJheS5lcXVhbCBhLCBiXG4gICAgICAgIGVsc2UgaWYgT2JqZWN0LnR5cGUoYSkgYW5kIE9iamVjdC50eXBlKGIpXG4gICAgICAgICAgdHJ1ZSBpZiBPYmplY3QuZXF1YWwgYSwgYlxuICAgICAgICBlbHNlXG4gICAgICAgICAgZmFsc2VcbiAgICAgIGVxdWl2YWxlbnQ6IChhLCBiKS0+IGBhID09IGJgIG9yIEZ1bmN0aW9uLmVxdWFsIGEsIGIgIyBMaWtlIGVxdWFsLCBidXQgYWxzbyBlcXVhdGVzIG51bGwgJiB1bmRlZmluZWQsIC0wICYgMCwgZXRjXG4gICAgICBub3RFcXVhbDogKGEsIGIpLT4gIUZ1bmN0aW9uLmVxdWFsIGEsIGJcbiAgICAgIG5vdEVxdWl2YWxlbnQ6IChhLCBiKS0+ICFGdW5jdGlvbi5lcXVpdmFsZW50IGEsIGJcblxuICAgICAgY2xvbmU6ICh2KS0+XG4gICAgICAgIGlmIG5vdCB2P1xuICAgICAgICAgIHZcbiAgICAgICAgZWxzZSBpZiBGdW5jdGlvbi50eXBlIHZcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IgXCJJZiB5b3UgbmVlZCB0byBjbG9uZSBmdW5jdGlvbnMsIHVzZSBhIGN1c3RvbSBjbG9uZXJcIlxuICAgICAgICBlbHNlIGlmIFByb21pc2UudHlwZSB2XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yIFwiSWYgeW91IG5lZWQgdG8gY2xvbmUgcHJvbWlzZXMsIHVzZSBhIGN1c3RvbSBjbG9uZXJcIlxuICAgICAgICBlbHNlIGlmIEFycmF5LnR5cGUgdlxuICAgICAgICAgIEFycmF5LmNsb25lIHZcbiAgICAgICAgZWxzZSBpZiBPYmplY3QudHlwZSB2XG4gICAgICAgICAgT2JqZWN0LmNsb25lIHZcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHZcblxuXG4gICAgTWF0aDpcblxuICAgICAgVEFVOiBNYXRoLlBJICogMlxuXG4gICAgICB6ZXJvOiAodiktPiBNYXRoLkVQU0lMT04gPiBNYXRoLmFicyB2XG4gICAgICBub256ZXJvOiAodiktPiBub3QgTWF0aC56ZXJvIHZcblxuICAgICAgYWRkOiAoYSwgYiktPiBhICsgYlxuICAgICAgZGl2OiAoYSwgYiktPiBhIC8gYlxuICAgICAgbW9kOiAoYSwgYiktPiBhICUgYlxuICAgICAgbXVsOiAoYSwgYiktPiBhICogYlxuICAgICAgc3ViOiAoYSwgYiktPiBhIC0gYlxuXG4gICAgICBhdmc6IChhLCBiKS0+IChhICsgYikvMlxuXG4gICAgICBjbGlwOiAodiwgLi4uW21pbiA9IDBdLCBtYXggPSAxKS0+IE1hdGgubWluIG1heCwgTWF0aC5tYXggbWluLCB2XG4gICAgICBzYXQ6ICh2KSAtPiBNYXRoLmNsaXAgdlxuXG4gICAgICBsZXJwTjogKGlucHV0LCBvdXRwdXRNaW4gPSAwLCBvdXRwdXRNYXggPSAxLCBjbGlwID0gZmFsc2UpLT5cbiAgICAgICAgaW5wdXQgKj0gb3V0cHV0TWF4IC0gb3V0cHV0TWluXG4gICAgICAgIGlucHV0ICs9IG91dHB1dE1pblxuICAgICAgICBpbnB1dCA9IE1hdGguY2xpcCBpbnB1dCwgb3V0cHV0TWluLCBvdXRwdXRNYXggaWYgY2xpcFxuICAgICAgICByZXR1cm4gaW5wdXRcblxuICAgICAgbGVycDogKGlucHV0LCBpbnB1dE1pbiA9IDAsIGlucHV0TWF4ID0gMSwgb3V0cHV0TWluID0gMCwgb3V0cHV0TWF4ID0gMSwgY2xpcCA9IHRydWUpLT5cbiAgICAgICAgcmV0dXJuIG91dHB1dE1pbiBpZiBpbnB1dE1pbiBpcyBpbnB1dE1heCAjIEF2b2lkcyBhIGRpdmlkZSBieSB6ZXJvXG4gICAgICAgIFtpbnB1dE1pbiwgaW5wdXRNYXgsIG91dHB1dE1pbiwgb3V0cHV0TWF4XSA9IFtpbnB1dE1heCwgaW5wdXRNaW4sIG91dHB1dE1heCwgb3V0cHV0TWluXSBpZiBpbnB1dE1pbiA+IGlucHV0TWF4XG4gICAgICAgIGlucHV0ID0gTWF0aC5jbGlwIGlucHV0LCBpbnB1dE1pbiwgaW5wdXRNYXggaWYgY2xpcFxuICAgICAgICBpbnB1dCAtPSBpbnB1dE1pblxuICAgICAgICBpbnB1dCAvPSBpbnB1dE1heCAtIGlucHV0TWluXG4gICAgICAgIHJldHVybiBNYXRoLmxlcnBOIGlucHV0LCBvdXRwdXRNaW4sIG91dHB1dE1heCwgZmFsc2VcblxuICAgICAgcmFuZDogKG1pbiA9IC0xLCBtYXggPSAxKS0+IE1hdGgubGVycE4gTWF0aC5yYW5kb20oKSwgbWluLCBtYXhcbiAgICAgIHJhbmRJbnQ6IChtaW4sIG1heCktPiBNYXRoLnJvdW5kIE1hdGgucmFuZCBtaW4sIG1heFxuXG4gICAgICByb3VuZFRvOiAoaW5wdXQsIHByZWNpc2lvbiktPlxuICAgICAgICAjIFVzaW5nIHRoZSByZWNpcHJvY2FsIGF2b2lkcyBmbG9hdGluZyBwb2ludCBlcnJvcnMuIEVnOiAzLzEwIGlzIGZpbmUsIGJ1dCAzKjAuMSBpcyB3cm9uZy5cbiAgICAgICAgcCA9IDEgLyBwcmVjaXNpb25cbiAgICAgICAgTWF0aC5yb3VuZChpbnB1dCAqIHApIC8gcFxuXG5cbiAgICBPYmplY3Q6XG4gICAgICB0eXBlOiAodiktPiBcIltvYmplY3QgT2JqZWN0XVwiIGlzIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCB2XG5cbiAgICAgICMgVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgYSBmdW5jdGlvbiBvbiBBcnJheSwgYXMgYSBtaXJyb3Igb2YgT2JqZWN0LmtleXMgLyBPYmplY3QudmFsdWVzLlxuICAgICAgIyBJbiBnZW5lcmFsLCBmdW5jdGlvbnMgdGhhdCB0YWtlIGFuIGFycmF5IGdvIG9uIEFycmF5LCBldmVuIGlmIHRoZXkgcmV0dXJuIGEgZGlmZmVyZW50IHR5cGUuXG4gICAgICBieTogKGssIGFyciktPiAjIE9iamVjdC5ieSBcIm5hbWVcIiwgW3tuYW1lOlwiYVwifSwge25hbWU6XCJiXCJ9XSA9PiB7YTp7bmFtZTpcImFcIn0sIGI6e25hbWU6XCJiXCJ9fVxuICAgICAgICBvID0ge31cbiAgICAgICAgb1tvYmpba11dID0gb2JqIGZvciBvYmogaW4gYXJyXG4gICAgICAgIHJldHVybiBvXG5cbiAgICAgIGNsb25lOiAob2JqKS0+XG4gICAgICAgIE9iamVjdC5tYXBWYWx1ZXMgb2JqLCBGdW5jdGlvbi5jbG9uZVxuXG4gICAgICBjb3VudDogKG9iaiktPlxuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmxlbmd0aFxuXG4gICAgICBlcXVhbDogKGEsIGIpLT5cbiAgICAgICAgcmV0dXJuIHRydWUgaWYgT2JqZWN0LmlzIGEsIGJcbiAgICAgICAgcmV0dXJuIGZhbHNlIHVubGVzcyAoYT8gYW5kIGI/KSBhbmQgKHt9LmNvbnN0cnVjdG9yIGlzIGEuY29uc3RydWN0b3IgaXMgYi5jb25zdHJ1Y3RvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlIHVubGVzcyBPYmplY3Qua2V5cyhhKS5sZW5ndGggaXMgT2JqZWN0LmtleXMoYikubGVuZ3RoXG4gICAgICAgIGZvciBrLCBhdiBvZiBhXG4gICAgICAgICAgYnYgPSBiW2tdXG4gICAgICAgICAgaWYgRnVuY3Rpb24uZXF1YWwgYXYsIGJ2XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgICBtYXBLZXlzOiAob2JqLCBmbiA9IEZ1bmN0aW9uLmlkZW50aXR5KS0+XG4gICAgICAgIG8gPSB7fVxuICAgICAgICBvW2tdID0gZm4gayBmb3IgayBvZiBvYmpcbiAgICAgICAgb1xuXG4gICAgICBtYXBWYWx1ZXM6IChvYmosIGZuID0gRnVuY3Rpb24uaWRlbnRpdHkpLT5cbiAgICAgICAgbyA9IHt9XG4gICAgICAgIG9ba10gPSBmbiB2IGZvciBrLCB2IG9mIG9ialxuICAgICAgICBvXG5cbiAgICAgIG1lcmdlOiAob2Jqcy4uLiktPlxuICAgICAgICBvdXQgPSB7fVxuICAgICAgICBmb3Igb2JqIGluIG9ianMgd2hlbiBvYmo/XG4gICAgICAgICAgZm9yIGssIHYgb2Ygb2JqXG4gICAgICAgICAgICAjIERPIE5PVCBhZGQgYW55IGFkZGl0aW9uYWwgbG9naWMgZm9yIG1lcmdpbmcgb3RoZXIgdHlwZXMgKGxpa2UgYXJyYXlzKSxcbiAgICAgICAgICAgICMgb3IgZXhpc3RpbmcgYXBwcyB3aWxsIGJyZWFrIChIeXBlcnppbmUsIEhlc3QsIGV0Yy4pXG4gICAgICAgICAgICAjIElmIHlvdSB3YW50IHRvIGRlZXAgbWVyZ2Ugb3RoZXIgdHlwZXMsIHdyaXRlIGEgY3VzdG9tIG1lcmdlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgb3V0W2tdID0gaWYgT2JqZWN0LnR5cGUgdlxuICAgICAgICAgICAgICBPYmplY3QubWVyZ2Ugb3V0W2tdLCB2XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHZcbiAgICAgICAgb3V0XG5cbiAgICAgIHJtZXJnZTogKG9ianMuLi4pLT5cbiAgICAgICAgT2JqZWN0Lm1lcmdlIG9ianMucmV2ZXJzZSgpLi4uXG5cbiAgICAgIHNlYXJjaDogKG9iaiwga2V5KS0+XG4gICAgICAgIHJldHVybiB0cnVlIGlmIG9ialtrZXldP1xuICAgICAgICBmb3IgaywgdiBvZiBvYmpcbiAgICAgICAgICBpZiBBcnJheS50eXBlIHZcbiAgICAgICAgICAgIHJldHVybiB0cnVlIGlmIEFycmF5LnNlYXJjaCB2LCBrZXlcbiAgICAgICAgICBlbHNlIGlmIE9iamVjdC50eXBlIHZcbiAgICAgICAgICAgIHJldHVybiB0cnVlIGlmIE9iamVjdC5zZWFyY2ggdiwga2V5XG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgICBzdWJ0cmFjdEtleXM6IChhLCBiKS0+XG4gICAgICAgIG8gPSBPYmplY3QubWFwS2V5cyBhICMgc2hhbGxvdyBjbG9uZVxuICAgICAgICBkZWxldGUgb1trXSBmb3IgayBvZiBiXG4gICAgICAgIG9cblxuXG4gICAgUHJvbWlzZTpcbiAgICAgIHR5cGU6ICh2KS0+IHYgaW5zdGFuY2VvZiBQcm9taXNlXG5cbiAgICAgIHRpbWVvdXQ6ICh0KS0+IG5ldyBQcm9taXNlIChyZXNvbHZlKS0+IHNldFRpbWVvdXQgcmVzb2x2ZSwgdFxuXG5cbiAgICBTdHJpbmc6XG4gICAgICB0eXBlOiAodiktPiBcInN0cmluZ1wiIGlzIHR5cGVvZiB2XG5cbiAgICAgICMgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUyMTcxNDgwLzMxMzU3NiwgcHVibGljIGRvbWFpblxuICAgICAgaGFzaDogKHN0ciwgc2VlZCA9IDApLT5cbiAgICAgICAgcmV0dXJuIDAgdW5sZXNzIHN0cj9cbiAgICAgICAgaDEgPSAweGRlYWRiZWVmIF4gc2VlZFxuICAgICAgICBoMiA9IDB4NDFjNmNlNTcgXiBzZWVkXG4gICAgICAgIGZvciBjIGluIHN0clxuICAgICAgICAgIGNoID0gYy5jaGFyQ29kZUF0IDBcbiAgICAgICAgICBoMSA9IE1hdGguaW11bCBoMSBeIGNoLCAyNjU0NDM1NzYxXG4gICAgICAgICAgaDIgPSBNYXRoLmltdWwgaDIgXiBjaCwgMTU5NzMzNDY3N1xuICAgICAgICBoMSA9IE1hdGguaW11bChoMSBeIChoMT4+PjE2KSwgMjI0NjgyMjUwNykgXiBNYXRoLmltdWwoaDIgXiAoaDI+Pj4xMyksIDMyNjY0ODk5MDkpXG4gICAgICAgIGgyID0gTWF0aC5pbXVsKGgyIF4gKGgyPj4+MTYpLCAyMjQ2ODIyNTA3KSBeIE1hdGguaW11bChoMSBeIChoMT4+PjEzKSwgMzI2NjQ4OTkwOSlcbiAgICAgICAgcmV0dXJuIDQyOTQ5NjcyOTYgKiAoMjA5NzE1MSAmIGgyKSArIChoMT4+PjApXG5cbiAgICAgIHBsdXJhbGl6ZTogKGNvdW50LCBzdHJpbmcsIHN1ZmZpeCA9IFwic1wiKS0+XG4gICAgICAgIHN1ZmZpeCA9IFwiXCIgaWYgY291bnQgaXMgMVxuICAgICAgICAoc3RyaW5nICsgc3VmZml4KS5yZXBsYWNlKFwiJSVcIiwgY291bnQpXG5cbiAgICAgIHRvS2ViYWJDYXNlOiAodiktPlxuICAgICAgICB2LnJlcGxhY2UoLyhbQS1aXSkvZyxcIi0kMVwiKS50b0xvd2VyQ2FzZSgpXG5cblxuICAjIEluaXRcblxuICBmb3IgY2xhc3NOYW1lLCBjbGFzc1BhdGNoZXMgb2YgbW9ua2V5UGF0Y2hlc1xuICAgIGdsb2JhbGNsYXNzID0gZ2xvYmFsVGhpc1tjbGFzc05hbWVdXG4gICAgZm9yIGtleSwgdmFsdWUgb2YgY2xhc3NQYXRjaGVzXG4gICAgICBpZiBnbG9iYWxjbGFzc1trZXldP1xuICAgICAgICBjb25zb2xlLmxvZyBcIkNhbid0IG1vbmtleSBwYXRjaCAje2NsYXNzTmFtZX0uI3trZXl9IGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXCJcbiAgICAgIGVsc2VcbiAgICAgICAgZ2xvYmFsY2xhc3Nba2V5XSA9IHZhbHVlXG5cblxuIyBzdWJtb2R1bGUvYnVja2V0L3Rlc3QuY29mZmVlXG5UZXN0cyA9IFRlc3QgPSBudWxsXG5cbmRvICgpLT5cbiAgY29udGV4dCA9IG51bGxcblxuICBUZXN0cyA9IChuYW1lLCB0ZXN0KS0+XG4gICAgY29udGV4dCA9ICgpLT4gY29uc29sZS5ncm91cCBcIiVjI3tuYW1lfVwiLCBcImNvbG9yOiByZWRcIjsgY29udGV4dCA9IG51bGxcbiAgICB0ZXN0KClcbiAgICBjb25zb2xlLmdyb3VwRW5kKClcbiAgICBjb250ZXh0ID0gbnVsbFxuXG4gIFRlc3QgPSAobmFtZSwgLi4uc3R1ZmYpLT5cblxuICAgICMgSWYgd2UndmUgYmVlbiBwYXNzZWQgYW55IGZ1bmN0aW9ucywgcnVuIHRoZW0gYW5kIGNhcHR1cmUgdGhlIHJldHVybiB2YWx1ZXMuXG4gICAgZm9yIHRoaW5nLCBpIGluIHN0dWZmIHdoZW4gRnVuY3Rpb24udHlwZSB0aGluZ1xuICAgICAgc3R1ZmZbaV0gPSB0aGluZygpXG5cbiAgICAjIElmIHRoZXJlJ3Mgb25seSBvbmUgdGhpbmcgaW4gc3R1ZmYsIGp1c3QgY29tcGFyZSBpdCB3aXRoIHRydWVcbiAgICBpZiBzdHVmZi5sZW5ndGggaXMgMVxuICAgICAgc3R1ZmYudW5zaGlmdCB0cnVlXG5cbiAgICAjIE5vdywgYWxsIHRoaW5ncyBpbiBzdHVmZiBtdXN0IGFsbCBiZSBlcXVpdmFsZW50LiBPciBlbHNlLlxuICAgICMgKFRoaXMgdGVzdCBmcmFtZXdvcmsgaXMgc3VwZXIgY2FzdWFsLCBzbyB3ZSBqdXN0IGNoZWNrIGVhY2ggbmVpZ2hib3VyaW5nIHBhaXIpXG4gICAgZm9yIHRoaW5nLCBpIGluIEFycmF5LmJ1dExhc3Qgc3R1ZmZcbiAgICAgIHVubGVzcyBGdW5jdGlvbi5lcXVpdmFsZW50IHRoaW5nLCBzdHVmZltpKzFdXG4gICAgICAgIGNvbnRleHQ/KClcbiAgICAgICAgY29uc29sZS5ncm91cCBcIiVjI3tuYW1lfVwiLCBcImZvbnQtd2VpZ2h0Om5vcm1hbDtcIlxuICAgICAgICBjb25zb2xlLmxvZyBcInRoaXM6XCIsIHRoaW5nXG4gICAgICAgIGNvbnNvbGUubG9nIFwiaXNudDpcIiwgc3R1ZmZbaSsxXVxuICAgICAgICBjb25zb2xlLmdyb3VwRW5kKClcblxuXG4jIGxpYi9maWxlLXRyZWUuY29mZmVlXG5UYWtlIFtcIlJlYWRcIl0sIChSZWFkKS0+XG5cbiAgc29ydCA9IChhLCBiKS0+IGEubmFtZS5sb2NhbGVDb21wYXJlIGIubmFtZVxuXG4gIHBvcHVsYXRlVHJlZSA9ICh0cmVlKS0+XG4gICAgaWYgYXdhaXQgUmVhZC5leGlzdHMgdHJlZS5wYXRoXG4gICAgICBkaXJlbnRzID0gYXdhaXQgUmVhZC53aXRoRmlsZVR5cGVzIHRyZWUucGF0aFxuICAgICAgZGlyZW50cy5zb3J0IHNvcnRcbiAgICAgIHRyZWUuY2hpbGRyZW4gPSBhd2FpdCBQcm9taXNlLmFsbCBkaXJlbnRzLm1hcCAoZGlyZW50KS0+XG4gICAgICAgIGlmIGRpcmVudC5pc0RpcmVjdG9yeSgpXG4gICAgICAgICAgY2hpbGRUcmVlID0gRmlsZVRyZWUubmV3RW1wdHkgdHJlZS5wYXRoLCBkaXJlbnQubmFtZVxuICAgICAgICAgIGNoaWxkVHJlZS5yZWxwYXRoID0gUmVhZC5wYXRoIHRyZWUucmVscGF0aCwgZGlyZW50Lm5hbWVcbiAgICAgICAgICBhd2FpdCBwb3B1bGF0ZVRyZWUgY2hpbGRUcmVlXG4gICAgICAgICAgdHJlZS5jb3VudCArPSBjaGlsZFRyZWUuY291bnRcbiAgICAgICAgICBjaGlsZFRyZWVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRyZWUuY291bnQgKz0gMVxuICAgICAgICAgIHBhcnRzID0gZGlyZW50Lm5hbWUuc3BsaXQgXCIuXCJcbiAgICAgICAgICBjaGlsZEZpbGUgPVxuICAgICAgICAgICAgbmFtZTogZGlyZW50Lm5hbWVcbiAgICAgICAgICAgIGJhc2VuYW1lOiBBcnJheS5idXRMYXN0KHBhcnRzKS5qb2luIFwiLlwiXG4gICAgICAgICAgICBleHQ6IGlmIHBhcnRzLmxlbmd0aCA+IDEgdGhlbiBBcnJheS5sYXN0KHBhcnRzKS50b0xvd2VyQ2FzZSgpIGVsc2UgbnVsbFxuICAgICAgICAgICAgcGF0aDogUmVhZC5wYXRoIHRyZWUucGF0aCwgZGlyZW50Lm5hbWVcbiAgICAgICAgICAgIHJlbHBhdGg6IFJlYWQucGF0aCB0cmVlLnJlbHBhdGgsIGRpcmVudC5uYW1lXG4gICAgdHJlZVxuXG4gIE1ha2UgXCJGaWxlVHJlZVwiLCBGaWxlVHJlZSA9XG4gICAgbmV3RW1wdHk6IChwYXJlbnRQYXRoLCBuYW1lKS0+XG4gICAgICBuYW1lOiBuYW1lXG4gICAgICBiYXNlbmFtZTogbmFtZVxuICAgICAgZXh0OiBudWxsXG4gICAgICBwYXRoOiBSZWFkLnBhdGggcGFyZW50UGF0aCwgbmFtZSAjIGFic29sdXRlIHBhdGggb24gdGhlIGxvY2FsIEhEXG4gICAgICByZWxwYXRoOiBuYW1lICMgcGF0aCByZWxhdGl2ZSB0byB0aGUgcGFyZW50IG9mIHRoZSB0cmVlIHJvb3RcbiAgICAgIGNvdW50OiAwXG4gICAgICBjaGlsZHJlbjogW11cblxuICAgIG5ld1BvcHVsYXRlZDogKHBhcmVudFBhdGgsIG5hbWUpLT5cbiAgICAgIHJvb3QgPSBGaWxlVHJlZS5uZXdFbXB0eSBwYXJlbnRQYXRoLCBuYW1lXG4gICAgICBhd2FpdCBwb3B1bGF0ZVRyZWUgcm9vdFxuICAgICAgcm9vdFxuXG4gICAgZmxhdDogKHRyZWUsIGssIGludG8gPSBbXSktPlxuICAgICAgZm9yIGNoaWxkIGluIHRyZWUuY2hpbGRyZW5cbiAgICAgICAgaWYgbm90IGs/ICMgY29sbGVjdGluZyBjaGlsZHJlblxuICAgICAgICAgIGludG8ucHVzaCBjaGlsZFxuICAgICAgICBlbHNlIGlmIGNoaWxkW2tdPyAjIGNvbGxlY3RpbmcgY2hpbGRyZW4ncyBwcm9wZXJ0aWVzXG4gICAgICAgICAgaW50by5wdXNoIGNoaWxkW2tdXG4gICAgICAgIEZpbGVUcmVlLmZsYXQgY2hpbGQsIGssIGludG8gaWYgY2hpbGQuY2hpbGRyZW5cbiAgICAgIGludG9cblxuICAgIGZpbmQ6ICh0cmVlLCBrLCB2KS0+XG4gICAgICByZXR1cm4gdHJlZSBpZiB0cmVlW2tdIGlzIHZcbiAgICAgIGlmIHRyZWUuY2hpbGRyZW5cbiAgICAgICAgZm9yIGNoaWxkIGluIHRyZWUuY2hpbGRyZW5cbiAgICAgICAgICByZXR1cm4gcmVzIGlmIHJlcyA9IEZpbGVUcmVlLmZpbmQgY2hpbGQsIGssIHZcbiAgICAgIG51bGxcblxuXG4jIGxpYi9mcnVzdHJhdGlvbi5jb2ZmZWVcblRha2UgW10sICgpLT5cbiAgYXJyID0gW1xuICAgIFwi4oCiX+KAomAgXCIsXG4gICAgXCJg4oCiX+KAomBcIixcbiAgICBcIiBg4oCiX+KAolwiLFxuICAgIFwiICBvLm9cIixcbiAgICBcIiBvLm8gXCIsXG4gICAgXCJvLm8gIFwiLFxuICAgIFwi4oCi4oia4oCiICBcIixcbiAgICBcIiDigKLiiJrigKIgXCIsXG4gICAgXCIgIOKAouKImuKAolwiLFxuICAgIFwiICDCsGXCsFwiLFxuICAgIFwiIMKwb8KwIFwiLFxuICAgIFwiwrAzwrAgIFwiLFxuICAgIFwidl92ICBcIixcbiAgICBcIiB2X3YgXCIsXG4gICAgXCIgIHZfdlwiLFxuICAgIFwiIGDigKLPieKAolwiLFxuICAgIFwiYOKAos+J4oCiYFwiLFxuICAgIFwi4oCiz4nigKJgIFwiLFxuICAgIFwi4oCYXuKAmCAgXCIsXG4gICAgXCIgJ14nIFwiLFxuICAgIFwiICBgXmBcIixcbiAgICBcIiAgVOKInlRcIixcbiAgICBcIiBU4oieVCBcIixcbiAgICBcIlTiiJ5UICBcIixcbiAgICBcIsKhXsKhICBcIixcbiAgICBcIiDCoV7CoSBcIixcbiAgICBcIiAgwqFewqFcIixcbiAgICBcIiAgO187XCIsXG4gICAgXCIgO187IFwiLFxuICAgIFwiO187ICBcIlxuICBdXG5cbiAgTWFrZSBcIkZydXN0cmF0aW9uXCIsIChpKS0+XG4gICAgaWYgaT9cbiAgICAgIGkgJT0gYXJyLmxlbmd0aFxuICAgIGVsc2VcbiAgICAgIGkgPSBNYXRoLnJhbmQgMCwgYXJyLmxlbmd0aFxuICAgIGFycltpfDBdXG5cblxuIyBsaWIvaXRlcmF0ZWQuY29mZmVlXG5UYWtlIFtdLCAoKS0+XG5cbiAgTWFrZSBcIkl0ZXJhdGVkXCIsIEl0ZXJhdGVkID0gKC4uLlt0aW1lTGltaXQgPSA1XSwgaXRlcmF0ZWRGdW5jdGlvbiktPlxuXG4gICAgbmV4dEZyYW1lUmVxdWVzdGVkID0gZmFsc2VcbiAgICBydW5BZ2Fpbk5leHRGcmFtZSA9IGZhbHNlXG4gICAgZGlkUnVuVGhpc0ZyYW1lID0gZmFsc2VcbiAgICByYW5PdXRPZlRpbWUgPSBmYWxzZVxuICAgIHN0YXJ0VGltZSA9IG51bGxcblxuICAgIHJ1biA9ICgpLT5cbiAgICAgICMgT25seSBydW4gb25jZSBwZXIgZnJhbWUuIElmIHdlJ3ZlIGFscmVhZHkgcnVuLCBtYXJrIHRoYXQgd2Ugd2FudCB0byBydW4gYWdhaW4gbmV4dCBmcmFtZS5cbiAgICAgIHJldHVybiBydW5BZ2Fpbk5leHRGcmFtZSA9IHRydWUgaWYgZGlkUnVuVGhpc0ZyYW1lXG4gICAgICBkaWRSdW5UaGlzRnJhbWUgPSB0cnVlXG5cbiAgICAgICMgV2hlbmV2ZXIgd2UgcnVuLCB3ZSBuZWVkIHRvIGRvIHNvbWUgYWRkaXRpb25hbCB3b3JrIG5leHQgZnJhbWUuXG4gICAgICByZXF1ZXN0TmV4dEZyYW1lKClcblxuICAgICAgIyBEZWZlciB0aGUgZXhlY3V0aW9uIG9mIHRoZSBmdW5jdGlvbiAqc2xpZ2h0bHkqLCB0byBpbXByb3ZlIGJhdGNoaW5nIGJlaGF2aW91clxuICAgICAgIyB3aGVuIGFuIGl0ZXJhdGVkIGZ1bmN0aW9uIGlzIGNhbGxlZCByZXBlYXRlZGx5IGluc2lkZSBhIGxvb3AgKGVnOiBieSBsaWIvam9iLmNvZmZlZSkuXG4gICAgICBxdWV1ZU1pY3JvdGFzayAoKS0+XG5cbiAgICAgICAgIyBOb3cgd2UgY2FuIGFjdHVhbGx5IHJ1biB0aGUgaXRlcmF0ZWQgZnVuY3Rpb24hXG4gICAgICAgIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgIGl0ZXJhdGVkRnVuY3Rpb24gbW9yZVxuXG4gICAgICAjIEl0ZXJhdGVkIGZ1bmN0aW9ucyBhcmUganVzdCBmb3Igc2lkZSBlZmZlY3RzIOKAlCBhIHJldHVybiB2YWx1ZSBpcyBub3QgbmVlZGVkLlxuICAgICAgbnVsbFxuXG5cbiAgICByZXF1ZXN0TmV4dEZyYW1lID0gKCktPlxuICAgICAgcmV0dXJuIGlmIG5leHRGcmFtZVJlcXVlc3RlZFxuICAgICAgbmV4dEZyYW1lUmVxdWVzdGVkID0gdHJ1ZVxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIG5leHRGcmFtZVxuXG4gICAgIyBXaGVuZXZlciBzb21lb25lIGNhbGxzIHJ1bigpLCB3ZSAqYWx3YXlzKiBuZWVkIHRvIGRvIHNvbWUgY2xlYW51cCB3b3JrLCBhbmQgbWUgbWlnaHRcbiAgICAjIGFsc28gbmVlZCB0byBjYWxsIHJ1bigpIGFnYWluIG91cnNlbHZlcyBpZiB0aGVyZSdzIG1vcmUgaXRlcmF0ZWQgd29yayB0byBiZSBkb25lLlxuICAgIG5leHRGcmFtZSA9ICgpLT5cbiAgICAgIGRvUnVuID0gcnVuQWdhaW5OZXh0RnJhbWVcbiAgICAgIG5leHRGcmFtZVJlcXVlc3RlZCA9IGZhbHNlXG4gICAgICBydW5BZ2Fpbk5leHRGcmFtZSA9IGZhbHNlXG4gICAgICBkaWRSdW5UaGlzRnJhbWUgPSBmYWxzZVxuICAgICAgcmFuT3V0T2ZUaW1lID0gZmFsc2VcbiAgICAgIHJ1bigpIGlmIGRvUnVuXG5cbiAgICAjIFRoaXMgZnVuY3Rpb24gd2lsbCB0ZWxsIHRoZSBjYWxsZXIgd2hldGhlciB0aGV5J3JlIHNhZmUgdG8gZG8gbW9yZSB3b3JrIHRoaXMgZnJhbWUuXG4gICAgIyBUaGV5J2xsIGNhbGwgaXQgcmVwZWF0ZWRseSBpbiBhIGxvb3AgKHdoaWxlIGRvaW5nIG90aGVyIHdvcmspIHVudGlsIGVpdGhlciB0aGV5XG4gICAgIyBydW4gb3V0IG9mIHRpbWUgYW5kIGJyZWFrIG91dCBvZiB0aGUgbG9vcCwgb3IgcnVuIG91dCBvZiB3b3JrIHRvIGRvIGFuZCBqdXN0IHN0b3BcbiAgICAjIGNhbGxpbmcgdXMuXG4gICAgbW9yZSA9IChjdXN0b21MaW1pdCktPlxuICAgICAgcmFuT3V0T2ZUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUgPiAoY3VzdG9tTGltaXQgb3IgdGltZUxpbWl0KVxuXG4gICAgICBpZiByYW5PdXRPZlRpbWVcbiAgICAgICAgIyBNYXJrIHRoYXQgd2Ugd2FudCB0byBhY3R1YWxseSBkbyBhIHJ1bigpIG5leHQgZnJhbWUsIG5vdCBqdXN0IHRoZSB1c3VhbCBjbGVhbnVwLlxuICAgICAgICBydW5BZ2Fpbk5leHRGcmFtZSA9IHRydWVcblxuICAgICAgICAjIFdlIGFsd2F5cyBuZWVkIHRvIHJlcXVlc3QgYSBuZXcgZnJhbWUsIHNpbmNlIHRoZSBjYWxsIHRvIG1vcmUoKSBtaWdodCBjb21lXG4gICAgICAgICMgbG9uZyBhZnRlciB0aGUgbGFzdCBjYWxsIHRvIHJ1bigpIGlmIHRoZSBpdGVyYXRlZCBmdW5jdGlvbiBpcyBkb2luZyBzb21ldGhpbmcgYXN5bmMuXG4gICAgICAgIHJlcXVlc3ROZXh0RnJhbWUoKVxuXG4gICAgICByZXR1cm4gbm90IHJhbk91dE9mVGltZVxuXG4gICAgcmV0dXJuIHJ1blxuXG5cbiMgbGliL2pvYi5jb2ZmZWVcblRha2UgW10sICgpLT5cblxuICBoYW5kbGVycyA9IHt9XG4gIHdhdGNoZXJzID0gW11cbiAgcnVubmluZyA9IGZhbHNlXG4gIGxhc3RUaW1lID0gbnVsbFxuICBsYXN0TiA9IFtdXG5cbiAgTWFrZS5hc3luYyBcIkpvYlwiLCBKb2IgPSAocHJpb3JpdHksIHR5cGUsIC4uLmFyZ3MpLT5cbiAgICAjIFByaW9yaXR5IGlzIG9wdGlvbmFsLCBhbmQgZGVmYXVsdHMgdG8gMFxuICAgIGlmIFN0cmluZy50eXBlIHByaW9yaXR5XG4gICAgICByZXR1cm4gSm9iIDAsIHByaW9yaXR5LCB0eXBlLCAuLi5hcmdzXG5cbiAgICB0aHJvdyBFcnJvciBcIk5vIGhhbmRsZXIgZm9yIGpvYiB0eXBlOiAje3R5cGV9XCIgdW5sZXNzIGhhbmRsZXJzW3R5cGVdP1xuXG4gICAgbmV3IFByb21pc2UgKHJlc29sdmUpLT5cbiAgICAgIEpvYi5xdWV1ZXNbcHJpb3JpdHldID89IFtdXG4gICAgICBKb2IucXVldWVzW3ByaW9yaXR5XS5wdXNoIHt0eXBlLCBhcmdzLCByZXNvbHZlfVxuICAgICAgSm9iLmNvdW50KytcbiAgICAgIEpvYi5ydW5Kb2JzKClcblxuICBKb2IucXVldWVzID0gW11cbiAgSm9iLmNvdW50ID0gMFxuICBKb2IuZGVsYXkgPSAwXG5cbiAgSm9iLmhhbmRsZXIgPSAodHlwZSwgaGFuZGxlciktPlxuICAgIGlmIGhhbmRsZXJzW3R5cGVdIHRoZW4gdGhyb3cgRXJyb3IgXCJBIGpvYiBoYW5kbGVyIGZvciAje3R5cGV9IGFscmVhZHkgZXhpc3RzXCJcbiAgICBoYW5kbGVyc1t0eXBlXSA9IGhhbmRsZXJcblxuICBKb2Iud2F0Y2hlciA9ICh3YXRjaGVyKS0+XG4gICAgd2F0Y2hlcnMucHVzaCB3YXRjaGVyXG5cbiAgSm9iLnJ1bkpvYnMgPSAoKS0+XG4gICAgcmV0dXJuIGlmIHJ1bm5pbmdcbiAgICBydW5uaW5nID0gdHJ1ZVxuICAgIGxhc3RUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBKb2IuZGVsYXkgPSAxNlxuICAgIHVwZGF0ZVdhdGNoZXJzKClcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcnVuXG5cbiAgcnVuID0gKCktPlxuICAgIGRpcnR5ID0gZmFsc2VcbiAgICBmb3IgcXVldWUsIHByaW9yaXR5IGluIEpvYi5xdWV1ZXMgYnkgLTFcbiAgICAgIHdoaWxlIHF1ZXVlPy5sZW5ndGggPiAwXG4gICAgICAgIGRpcnR5ID0gdHJ1ZVxuICAgICAgICB7dGltZSwgdHlwZSwgYXJncywgcmVzb2x2ZX0gPSBxdWV1ZS5zaGlmdCgpXG4gICAgICAgIEpvYi5jb3VudC0tXG4gICAgICAgIHJlc29sdmUgaGFuZGxlcnNbdHlwZV0gLi4uYXJncyAjIFdlIGNhbid0IGF3YWl0LCBvciBlbHNlIGlmIGEgSm9iIGNyZWF0ZXMgYSBuZXcgSm9iIGluc2lkZSBpdHNlbGYsIHdlJ2xsIGdldCBzdHVja1xuICAgICAgICBKb2IuZGVsYXkgPSAocGVyZm9ybWFuY2Uubm93KCkgLSBsYXN0VGltZSkgKiAwLjEgKyBKb2IuZGVsYXkgKiAwLjlcbiAgICAgICAgcmV0dXJuIGJhaWwoKSBpZiBKb2IuZGVsYXkgPiAzMCAjIERvbid0IGxldCB0aGUgZnJhbWUgcmF0ZSBjcmF0ZXJcbiAgICBydW5uaW5nID0gZmFsc2VcbiAgICAjIElmIGFueSBqb2JzIHJhbiB0aGlzIGZyYW1lLCB3ZSBzaG91bGQgcnVuIGF0IGxlYXN0IG9uZSBtb3JlIHRpbWUsIGluIGNhc2UgYW55IGpvYnMgdGhhdCB3ZSByYW4gY3JlYXRlZCBuZXcgam9icyBhdCBhIGhpZ2hlciBwcmlvcml0eS5cbiAgICBKb2IucnVuSm9icygpIGlmIGRpcnR5XG4gICAgdXBkYXRlV2F0Y2hlcnMoKVxuXG4gIGJhaWwgPSAoKS0+XG4gICAgbGFzdFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSBydW5cbiAgICB1cGRhdGVXYXRjaGVycygpXG5cbiAgdXBkYXRlV2F0Y2hlcnMgPSAoKS0+XG4gICAgZm9yIHdhdGNoZXIgaW4gd2F0Y2hlcnNcbiAgICAgIHdhdGNoZXIgSm9iLmNvdW50LCBKb2IuZGVsYXlcbiAgICBudWxsXG5cblxuIyBsaWIvbG9nLWluaXRpYWxpemF0aW9uLXRpbWUuY29mZmVlXG5kbyAoKS0+XG4gIHsgcGVyZm9ybWFuY2UgfSA9IHJlcXVpcmUgXCJwZXJmX2hvb2tzXCIgdW5sZXNzIHBlcmZvcm1hbmNlP1xuXG4gIHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuXG4gIExvZyA9IGF3YWl0IFRha2UuYXN5bmMgXCJMb2dcIlxuXG4gIExvZyBcIkluaXRpYWxpemF0aW9uIFRpbWVcIiwgbnVsbCwgdGltZVxuXG5cbiMgbGliL2xvZy5jb2ZmZWVcblRha2UgW10sICgpLT5cbiAgeyBwZXJmb3JtYW5jZSB9ID0gcmVxdWlyZSBcInBlcmZfaG9va3NcIiB1bmxlc3MgcGVyZm9ybWFuY2U/XG5cbiAgIyBXZSBjYW4ndCAvIHNob3VsZG4ndCBUYWtlIGFueXRoaW5nLCBzaW5jZSBMb2cgbWlnaHQgbmVlZCB0byBiZSB1c2VkICphbnl3aGVyZSpcbiAgREIgPSBFbnYgPSBJUEMgPSBQcmludGVyID0gbnVsbFxuXG4gIE1ha2UuYXN5bmMgXCJMb2dcIiwgTG9nID0gKG1zZywgYXR0cnMsIHRpbWUpLT5cbiAgICBFbnYgPz0gVGFrZSBcIkVudlwiXG5cbiAgICAjIFNlbmQgbG9ncyB0byB0aGUgbG9jYWwgcHJpbnRlclxuICAgIGlmIFByaW50ZXIgPz0gVGFrZSBcIlByaW50ZXJcIlxuICAgICAgUHJpbnRlciBtc2csIGF0dHJzLCB0aW1lXG5cbiAgICAjIElmIHdlIGhhdmUgYSBwb3J0IHRvIHRoZSBEQiwgc2VuZCBsb2dzIHRvIHRoZSBEQiBQcmludGVyXG4gICAgaWYgREIgPz0gVGFrZSBcIkRCXCJcbiAgICAgIERCLnNlbmQgXCJwcmludGVyXCIsIG1zZywgYXR0cnMsIHRpbWVcblxuICAgICMgSWYgd2UncmUgaW4gZGV2LCBhbmQgaW4gYSByZW5kZXIgcHJvY2Vzcywgc2VuZCBsb2dzIHRvIHRoZSBtYWluIHByb2Nlc3MgUHJpbnRlclxuICAgIGlmIEVudj8uaXNEZXYgYW5kIEVudj8uaXNSZW5kZXIgYW5kIElQQyA/PSBUYWtlIFwiSVBDXCJcbiAgICAgIElQQy5zZW5kIFwicHJpbnRlclwiLCBtc2csIGF0dHJzLCB0aW1lXG5cbiAgICByZXR1cm4gbXNnXG5cbiAgTG9nLnRpbWUgPSAobXNnLCBmbiktPlxuICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICB2ID0gZm4oKVxuICAgIExvZy50aW1lLmZvcm1hdHRlZCBtc2csIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRcbiAgICByZXR1cm4gdlxuXG4gIExvZy50aW1lLmFzeW5jID0gKG1zZywgZm4pLT5cbiAgICBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgdiA9IGF3YWl0IGZuKClcbiAgICBMb2cudGltZS5mb3JtYXR0ZWQgbXNnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0XG4gICAgcmV0dXJuIHZcblxuICBMb2cudGltZS5jdXN0b20gPSAocHJlTXNnKS0+XG4gICAgTG9nIHByZU1zZyBpZiBwcmVNc2dcbiAgICBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgKHBvc3RNc2cpLT4gTG9nLnRpbWUuZm9ybWF0dGVkIHBvc3RNc2csIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRcblxuICBMb2cudGltZS5mb3JtYXR0ZWQgPSAobXNnLCB0aW1lKS0+XG4gICAgTG9nIHRpbWUudG9GaXhlZCgxKS5wYWRTdGFydCg2KSArIFwiIFwiICsgbXNnXG5cbiAgTG9nLmVyciA9IChtc2cpLT5cbiAgICBMb2cgbXNnLCBjb2xvcjogXCIjRjAwXCJcblxuXG4jIGxpYi9wYXRocy5jb2ZmZWVcblRha2UgW1wiUmVhZFwiXSwgKFJlYWQpLT5cblxuICBNYWtlIFwiUGF0aHNcIiwgUGF0aHMgPVxuICAgIGZpbGVzOiAoYXNzZXQpLT4gICAgICAgICAgICAgICBSZWFkLnBhdGggYXNzZXQucGF0aCwgXCJGaWxlc1wiXG4gICAgbmFtZXM6IChhc3NldCktPiAgICAgICAgICAgICAgIFJlYWQucGF0aCBhc3NldC5wYXRoLCBcIk5hbWVcIlxuICAgIHNob3RzOiAoYXNzZXQpLT4gICAgICAgICAgICAgICBSZWFkLnBhdGggYXNzZXQucGF0aCwgXCJTaG90XCJcbiAgICBuZXdTaG90czogKGFzc2V0KS0+ICAgICAgICAgICAgUmVhZC5wYXRoIGFzc2V0LnBhdGgsIFwiU2hvdCAoTmV3KVwiXG4gICAgdGFnczogKGFzc2V0KS0+ICAgICAgICAgICAgICAgIFJlYWQucGF0aCBhc3NldC5wYXRoLCBcIlRhZ3NcIlxuICAgIHRodW1ibmFpbHM6IChhc3NldCktPiAgICAgICAgICBSZWFkLnBhdGggYXNzZXQucGF0aCwgXCJUaHVtYm5haWwgQ2FjaGVcIlxuXG4gICAgZmlsZTogKGFzc2V0LCBmaWxlbmFtZSktPiAgICAgIFJlYWQucGF0aCBQYXRocy5maWxlcyhhc3NldCksIGZpbGVuYW1lXG4gICAgbmFtZTogKGFzc2V0KS0+ICAgICAgICAgICAgICAgIFJlYWQucGF0aCBQYXRocy5uYW1lcyhhc3NldCksIGFzc2V0Lm5hbWVcbiAgICBzaG90OiAoYXNzZXQpLT4gICAgICAgICAgICAgICAgUmVhZC5wYXRoIFBhdGhzLnNob3RzKGFzc2V0KSwgYXNzZXQuc2hvdFxuICAgIG5ld1Nob3Q6IChhc3NldCktPiAgICAgICAgICAgICBSZWFkLnBhdGggUGF0aHMubmV3U2hvdHMoYXNzZXQpLCBhc3NldC5uZXdTaG90XG4gICAgdGh1bWJuYWlsOiAoYXNzZXQsIGZpbGVuYW1lKS0+IFJlYWQucGF0aCBQYXRocy50aHVtYm5haWxzKGFzc2V0KSwgZmlsZW5hbWVcbiAgICB0YWc6IChhc3NldCwgdGFnKS0+ICAgICAgICAgICAgUmVhZC5wYXRoIFBhdGhzLnRhZ3MoYXNzZXQpLCB0YWdcblxuICAgIHRodW1ibmFpbE5hbWU6IChmaWxlLCBzaXplKS0+ICBcIiN7U3RyaW5nLmhhc2ggZmlsZS5yZWxwYXRofS0je3NpemV9LmpwZ1wiXG5cbiAgICBleHQ6XG4gICAgICBpY29uOiB7XCJhc1wiLCBcImNwdHhcIiwgXCJjc3NcIiwgXCJkd2dcIiwgXCJleGVcIiwgXCJmbGFcIiwgXCJpZGxrXCIsIFwiaW5kYlwiLCBcImluZGRcIiwgXCJzd2ZcIiwgbnVsbDp0cnVlLCB1bmRlZmluZWQ6dHJ1ZX0gIyBJbmNsdWRlIG51bGwgLyB1bmRlZmluZWQgYmVjYXVzZSB3ZSB3YW50IHRob3NlIHRvIGdldCBhbiBpY29uLCBub3QgYSB0aHVtYm5haWxcbiAgICAgIHNpcHM6IHtcIjNmclwiLFwiYXJ3XCIsXCJhc3RjXCIsXCJhdmNpXCIsXCJibXBcIixcImNyMlwiLFwiY3IzXCIsXCJjcndcIixcImRjclwiLFwiZGRzXCIsXCJkbmdcIixcImR4b1wiLFwiZXJmXCIsXCJleHJcIixcImZmZlwiLFwiZ2lmXCIsXCJoZWljXCIsXCJoZWljc1wiLFwiaGVpZlwiLFwiaWNuc1wiLFwiaWNvXCIsXCJpaXFcIixcImpwMlwiLFwianBlZ1wiLFwianBnXCIsXCJrdHhcIixcIm1vc1wiLFwibXBvXCIsXCJtcndcIixcIm5lZlwiLFwibnJ3XCIsXCJvcmZcIixcIm9yZlwiLFwib3JmXCIsXCJwYm1cIixcInBkZlwiLFwicGVmXCIsXCJwaWNcIixcInBpY3RcIixcInBuZ1wiLFwicHNkXCIsXCJwdnJcIixcInJhZlwiLFwicmF3XCIsXCJydzJcIixcInJ3bFwiLFwic2dpXCIsXCJzcjJcIixcInNyZlwiLFwic3J3XCIsXCJ0Z2FcIixcInRpZmZcIixcIndlYnBcIn1cbiAgICAgIHZpZGVvOiB7XCJhdmNoZFwiLCBcImF2aVwiLCBcIm00cFwiLCBcIm00dlwiLCBcIm1vdlwiLCBcIm1wMlwiLCBcIm1wNFwiLCBcIm1wZVwiLCBcIm1wZWdcIiwgXCJtcGdcIiwgXCJtcHZcIiwgXCJvZ2dcIiwgXCJxdFwiLCBcIndlYm1cIiwgXCJ3bXZcIn1cblxuXG4jIGxpYi9wcmludGVyLmNvZmZlZVxuVGFrZSBbXSwgKCktPlxuICByZXR1cm4gaWYgd2luZG93Py5pc0RCICMgREIgaGFzIGl0cyBvd24gUHJpbnRlclxuXG4gIHsgcGVyZm9ybWFuY2UgfSA9IHJlcXVpcmUgXCJwZXJmX2hvb2tzXCIgdW5sZXNzIHBlcmZvcm1hbmNlP1xuXG4gIE1ha2UgXCJQcmludGVyXCIsIFByaW50ZXIgPSAobXNnLCBhdHRycywgdGltZSktPlxuICAgIHRpbWUgPSAodGltZSBvciBwZXJmb3JtYW5jZS5ub3coKSkudG9GaXhlZCgwKS5wYWRTdGFydCg1KVxuICAgIGNvbnNvbGUubG9nIHRpbWUgKyBcIiAgXCIgKyBtc2dcblxuXG4jIGxpYi9wdWItc3ViLmNvZmZlZVxuVGFrZSBbXSwgKCktPlxuXG4gIHN1YnMgPSB7fVxuXG4gIFN1YiA9IChuYW1lLCBjYiktPlxuICAgIChzdWJzW25hbWVdID89IFtdKS5wdXNoIGNiXG5cbiAgUHViID0gKG5hbWUsIGFyZ3MuLi4pLT5cbiAgICBpZiBzdWJzW25hbWVdP1xuICAgICAgZm9yIGhhbmRsZXIgaW4gc3Vic1tuYW1lXVxuICAgICAgICBoYW5kbGVyIGFyZ3MuLi5cbiAgICBudWxsXG5cbiAgTWFrZSBcIlB1YlN1YlwiLCB7UHViLCBTdWJ9XG5cblxuIyBsaWIvcmVhZC5jb2ZmZWVcbiMgVE9ETzogQ2xlYXIgdXAgdGhlIG5hbWluZyBzbyB0aGF0IGV2ZXJ5dGhpbmcgaXMgZXhwbGljaXRseSBSZWFkLnN5bmMuZm9vIG9yIFJlYWQuYXN5bmMuZm9vXG5cblRha2UgW10sICgpLT5cbiAgZnMgPSByZXF1aXJlIFwiZnNcIlxuICBwYXRoID0gcmVxdWlyZSBcInBhdGhcIlxuXG4gIHZhbGlkRmlsZU5hbWUgPSAodiktPlxuICAgIHJldHVybiBmYWxzZSBpZiAwIGlzIHYuaW5kZXhPZiBcIi5cIiAjIEV4Y2x1ZGUgZG90ZmlsZXNcbiAgICByZXR1cm4gZmFsc2UgaWYgLTEgaXNudCB2LnNlYXJjaCAvWzw+OjssP1wiKnwvXFxcXF0vICMgRXhjbHVkZSBuYW1lcyB3ZSB3b24ndCBiZSBhYmxlIHRvIHJvdW5kdHJpcFxuICAgIHJldHVybiB0cnVlICMgRXZlcnl0aGluZyBlbHNlIGlzIGdvb2RcblxuICB2YWxpZERpcmVudE5hbWUgPSAodiktPlxuICAgIHZhbGlkRmlsZU5hbWUgdi5uYW1lXG5cbiAgZmlsdGVyVmFsaWREaXJlbnROYW1lID0gKHZzKS0+XG4gICAgdnMuZmlsdGVyIHZhbGlkRGlyZW50TmFtZVxuXG4gIFJlYWQgPSAoZm9sZGVyUGF0aCktPlxuICAgIHRyeVxuICAgICAgZmlsZU5hbWVzID0gZnMucmVhZGRpclN5bmMgZm9sZGVyUGF0aFxuICAgICAgZmlsZU5hbWVzLmZpbHRlciB2YWxpZEZpbGVOYW1lXG4gICAgY2F0Y2hcbiAgICAgIG51bGxcblxuICAjIFRlbXBvcmFyeSBoYWNrIHVudGlsIHdlIGZ1bGx5IHN3aXRjaCBSZWFkIG92ZXIgdG8gc3BsaXQgc3luYyBhbmQgYXN5bmMuXG4gICMgTm90ZSB0aGF0IHdlIGNhbid0IGp1c3Qgc2F5IFJlYWQuc3luYyA9IFJlYWQsIG9yIHRoYXQgYnJlYWtzIFJlYWQuc3luYy5leGlzdHMhXG4gIFJlYWQuc3luYyA9IChwKS0+IFJlYWQgcFxuXG4gIFJlYWQuc3luYy5leGlzdHMgPSAocGF0aCktPlxuICAgIGZzLmV4aXN0c1N5bmMgcGF0aFxuXG4gIFJlYWQuYXN5bmMgPSAoZm9sZGVyUGF0aCktPlxuICAgIG5ldyBQcm9taXNlIChyZXNvbHZlKS0+XG4gICAgICBmcy5yZWFkZGlyIGZvbGRlclBhdGgsIChlcnIsIGZpbGVOYW1lcyktPlxuICAgICAgICBpZiBlcnI/XG4gICAgICAgICAgcmVzb2x2ZSBudWxsXG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXNvbHZlIGZpbGVOYW1lcy5maWx0ZXIgdmFsaWRGaWxlTmFtZVxuXG4gIFJlYWQud2l0aEZpbGVUeXBlcyA9IChmb2xkZXJQYXRoKS0+XG4gICAgZnMucHJvbWlzZXMucmVhZGRpciBmb2xkZXJQYXRoLCB7d2l0aEZpbGVUeXBlczp0cnVlfVxuICAgIC50aGVuIGZpbHRlclZhbGlkRGlyZW50TmFtZVxuXG4gIFJlYWQuaXNGb2xkZXIgPSAoZm9sZGVyUGF0aCktPlxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgZm9sZGVyUGF0aD8ubGVuZ3RoXG4gICAgbmV3IFByb21pc2UgKHJlc29sdmUpLT5cbiAgICAgIGZzLnN0YXQgZm9sZGVyUGF0aCwgKGVyciwgc3RhdCktPlxuICAgICAgICByZXNvbHZlIHN0YXQ/LmlzRGlyZWN0b3J5KClcblxuICBSZWFkLnN0YXQgPSAocGF0aCktPlxuICAgIG5ldyBQcm9taXNlIChyZXNvbHZlKS0+XG4gICAgICBmcy5zdGF0IHBhdGgsIChlcnIsIHN0YXQpLT5cbiAgICAgICAgcmVzb2x2ZSBzdGF0XG5cbiAgUmVhZC5leGlzdHMgPSAoZmlsZVBhdGgpLT5cbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIGZpbGVQYXRoPy5sZW5ndGhcbiAgICBuZXcgUHJvbWlzZSAocmVzb2x2ZSktPlxuICAgICAgZnMuYWNjZXNzIGZpbGVQYXRoLCAoZXJyKS0+XG4gICAgICAgIHJlc29sdmUgbm90IGVycj9cblxuICBSZWFkLmZpbGUgPSAoZmlsZVBhdGgpLT5cbiAgICB0cnlcbiAgICAgIGZpbGUgPSBmcy5yZWFkRmlsZVN5bmMgZmlsZVBhdGhcbiAgICBjYXRjaFxuICAgICAgbnVsbFxuXG4gIFJlYWQuc2VwID0gcGF0aC5zZXBcbiAgUmVhZC53YXRjaCA9IGZzLndhdGNoXG5cbiAgUmVhZC5wYXRoID0gKC4uLnNlZ3MpLT4gc2Vncy5qb2luIHBhdGguc2VwXG4gIFJlYWQuc3BsaXQgPSAocCktPiBBcnJheS5wdWxsIHAuc3BsaXQocGF0aC5zZXApLCBcIlwiXG4gIFJlYWQubGFzdCA9IChwKS0+IEFycmF5Lmxhc3QgUmVhZC5zcGxpdCBwXG4gIFJlYWQucGFyZW50UGF0aCA9IChwKS0+IFJlYWQucGF0aCAuLi5BcnJheS5idXRMYXN0IFJlYWQuc3BsaXQgcFxuXG4gIE1ha2UgXCJSZWFkXCIsIFJlYWRcblxuXG4jIGxpYi9zaXplLW9uLWRpc2suY29mZmVlXG5UYWtlIFtcIlJlYWRcIl0sIChSZWFkKS0+XG5cbiAgTWFrZS5hc3luYyBcIlNpemVPbkRpc2tcIiwgU2l6ZU9uRGlzayA9IChwYXRoKS0+XG4gICAgbmV3IFByb21pc2UgKHJlc29sdmUpLT5cbiAgICAgIHN0YXRzID0gYXdhaXQgUmVhZC5zdGF0IHBhdGhcbiAgICAgIGlmIG5vdCBzdGF0cz9cbiAgICAgICAgcmVzb2x2ZSAwXG4gICAgICBlbHNlIGlmIG5vdCBzdGF0cy5pc0RpcmVjdG9yeSgpXG4gICAgICAgIHJlc29sdmUgc3RhdHMuc2l6ZVxuICAgICAgZWxzZVxuICAgICAgICB0b3RhbCA9IDBcbiAgICAgICAgY2hpbGRyZW4gPSBhd2FpdCBSZWFkLmFzeW5jIHBhdGhcbiAgICAgICAgc2l6ZXMgPSBmb3IgY2hpbGROYW1lIGluIGNoaWxkcmVuXG4gICAgICAgICAgU2l6ZU9uRGlzayBSZWFkLnBhdGggcGF0aCwgY2hpbGROYW1lXG4gICAgICAgIGZvciBzaXplIGluIHNpemVzXG4gICAgICAgICAgdG90YWwgKz0gYXdhaXQgc2l6ZVxuICAgICAgICByZXNvbHZlIHRvdGFsXG5cbiAgU2l6ZU9uRGlzay5wcmV0dHkgPSAocGF0aCktPlxuICAgIHNpemUgPSBhd2FpdCBTaXplT25EaXNrIHBhdGhcbiAgICBsZW4gPSBzaXplLnRvU3RyaW5nKCkubGVuZ3RoXG4gICAgY29uc29sZS5sb2cgc2l6ZS8xMDAwXG4gICAgY29uc29sZS5sb2cgbGVuXG5cbiAgICBzd2l0Y2hcbiAgICAgIHdoZW4gbGVuIDwgM1xuICAgICAgICBzdWZmaXggPSBcIkJcIlxuICAgICAgICBleHAgPSAwXG4gICAgICB3aGVuIGxlbiA8IDdcbiAgICAgICAgc3VmZml4ID0gXCJLQlwiXG4gICAgICAgIGV4cCA9IDFcbiAgICAgIHdoZW4gbGVuIDwgMTFcbiAgICAgICAgc3VmZml4ID0gXCJNQlwiXG4gICAgICAgIGV4cCA9IDJcbiAgICAgIGVsc2VcbiAgICAgICAgc3VmZml4ID0gXCJHQlwiXG4gICAgICAgIGV4cCA9IDNcblxuICAgIChzaXplIC8gTWF0aC5wb3coMTAwMCwgZXhwKSkudG9GaXhlZCgxKSArIFwiIFwiICsgc3VmZml4XG5cblxuIyBsaWIvc3RhdGUuY29mZmVlXG5UYWtlIFtdLCAoKS0+XG5cbiAgc3RhdGUgPSB7fVxuICBzdWJzY3JpcHRpb25zID0ge19jYnM6W119XG5cbiAgZ2V0QXQgPSAobm9kZSwgcGF0aCktPlxuICAgIHJldHVybiBbe1wiXCI6bm9kZX0sIFwiXCJdIGlmIHBhdGggaXMgXCJcIlxuICAgIHBhcnRzID0gcGF0aC5zcGxpdCBcIi5cIlxuICAgIGsgPSBwYXJ0cy5wb3AoKVxuICAgIGZvciBwYXJ0IGluIHBhcnRzXG4gICAgICBub2RlID0gbm9kZVtwYXJ0XSA/PSB7fVxuICAgIFtub2RlLCBrXVxuXG5cbiAgTWFrZS5hc3luYyBcIlN0YXRlXCIsIFN0YXRlID0gKHBhdGggPSBcIlwiLCB2LCB7aW1tdXRhYmxlID0gZmFsc2V9ID0ge30pLT5cbiAgICBbbm9kZSwga10gPSBnZXRBdCBzdGF0ZSwgcGF0aFxuXG4gICAgcmV0dXJuIG5vZGVba10gaWYgdiBpcyB1bmRlZmluZWQgIyBKdXN0IGEgcmVhZFxuXG4gICAgIyBJdCdzIG5vdCBzYWZlIHRvIHRha2Ugc29tZXRoaW5nIG91dCBvZiBTdGF0ZSwgbXV0YXRlIGl0LCBhbmQgY29tbWl0IGl0IGFnYWluLlxuICAgICMgVGhlIGltbXV0YWJsZSBvcHRpb24gdGVsbHMgdXMgdGhlIGNhbGxlciBwcm9taXNlcyB0aGV5J3JlIG5vdCBkb2luZyB0aGF0LlxuICAgICMgT3RoZXJ3aXNlLCB3ZSBjbG9uZSB2YWx1ZXMgYmVmb3JlIHJlYWRpbmcgb3Igd3JpdGluZyB0aGVtLlxuICAgIHYgPSBGdW5jdGlvbi5jbG9uZSB2IHVubGVzcyBpbW11dGFibGVcblxuICAgIGlmIG5vdCBpbW11dGFibGUgYW5kIHYgaXMgbm9kZVtrXSBhbmQgKE9iamVjdC50eXBlKHYpIG9yIEFycmF5LnR5cGUodikpXG4gICAgICB0aHJvdyBcIkRpZCB5b3UgdGFrZSBzb21ldGhpbmcgb3V0IG9mIFN0YXRlLCBtdXRhdGUgaXQsIGFuZCBjb21taXQgaXQgYWdhaW4/XCJcblxuICAgIHRocm93IEVycm9yIFwiWW91J3JlIG5vdCBhbGxvd2VkIHRvIHNldCB0aGUgU3RhdGUgcm9vdFwiIGlmIHBhdGggaXMgXCJcIlxuXG4gICAgb2xkID0gbm9kZVtrXVxuXG4gICAgaWYgdj8gdGhlbiBub2RlW2tdID0gdiBlbHNlIGRlbGV0ZSBub2RlW2tdXG5cbiAgICBpZiBGdW5jdGlvbi5ub3RFcXVpdmFsZW50IHYsIG9sZFxuICAgICAgcXVldWVNaWNyb3Rhc2sgKCktPlxuICAgICAgICBsb2NhbE5vdGlmeSBwYXRoLCB2XG5cbiAgICByZXR1cm4gdlxuXG4gIGNvbmRpdGlvbmFsU2V0ID0gKHBhdGgsIHYsIHByZWQpLT5cbiAgICBbbm9kZSwga10gPSBnZXRBdCBzdGF0ZSwgcGF0aFxuICAgIGRvU2V0ID0gcHJlZCBub2RlW2tdLCB2XG4gICAgU3RhdGUgcGF0aCwgdiBpZiBkb1NldFxuICAgIHJldHVybiBkb1NldFxuXG4gICMgVGhlc2UgYXJlIHVzZWZ1bCBiZWNhdXNlIHRoZXkgcmV0dXJuIHRydWUgaWYgYSBjaGFuZ2Ugd2FzIG1hZGVcbiAgU3RhdGUuY2hhbmdlID0gKHBhdGgsIHYpLT4gY29uZGl0aW9uYWxTZXQgcGF0aCwgdiwgRnVuY3Rpb24ubm90RXF1aXZhbGVudFxuICBTdGF0ZS5kZWZhdWx0ID0gKHBhdGgsIHYpLT4gY29uZGl0aW9uYWxTZXQgcGF0aCwgdiwgRnVuY3Rpb24ubm90RXhpc3RzXG5cbiAgIyBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGl0IHJlZHVjZXMgdGhlIG5lZWQgdG8gdXBkYXRlIFN0YXRlIGluIGEgbG9vcCxcbiAgIyB3aGljaCB0cmlnZ2VycyBhIGxvdCBvZiAocG9zc2libHkgcG9pbnRsZXNzKSBub3RpZmljYXRpb25zLlxuICAjIFJlbWluZGVyIHRoYXQgT2JqZWN0Lm1lcmdlIGRvZXNuJ3QgaGFuZGxlIGFycmF5cywgc28gbWF5YmVcbiAgIyBsaW1pdCB0aGUgdXNlIG9mIHRoaXMgZnVuY3Rpb24gdG8gcHJpbWl0aXZlcyAoc2luY2UgaXQgaW1wbGllcyBpbW11dGFibGUpLlxuICBTdGF0ZS5tZXJnZSA9IChwYXRoLCB2KS0+IFN0YXRlIHBhdGgsIChPYmplY3QubWVyZ2UgdiwgU3RhdGUgcGF0aCksIGltbXV0YWJsZTogdHJ1ZVxuXG4gICMgVGhlc2UgYXJlIHVzZWZ1bCBiZWNhdXNlIGl0IG9mZmVycyBhIG5pY2Ugc3ludGF4IGZvciB1cGRhdGluZyBleGlzdGluZyB2YWx1ZXMgaW4gU3RhdGUsXG4gICMgd2l0aCBzdXBwb3J0IGZvciBhc3luYywgZWl0aGVyIG11dGFibHkgb3IgaW1tdXRhYmx5LlxuICBTdGF0ZS51cGRhdGUgPSAocGF0aCwgZm4pLT4gU3RhdGUgcGF0aCwgKGF3YWl0IGZuIFN0YXRlIHBhdGgpLCBpbW11dGFibGU6IHRydWVcbiAgU3RhdGUubXV0YXRlID0gKHBhdGgsIGZuKS0+IFN0YXRlLmNsb25lIHBhdGgsIChhd2FpdCBmbiBTdGF0ZSBwYXRoKSwgaW1tdXRhYmxlOiB0cnVlXG5cbiAgIyBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIHJlYWRpbmcgc29tZXRoaW5nIGZyb20gU3RhdGUgdGhhdCBpcyBwcmUtY2xvbmVkXG4gICMgKGlmIG5lY2Vzc2FyeSkgdG8gYXZvaWQgbXV0YWJpbGl0eSBpc3N1ZXMuXG4gIFN0YXRlLmNsb25lID0gKHBhdGgpLT4gRnVuY3Rpb24uY2xvbmUgU3RhdGUgcGF0aFxuXG4gIFN0YXRlLnN1YnNjcmliZSA9ICguLi5bcGF0aCA9IFwiXCIsIHJ1bk5vdyA9IHRydWUsIHdlYWsgPSBmYWxzZV0sIGNiKS0+XG4gICAgdGhyb3cgXCJJbnZhbGlkIHN1YnNjcmliZSBwYXRoXCIgdW5sZXNzIFN0cmluZy50eXBlIHBhdGggIyBBdm9pZCBlcnJvcnMgaWYgeW91IHRyeSBzYXkgc3Vic2NyaWJlKHJ1bk5vdywgY2IpXG4gICAgW25vZGUsIGtdID0gZ2V0QXQgc3Vic2NyaXB0aW9ucywgcGF0aFxuICAgICgobm9kZVtrXSA/PSB7fSkuX2NicyA/PSBbXSkucHVzaCBjYlxuICAgIGNiLl9zdGF0ZV93ZWFrID0gd2VhayAjIC4uLiB0aGlzIGlzIGZpbmUg8J+QleKYle+4j/CflKVcbiAgICBjYiBTdGF0ZSBwYXRoIGlmIHJ1bk5vd1xuXG4gIFN0YXRlLnVuc3Vic2NyaWJlID0gKC4uLltwYXRoID0gXCJcIl0sIGNiKS0+XG4gICAgW25vZGUsIGtdID0gZ2V0QXQgc3Vic2NyaXB0aW9ucywgcGF0aFxuICAgIHRocm93IEVycm9yIFwiVW5zdWJzY3JpYmUgZmFpbGVkXCIgdW5sZXNzIGNiIGluIG5vZGVba10uX2Nic1xuICAgIEFycmF5LnB1bGwgbm9kZVtrXS5fY2JzLCBjYlxuICAgIG51bGxcblxuICBsb2NhbE5vdGlmeSA9IChwYXRoLCB2KS0+XG4gICAgW25vZGUsIGtdID0gZ2V0QXQgc3Vic2NyaXB0aW9ucywgcGF0aFxuICAgIHJ1bkNic1dpdGhpbiBub2RlW2tdLCB2XG4gICAgcnVuQ2JzIG5vZGVba10sIHYsIHZcbiAgICBjaGFuZ2VzID0gcnVuQ2JzQWJvdmUgcGF0aCwgdlxuICAgIHJ1bkNicyBzdWJzY3JpcHRpb25zLCBzdGF0ZSwgY2hhbmdlc1xuXG4gIHJ1bkNic1dpdGhpbiA9IChwYXJlbnQsIHYpLT5cbiAgICByZXR1cm4gdW5sZXNzIE9iamVjdC50eXBlIHBhcmVudFxuICAgIGZvciBrLCBjaGlsZCBvZiBwYXJlbnQgd2hlbiBrIGlzbnQgXCJfY2JzXCJcbiAgICAgIF92ID0gdj9ba11cbiAgICAgIHJ1bkNic1dpdGhpbiBjaGlsZCwgX3ZcbiAgICAgIHJ1bkNicyBjaGlsZCwgX3YsIF92XG4gICAgbnVsbFxuXG4gIHJ1bkNic0Fib3ZlID0gKHBhdGgsIGNoYW5nZXMpLT5cbiAgICBwYXJ0cyA9IHBhdGguc3BsaXQgXCIuXCJcbiAgICBwID0gcGFydHMucG9wKClcbiAgICBjaGFuZ2VzQWJvdmUgPSB7fVxuICAgIGNoYW5nZXNBYm92ZVtwXSA9IGNoYW5nZXNcbiAgICByZXR1cm4gY2hhbmdlc0Fib3ZlIHVubGVzcyBwYXJ0cy5sZW5ndGggPiAwXG4gICAgcGF0aEFib3ZlID0gcGFydHMuam9pbiBcIi5cIlxuICAgIFtub2RlLCBrXSA9IGdldEF0IHN1YnNjcmlwdGlvbnMsIHBhdGhBYm92ZVxuICAgIHJ1bkNicyBub2RlW2tdLCBTdGF0ZShwYXRoQWJvdmUpLCBjaGFuZ2VzQWJvdmVcbiAgICBydW5DYnNBYm92ZSBwYXRoQWJvdmUsIGNoYW5nZXNBYm92ZVxuXG4gIHJ1bkNicyA9IChub2RlLCB2LCBjaGFuZ2VkKS0+XG4gICAgaWYgbm9kZT8uX2Nic1xuICAgICAgZGVhZCA9IFtdXG4gICAgICBmb3IgY2IgaW4gbm9kZS5fY2JzXG4gICAgICAgIGlmIGNiLl9zdGF0ZV93ZWFrIGFuZCBub3Qgdj9cbiAgICAgICAgICBkZWFkLnB1c2ggY2JcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNiIHYsIGNoYW5nZWRcbiAgICAgIEFycmF5LnB1bGwgbm9kZS5fY2JzLCBjYiBmb3IgY2IgaW4gZGVhZFxuICAgIG51bGxcblxuXG4jIGxpYi93cml0ZS5jb2ZmZWVcblRha2UgW1wiRW52XCIsIFwiTG9nXCIsIFwiUmVhZFwiXSwgKEVudiwgTG9nLCBSZWFkKS0+XG4gIGZzID0gcmVxdWlyZSBcImZzXCJcblxuICB2YWxpZFBhdGggPSAodiktPlxuICAgIHZhbGlkID0gdHJ1ZVxuICAgIHYgPSB2LnJlcGxhY2UgL15bQS1aXTovLCBcIlwiICMgSWdub3JlIHRoZSBkcml2ZSBsZXR0ZXIgb24gV2luZG93cyBcbiAgICB2YWxpZCA9IGZhbHNlIGlmIC0xIGlzbnQgdi5zZWFyY2ggL1s8Pjo7LD9cIip8XS8gIyBFeGNsdWRlIG5hbWVzIHdlIHdvbid0IGJlIGFibGUgdG8gcm91bmR0cmlwXG4gICAgaWYgbm90IHZhbGlkIHRoZW4gTG9nLmVyciBcIiN7dn0gaXMgbm90IGEgdmFsaWQgZmlsZSBwYXRoXCJcbiAgICByZXR1cm4gdmFsaWRcblxuXG4gIE1ha2UuYXN5bmMgXCJXcml0ZVwiLCBXcml0ZSA9ICgpLT5cbiAgICB0aHJvdyBcIk5vdCBJbXBsZW1lbnRlZFwiXG5cbiAgV3JpdGUubG9nZ2luZyA9IHRydWVcblxuICBXcml0ZS5zeW5jID0ge31cbiAgV3JpdGUuYXN5bmMgPSB7fVxuXG4gIE1lbW9yeSA9IG51bGxcblxuICBsb2dXcml0ZSA9IChmbiwgcCwgb3B0cyA9IHt9KS0+XG4gICAgcmV0dXJuIGlmIG9wdHMucXVpZXRcbiAgICByZXR1cm4gdW5sZXNzIFdyaXRlLmxvZ2dpbmdcbiAgICBpZiBNZW1vcnkgPz0gVGFrZSBcIk1lbW9yeVwiXG4gICAgICBwID0gcC5yZXBsYWNlIG5ldyBSZWdFeHAoTWVtb3J5KFwiYXNzZXRzRm9sZGVyXCIpICsgUmVhZC5zZXAsIFwiZ1wiKSwgXCJcIiB1bmxlc3MgcCBpcyBNZW1vcnkoXCJhc3NldHNGb2xkZXJcIilcbiAgICAgIHAgPSBwLnJlcGxhY2UgbmV3IFJlZ0V4cChNZW1vcnkoXCJkYXRhRm9sZGVyXCIpICsgUmVhZC5zZXAsIFwiZ1wiKSwgXCJcIiB1bmxlc3MgcCBpcyBNZW1vcnkoXCJkYXRhRm9sZGVyXCIpXG4gICAgcCA9IHAucmVwbGFjZSBuZXcgUmVnRXhwKEVudi5ob21lICsgUmVhZC5zZXAsIFwiZ1wiKSwgXCJcIiB1bmxlc3MgcCBpcyBFbnYuaG9tZVxuICAgIExvZyBcIldSSVRFICN7Zm59ICN7cH1cIlxuXG4gIFdyaXRlLnN5bmMuZmlsZSA9IChwYXRoLCBkYXRhLCBvcHRzKS0+XG4gICAgaWYgdmFsaWQgPSB2YWxpZFBhdGggcGF0aFxuICAgICAgbG9nV3JpdGUgXCJmaWxlXCIsIHBhdGgsIG9wdHNcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMgcGF0aCwgZGF0YVxuICAgIHJldHVybiB2YWxpZFxuXG4gIFdyaXRlLnN5bmMubWtkaXIgPSAocGF0aCwgb3B0cyktPlxuICAgIHJldHVybiB0cnVlIGlmIGZzLmV4aXN0c1N5bmMgcGF0aFxuICAgIGlmIHZhbGlkID0gdmFsaWRQYXRoIHBhdGhcbiAgICAgIGxvZ1dyaXRlIFwibWtkaXJcIiwgcGF0aCwgb3B0c1xuICAgICAgZnMubWtkaXJTeW5jIHBhdGgsIHJlY3Vyc2l2ZTogdHJ1ZVxuICAgIHJldHVybiB2YWxpZFxuXG4gIFdyaXRlLnN5bmMucmVuYW1lID0gKHBhdGgsIG5ld05hbWUsIG9wdHMpLT5cbiAgICBuZXdQYXRoID0gUmVhZC5zZXAgKyBSZWFkLnBhdGggUmVhZC5wYXJlbnRQYXRoKHBhdGgpLCBuZXdOYW1lXG4gICAgcmV0dXJuIHRydWUgaWYgcGF0aCBpcyBuZXdQYXRoXG4gICAgaWYgdmFsaWQgPSB2YWxpZFBhdGgocGF0aCkgYW5kIHZhbGlkUGF0aChuZXdQYXRoKVxuICAgICAgbG9nV3JpdGUgXCJyZW5hbWVcIiwgXCIje3BhdGh9IC0+ICN7bmV3UGF0aH1cIiwgb3B0c1xuICAgICAgZnMucmVuYW1lU3luYyBwYXRoLCBuZXdQYXRoXG4gICAgcmV0dXJuIHZhbGlkXG5cbiAgV3JpdGUuc3luYy5ybSA9IChwYXRoLCBvcHRzKS0+XG4gICAgcmV0dXJuIHRydWUgaWYgbm90IGZzLmV4aXN0c1N5bmMgcGF0aFxuICAgIGlmIHZhbGlkID0gdmFsaWRQYXRoIHBhdGhcbiAgICAgIGxvZ1dyaXRlIFwicm1cIiwgcGF0aCwgb3B0c1xuICAgICAgZnMucm1TeW5jIHBhdGgsIHJlY3Vyc2l2ZTogdHJ1ZVxuICAgIHJldHVybiB2YWxpZFxuXG4gIFdyaXRlLnN5bmMuY29weUZpbGUgPSAoc3JjLCBkZXN0LCBvcHRzKS0+XG4gICAgaWYgdmFsaWQgPSB2YWxpZFBhdGgoc3JjKSBhbmQgdmFsaWRQYXRoKGRlc3QpXG4gICAgICBsb2dXcml0ZSBcImNvcHlGaWxlXCIsIFwiI3tzcmN9IC0+ICN7ZGVzdH1cIiwgb3B0c1xuICAgICAgZnMuY29weUZpbGVTeW5jIHNyYywgZGVzdFxuICAgIHJldHVybiB2YWxpZFxuXG4gIFdyaXRlLnN5bmMuanNvbiA9IChwYXRoLCBkYXRhLCBvcHRzKS0+XG4gICAgV3JpdGUuc3luYy5maWxlIHBhdGgsIEpTT04uc3RyaW5naWZ5KGRhdGEpLCBvcHRzXG5cbiAgV3JpdGUuc3luYy5hcnJheSA9IChwYXRoLCBhcnIsIG9wdHMpLT5cbiAgICBjdXJyZW50ID0gUmVhZCBwYXRoXG4gICAgY3VycmVudCA/PSBbXVxuICAgIHJldHVybiBpZiBBcnJheS5lcXVhbCBhcnIsIGN1cnJlbnRcbiAgICAjIFJlbW92ZSBhbnl0aGluZyB0aGF0J3MgaW4gdGhlIGZvbGRlciBidXQgbm90IGluIG91ciBuZXcgYXJyYXlcbiAgICBXcml0ZS5zeW5jLnJtIFJlYWQucGF0aChwYXRoLCB2KSwgb3B0cyBmb3IgdiBpbiBjdXJyZW50IHdoZW4gdiBub3QgaW4gYXJyXG4gICAgIyBTYXZlIGFueXRoaW5nIHRoYXQncyBpbiBvdXIgbmV3IGFycmF5IGJ1dCBub3QgaW4gdGhlIGZvbGRlclxuICAgIFdyaXRlLnN5bmMubWtkaXIgUmVhZC5wYXRoKHBhdGgsIHYpLCBvcHRzIGZvciB2IGluIGFyciB3aGVuIHYgbm90IGluIGN1cnJlbnRcbiAgICBudWxsXG5cblxuICBXcml0ZS5hc3luYy5jb3B5SW50byA9IChzcmMsIGRlc3RGb2xkZXIsIG9wdHMpLT5cbiAgICBzcmNOYW1lID0gUmVhZC5sYXN0IHNyY1xuICAgIGlmIGF3YWl0IFJlYWQuaXNGb2xkZXIgc3JjXG4gICAgICBjaGlsZERlc3RGb2xkZXIgPSBSZWFkLnBhdGggZGVzdEZvbGRlciwgc3JjTmFtZVxuICAgICAgV3JpdGUuc3luYy5ta2RpciBjaGlsZERlc3RGb2xkZXIsIG9wdHNcbiAgICAgIHZhbGlkID0gdHJ1ZVxuICAgICAgZm9yIGl0ZW0gaW4gUmVhZCBzcmNcbiAgICAgICAgX3ZhbGlkID0gV3JpdGUuYXN5bmMuY29weUludG8gUmVhZC5wYXRoKHNyYywgaXRlbSksIGNoaWxkRGVzdEZvbGRlciwgb3B0c1xuICAgICAgICB2YWxpZCAmJj0gX3ZhbGlkXG4gICAgICByZXR1cm4gdmFsaWRcbiAgICBlbHNlXG4gICAgICBXcml0ZS5zeW5jLmNvcHlGaWxlIHNyYywgUmVhZC5wYXRoKGRlc3RGb2xkZXIsIHNyY05hbWUpLCBvcHRzXG5cblxuIyBtYWluL2NvZmZlZS9kYi5jb2ZmZWVcblRha2UgW1wiV2luZG93XCIsIFwiREJXaW5kb3dSZWFkeVwiXSwgKFdpbmRvdyktPlxuXG4gIE1ha2UgXCJEQlwiLCBEQiA9XG4gICAgc2VuZDogKGZuLCAuLi5hcmdzKS0+IFdpbmRvdy5nZXREQigpLndlYkNvbnRlbnRzLnNlbmQgXCJtYWluUG9ydFwiLCBmbiwgLi4uYXJnc1xuXG5cbiMgbWFpbi9jb2ZmZWUvZW52LmNvZmZlZVxuVGFrZSBbXSwgKCktPlxuICB7IGFwcCB9ID0gcmVxdWlyZSBcImVsZWN0cm9uXCJcbiAgY2hpbGRQcm9jZXNzID0gcmVxdWlyZSBcImNoaWxkX3Byb2Nlc3NcIlxuICBvcyA9IHJlcXVpcmUgXCJvc1wiXG4gIHBhdGggPSByZXF1aXJlIFwicGF0aFwiXG5cbiAgRW52ID1cbiAgICBpc0Rldjogbm90IGFwcC5pc1BhY2thZ2VkXG4gICAgaXNNYWM6IHByb2Nlc3MucGxhdGZvcm0gaXMgXCJkYXJ3aW5cIlxuICAgIGlzRGVmOiBwcm9jZXNzLmRlZmF1bHRBcHBcbiAgICBpc01haW46IHRydWVcbiAgICBpc1JlbmRlcjogZmFsc2VcbiAgICB1c2VyRGF0YTogYXBwLmdldFBhdGggXCJ1c2VyRGF0YVwiXG4gICAgaG9tZTogYXBwLmdldFBhdGggXCJob21lXCJcbiAgICB2ZXJzaW9uOiBhcHAuZ2V0VmVyc2lvbigpXG4gICAgdmVyc2lvbnM6IHByb2Nlc3MudmVyc2lvbnNcblxuICBFbnYuY29tcHV0ZXJOYW1lID0gaWYgRW52LmlzTWFjIHRoZW4gY2hpbGRQcm9jZXNzLmV4ZWNTeW5jKFwic2N1dGlsIC0tZ2V0IENvbXB1dGVyTmFtZVwiKS50b1N0cmluZygpLnJlcGxhY2UoXCJcXG5cIixcIlwiKSBlbHNlIG9zLmhvc3RuYW1lKClcblxuICAjIFBlcnNpc3RlZCB1c2VyIHByZWZlcmVuY2VzIGFuZCBvdGhlciBwZXItaW5zdGFsbCBhcHAgc3RhdGUgdGhhdCB3aWxsIGJlIG1hbmFnZWQgYnkgdGhlIERCIHdpbmRvd1xuICBFbnYuY29uZmlnUGF0aCA9IHBhdGguam9pbiBFbnYudXNlckRhdGEsIFwiQ29uZmlnLmpzb25cIlxuXG4gICMgUGVyc2lzdGVkIHBlci1pbnN0YWxsIGFwcCBzdGF0ZSB0aGF0IHdpbGwgYmUgbWFuYWdlZCBieSB0aGUgREIgcHJvY2Vzc1xuICBFbnYuZGJTdGF0ZVBhdGggPSBwYXRoLmpvaW4gRW52LnVzZXJEYXRhLCBcIkRCIFN0YXRlLmpzb25cIlxuXG4gICMgUGVyc2lzdGVkIHBlci1pbnN0YWxsIGFwcCBzdGF0ZSB0aGF0IHdpbGwgYmUgbWFuYWdlZCBieSB0aGUgTWFpbiBwcm9jZXNzXG4gIEVudi5tYWluU3RhdGVQYXRoID0gcGF0aC5qb2luIEVudi51c2VyRGF0YSwgXCJNYWluIFN0YXRlLmpzb25cIlxuXG4gICMgV2hlcmUgdGhlIGFzc2V0cyBhbmQgb3RoZXIgZ2xvYmFsbHktc2hhcmVkIGRhdGEgbWFuYWdlZCBieSBIeXBlcnppbmUgd2lsbCBsaXZlXG4gIEVudi5kZWZhdWx0RGF0YUZvbGRlciA9IHBhdGguam9pbiBFbnYuaG9tZSwgXCJEcm9wYm94XCIsIFwiU3lzdGVtXCIsIFwiSHlwZXJ6aW5lXCJcblxuICBNYWtlIFwiRW52XCIsIEVudlxuXG5cbiMgbWFpbi9jb2ZmZWUvaXBjLWhhbmRsZXJzLmNvZmZlZVxuZG8gKCktPlxuICB7IGFwcCwgQnJvd3NlcldpbmRvdywgZGlhbG9nLCBNZXNzYWdlQ2hhbm5lbE1haW4gfSA9IHJlcXVpcmUgXCJlbGVjdHJvblwiXG5cbiAgIyBJbiBhZGRpdG9uIHRvIHRoZSBJUEMgaGFuZGxlcnMgYmVsb3csIHdlIGFsc28gc2V0IHVwIHNvbWUgYXBwIGV2ZW50IGhhbmRsZXJzIGZvciBvdXIgd2luZG93c1xuICBhcHAub24gXCJicm93c2VyLXdpbmRvdy1mb2N1c1wiLCAoZXZlbnQsIHdpbiktPiB3aW4ud2ViQ29udGVudHMuc2VuZCBcImZvY3VzXCJcbiAgYXBwLm9uIFwiYnJvd3Nlci13aW5kb3ctYmx1clwiLCAoZXZlbnQsIHdpbiktPiB3aW4ud2ViQ29udGVudHMuc2VuZCBcImJsdXJcIlxuXG4gIHsgRW52LCBJUEMsIExvZywgUHJpbnRlciwgV2luZG93IH0gPSBhd2FpdCBUYWtlLmFzeW5jIFtcIkVudlwiLCBcIklQQ1wiLCBcIkxvZ1wiLCBcIlByaW50ZXJcIiwgXCJXaW5kb3dcIl1cblxuICBNYWtlIFwiSGFuZGxlcnNcIiwgSGFuZGxlcnMgPSBzZXR1cDogKCktPlxuXG4gICAgIyBTWVNURU1cblxuICAgIElQQy5oYW5kbGUgXCJlbnZcIiwgKCktPlxuICAgICAgRW52XG5cbiAgICBJUEMub24gXCJxdWl0XCIsICh7c2VuZGVyfSwgbXNnKS0+XG4gICAgICBhcHAucXVpdCgpXG5cbiAgICBJUEMub24gXCJmYXRhbFwiLCAoe3NlbmRlcn0sIG1zZyktPlxuICAgICAgZGlhbG9nLnNob3dFcnJvckJveCBcIkZhdGFsIEVycm9yXCIsIG1zZ1xuICAgICAgYXBwLnF1aXQoKVxuXG4gICAgSVBDLm9uIFwiYWxlcnRcIiwgKHtzZW5kZXJ9LCBvcHRzKS0+ICMgU2VlOiBodHRwczovL3d3dy5lbGVjdHJvbmpzLm9yZy9kb2NzL2xhdGVzdC9hcGkvZGlhbG9nLyNkaWFsb2dzaG93bWVzc2FnZWJveGJyb3dzZXJ3aW5kb3ctb3B0aW9uc1xuICAgICAgZGlhbG9nLnNob3dNZXNzYWdlQm94IG9wdHNcblxuICAgIElQQy5vbiBcInByaW50ZXJcIiwgKGUsIC4uLmFyZ3MpLT4gUHJpbnRlciAuLi5hcmdzXG5cbiAgICBJUEMub24gXCJiaW5kLWRiXCIsICh7cHJvY2Vzc0lkLCBzZW5kZXJ9KS0+XG4gICAgICBkYiA9IFdpbmRvdy5nZXREQigpXG4gICAgICB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsTWFpbigpXG4gICAgICBzZW5kZXIucG9zdE1lc3NhZ2UgXCJwb3J0XCIsIHtpZDpwcm9jZXNzSWR9LCBbcG9ydDFdXG4gICAgICBkYi53ZWJDb250ZW50cy5wb3N0TWVzc2FnZSBcInBvcnRcIiwge2lkOnByb2Nlc3NJZH0sIFtwb3J0Ml1cblxuICAgICMgV0lORE9XSU5HXG5cbiAgICBJUEMub24gXCJjbG9zZS13aW5kb3dcIiwgKHtzZW5kZXJ9KS0+XG4gICAgICBCcm93c2VyV2luZG93LmZyb21XZWJDb250ZW50cyhzZW5kZXIpPy5jbG9zZSgpXG5cbiAgICBJUEMub24gXCJzZXQtd2luZG93LXRpdGxlXCIsICh7c2VuZGVyfSwgbmFtZSktPlxuICAgICAgQnJvd3NlcldpbmRvdy5mcm9tV2ViQ29udGVudHMoc2VuZGVyKS5zZXRUaXRsZSBuYW1lXG5cbiAgICBJUEMuaGFuZGxlIFwic2hvd09wZW5EaWFsb2dcIiwgKHtzZW5kZXJ9LCBvcHRzKS0+XG4gICAgICBkaWFsb2cuc2hvd09wZW5EaWFsb2cgQnJvd3NlcldpbmRvdy5mcm9tV2ViQ29udGVudHMoc2VuZGVyKSwgb3B0c1xuXG4gICAgSVBDLm9uIFwib3Blbi1hc3NldFwiLCAoZSwgYXNzZXRJZCktPlxuICAgICAgV2luZG93Lm9wZW4uYXNzZXQgYXNzZXRJZFxuXG4gICAgSVBDLmhhbmRsZSBcIndoYXRzLW15LWFzc2V0XCIsICh7c2VuZGVyfSktPlxuICAgICAgd2luID0gQnJvd3NlcldpbmRvdy5mcm9tV2ViQ29udGVudHMgc2VuZGVyXG4gICAgICBXaW5kb3cuZGF0YVt3aW4ud2ViQ29udGVudHMuaWRdLmFzc2V0SWRcblxuICAgICMgRkVBVFVSRVNcblxuICAgIElQQy5vbiBcImRyYWctZmlsZVwiLCAoe3NlbmRlcn0sIHBhdGgpLT5cbiAgICAgIHNlbmRlci5zdGFydERyYWdcbiAgICAgICAgZmlsZTogcGF0aFxuICAgICAgICBpY29uOiBhd2FpdCBhcHAuZ2V0RmlsZUljb24gcGF0aFxuXG4gICAgSVBDLmhhbmRsZSBcImdldC1maWxlLWljb25cIiwgKHtzZW5kZXJ9LCBwYXRoKS0+XG4gICAgICBpbWcgPSBhd2FpdCBhcHAuZ2V0RmlsZUljb24gcGF0aFxuICAgICAgaW1nLnRvRGF0YVVSTCgpXG5cbiAgICBJUEMub24gXCJwcmV2aWV3LWZpbGVcIiwgKHtzZW5kZXJ9LCBwYXRoKS0+XG4gICAgICB3aW4gPSBCcm93c2VyV2luZG93LmZyb21XZWJDb250ZW50cyBzZW5kZXJcbiAgICAgIHdpbi5wcmV2aWV3RmlsZSBwYXRoXG5cblxuIyBtYWluL2NvZmZlZS9pcGMuY29mZmVlXG5UYWtlIFtcIldpbmRvd1wiXSwgKFdpbmRvdyktPlxuICB7IEJyb3dzZXJXaW5kb3csIGlwY01haW4gfSA9IHJlcXVpcmUgXCJlbGVjdHJvblwiXG5cbiAgTWFrZSBcIklQQ1wiLCBJUEMgPVxuXG4gICAgb246ICAgICAoY2hhbm5lbCwgY2IpLT4gaXBjTWFpbi5vbiAgICAgY2hhbm5lbCwgY2JcbiAgICBvbmNlOiAgIChjaGFubmVsLCBjYiktPiBpcGNNYWluLm9uY2UgICBjaGFubmVsLCBjYlxuICAgIGhhbmRsZTogKGNoYW5uZWwsIGNiKS0+IGlwY01haW4uaGFuZGxlIGNoYW5uZWwsIGNiXG5cbiAgICBwcm9taXNlOlxuICAgICAgb25jZTogKGNoYW5uZWwpLT4gbmV3IFByb21pc2UgKHJlc29sdmUpLT4gaXBjTWFpbi5vbmNlIGNoYW5uZWwsIChlLCBhcmcpLT4gcmVzb2x2ZSBhcmdcbiAgICAgIGhhbmRsZTogKGNoYW5uZWwpLT4gbmV3IFByb21pc2UgKHJlc29sdmUpLT4gaXBjTWFpbi5oYW5kbGUgY2hhbm5lbCwgKGUsIGFyZyktPiByZXNvbHZlIGFyZ1xuXG4gICAgIyBTZW5kIGEgbWVzc2FnZSB0byB0aGUgZnJvbnRtb3N0IHdpbmRvd1xuICAgIHRvRm9jdXNlZFdpbmRvdzogKG1zZyktPlxuICAgICAgd2luID0gQnJvd3NlcldpbmRvdy5nZXRGb2N1c2VkV2luZG93KClcbiAgICAgIHdpbiA/PSBCcm93c2VyV2luZG93LmdldEFsbFdpbmRvd3MoKVswXSAjIE5vIHdpbmRvdyB3YXMgZm9jdXNzZWQsIHNvIGdldCBhbnkgd2luZG93XG4gICAgICB3aW4gPz0gV2luZG93Lm9wZW4uYnJvd3NlcigpICMgTm8gd2luZG93cywgc28gb3BlbiBhIG5ldyB3aW5kb3dcbiAgICAgIHdpbi53ZWJDb250ZW50cy5zZW5kIG1zZ1xuXG5cbiMgbWFpbi9jb2ZmZWUvbWFpbi1zdGF0ZS5jb2ZmZWVcbiMgVGhpcyBmaWxlIG1hbmFnZXMgYW55IHN0YXRlIHRoYXQgbmVlZHMgdG8gYmUgcGVyc2lzdGVkIHRvIHRoZSBsb2NhbCBmaWxlc3lzdGVtXG4jIGp1c3QgZm9yIHRoZSBtYWluIHByb2Nlc3MuXG5cblRha2UgW1wiQURTUlwiLCBcIkVudlwiLCBcIkxvZ1wiLCBcIlJlYWRcIiwgXCJXcml0ZVwiXSwgKEFEU1IsIEVudiwgTG9nLCBSZWFkLCBXcml0ZSktPlxuXG4gICMgVGhpcyBsaXN0cyBhbGwgdGhlIGtleXMgd2UnbGwgcGVyc2lzdCBpbiB0aGUgbWFpbiBzdGF0ZSBmaWxlLCB3aXRoIHRoZWlyIGRlZmF1bHQgdmFsdWVzXG4gIHN0YXRlID1cbiAgICB3aW5kb3dCb3VuZHM6IGFzc2V0OiBbXSwgYnJvd3NlcjogW10sIGRiOiBbXSwgXCJzZXR1cC1hc3Npc3RhbnRcIjogW11cblxuICBzYXZlID0gQURTUiAwLCAyMDAwLCAoKS0+XG4gICAgV3JpdGUuc3luYy5qc29uIEVudi5tYWluU3RhdGVQYXRoLCBzdGF0ZSwgcXVpZXQ6IHRydWVcblxuICBNYWtlLmFzeW5jIFwiTWFpblN0YXRlXCIsIE1haW5TdGF0ZSA9IChrLCB2KS0+XG4gICAgdGhyb3cgRXJyb3IgXCJVbmtub3duIE1haW5TdGF0ZSBrZXk6ICN7a31cIiB1bmxlc3Mgc3RhdGVba10/XG4gICAgaWYgdiBpc250IHVuZGVmaW5lZFxuICAgICAgaWYgdj8gdGhlbiBzdGF0ZVtrXSA9IHYgZWxzZSBkZWxldGUgc3RhdGVba11cbiAgICAgIHNhdmUoKVxuICAgIHN0YXRlW2tdXG5cbiAgTWFpblN0YXRlLmluaXQgPSAoKS0+XG4gICAgdHJ5XG4gICAgICBqc29uID0gUmVhZC5maWxlIEVudi5tYWluU3RhdGVQYXRoXG4gICAgICBkYXRhID0gSlNPTi5wYXJzZSBqc29uXG4gICAgICBmb3IgaywgdiBvZiBkYXRhXG4gICAgICAgICMgT25seSBhY2NlcHQga2V5cyB3ZSBleHBsaWNpdGx5IGxpc3QgaW4gdGhlIGRlZmF1bHRzLlxuICAgICAgICAjIFRoaXMgbGV0cyB1cyBkcm9wIG9ic29sZXRlIHZhbHVlcy5cbiAgICAgICAgaWYgc3RhdGVba10/XG4gICAgICAgICAgc3RhdGVba10gPSB2XG5cblxuIyBtYWluL2NvZmZlZS9tZW51LmNvZmZlZVxuVGFrZSBbXCJFbnZcIiwgXCJJUENcIiwgXCJXaW5kb3dcIl0sIChFbnYsIElQQywgV2luZG93KS0+XG4gIHsgYXBwLCBNZW51LCBzaGVsbCB9ID0gcmVxdWlyZSBcImVsZWN0cm9uXCJcblxuICB0ZW1wbGF0ZSA9IFtdXG5cbiAgaWYgRW52LmlzTWFjIHRoZW4gdGVtcGxhdGUucHVzaFxuICAgIGxhYmVsOiBhcHAubmFtZVxuICAgIHN1Ym1lbnU6IFtcbiAgICAgIHsgcm9sZTogXCJhYm91dFwiIH1cbiAgICAgIHsgdHlwZTogXCJzZXBhcmF0b3JcIiB9XG4gICAgICB7IGxhYmVsOiBcIlByZWZlcmVuY2VzXCIsIGFjY2VsZXJhdG9yOiBcIkNtZE9yQ3RybCssXCIsIGNsaWNrOiBXaW5kb3cub3Blbi5zZXR1cEFzc2lzdGFudCB9XG4gICAgICB7IHR5cGU6IFwic2VwYXJhdG9yXCIgfVxuICAgICAgeyByb2xlOiBcInNlcnZpY2VzXCIgfVxuICAgICAgeyB0eXBlOiBcInNlcGFyYXRvclwiIH1cbiAgICAgIHsgcm9sZTogXCJoaWRlXCIgfVxuICAgICAgeyByb2xlOiBcImhpZGVvdGhlcnNcIiB9XG4gICAgICB7IHJvbGU6IFwidW5oaWRlXCIgfVxuICAgICAgeyB0eXBlOiBcInNlcGFyYXRvclwiIH1cbiAgICAgIHsgcm9sZTogXCJxdWl0XCIgfVxuICAgIF1cblxuICB0ZW1wbGF0ZS5wdXNoXG4gICAgbGFiZWw6IFwiRmlsZVwiXG4gICAgc3VibWVudTogW1xuICAgICAgeyBsYWJlbDogXCJOZXcgQXNzZXRcIiwgYWNjZWxlcmF0b3I6IFwiQ21kT3JDdHJsK05cIiwgY2xpY2s6ICgpLT4gVGFrZShcIkRCXCIpPy5zZW5kIFwiTmV3IEFzc2V0XCIgfVxuICAgICAgeyBsYWJlbDogXCJOZXcgQnJvd3NlciBXaW5kb3dcIiwgYWNjZWxlcmF0b3I6IFwiQ21kT3JDdHJsK1NoaWZ0K05cIiwgY2xpY2s6IFdpbmRvdy5vcGVuLmJyb3dzZXIgfVxuICAgICAgeyB0eXBlOiBcInNlcGFyYXRvclwiIH1cbiAgICAgIHsgbGFiZWw6IFwiU2hvdyBDb25maWcgRmlsZVwiLCBjbGljazogKCktPiBzaGVsbC5zaG93SXRlbUluRm9sZGVyIEVudi5jb25maWdQYXRoIH1cbiAgICAgIHsgdHlwZTogXCJzZXBhcmF0b3JcIiB9XG4gICAgICB7IHJvbGU6IGlmIEVudi5pc01hYyB0aGVuIFwiY2xvc2VcIiBlbHNlIFwicXVpdFwiIH1cbiAgICBdXG5cbiAgdGVtcGxhdGUucHVzaFxuICAgIGxhYmVsOiBcIkVkaXRcIlxuICAgIHN1Ym1lbnU6IFtcbiAgICAgIHsgcm9sZTogXCJ1bmRvXCIgfVxuICAgICAgeyByb2xlOiBcInJlZG9cIiB9XG4gICAgICB7IHR5cGU6IFwic2VwYXJhdG9yXCIgfVxuICAgICAgeyByb2xlOiBcImN1dFwiIH1cbiAgICAgIHsgcm9sZTogXCJjb3B5XCIgfVxuICAgICAgeyByb2xlOiBcInBhc3RlXCIgfVxuICAgICAgeyByb2xlOiBcImRlbGV0ZVwiIH1cbiAgICAgIHsgcm9sZTogXCJzZWxlY3RBbGxcIiB9XG4gICAgICB7IHR5cGU6IFwic2VwYXJhdG9yXCIgfVxuICAgICAgeyBsYWJlbDogXCJGaW5kXCIsIGFjY2VsZXJhdG9yOiBcIkNtZE9yQ3RybCtGXCIsIGNsaWNrOiAoKS0+IElQQy50b0ZvY3VzZWRXaW5kb3cgXCJmaW5kXCIgfVxuICAgICAgeyB0eXBlOiBcInNlcGFyYXRvclwiIH1cbiAgICAgIC4uLihpZiAhRW52LmlzTWFjIHRoZW4gW1xuICAgICAgICB7IHR5cGU6IFwic2VwYXJhdG9yXCIgfVxuICAgICAgICB7IGxhYmVsOiBcIlNldHRpbmdzXCIsIGNsaWNrOiBXaW5kb3cub3Blbi5zZXR1cEFzc2lzdGFudCB9XG4gICAgICBdIGVsc2UgW10pXG4gICAgXVxuXG4gIHRlbXBsYXRlLnB1c2hcbiAgICBsYWJlbDogXCJWaWV3XCJcbiAgICBzdWJtZW51OiBbXG4gICAgICAuLi4oaWYgRW52LmlzRGV2IG9yICFFbnYuaXNNYWMgdGhlbiBbXG4gICAgICAgIHsgcm9sZTogXCJyZWxvYWRcIiB9XG4gICAgICAgIHsgcm9sZTogXCJmb3JjZVJlbG9hZFwiIH1cbiAgICAgICAgeyByb2xlOiBcInRvZ2dsZURldlRvb2xzXCIgfVxuICAgICAgICB7IHR5cGU6IFwic2VwYXJhdG9yXCIgfVxuICAgICAgXSBlbHNlIFtdKVxuICAgICAgeyByb2xlOiBcInRvZ2dsZWZ1bGxzY3JlZW5cIiB9XG4gICAgXVxuXG4gIHRlbXBsYXRlLnB1c2hcbiAgICByb2xlOiBcIndpbmRvd01lbnVcIlxuICAgIHN1Ym1lbnU6IFtcbiAgICAgIHsgcm9sZTogXCJtaW5pbWl6ZVwiIH1cbiAgICAgIHsgcm9sZTogXCJ6b29tXCIgfVxuICAgICAgLi4uKGlmIEVudi5pc01hYyB0aGVuIFtcbiAgICAgICAgeyB0eXBlOiBcInNlcGFyYXRvclwiIH1cbiAgICAgICAgeyByb2xlOiBcImZyb250XCIgfVxuICAgICAgXSBlbHNlIFtcbiAgICAgICAgeyByb2xlOiBcImNsb3NlXCIgfVxuICAgICAgXSlcbiAgICAgIHsgdHlwZTogXCJzZXBhcmF0b3JcIiB9XG4gICAgICB7IGxhYmVsOiBcIlNob3cgRGVidWcgTG9nXCIsIGFjY2VsZXJhdG9yOiBcIkNtZE9yQ3RybCtTaGlmdCtEXCIsIGNsaWNrOiBXaW5kb3cub3Blbi5kYiB9XG4gICAgXVxuXG4gIHRlbXBsYXRlLnB1c2hcbiAgICByb2xlOiBcImhlbHBcIlxuICAgIHN1Ym1lbnU6IFtcbiAgICAgIC4uLihpZiAhRW52LmlzTWFjIHRoZW4gW1xuICAgICAgICB7IHJvbGU6IFwiYWJvdXRcIiB9XG4gICAgICAgIHsgdHlwZTogXCJzZXBhcmF0b3JcIiB9XG4gICAgICBdIGVsc2UgW10pXG4gICAgICB7IGxhYmVsOiBcIkh5cGVyemluZSBHdWlkZVwiLCBjbGljazogKCktPiBzaGVsbC5vcGVuRXh0ZXJuYWwgXCJodHRwczovL2dpdGh1Yi5jb20vY2RpZy9oeXBlcnppbmUvd2lraS9IeXBlcnppbmUtR3VpZGVcIiB9XG4gICAgICB7IHR5cGU6IFwic2VwYXJhdG9yXCIgfVxuICAgICAgeyBsYWJlbDogXCJSZXBvcnQgYSBQcm9ibGVtIG9yIEZlYXR1cmUgUmVxdWVzdOKAplwiLCBjbGljazogKCktPiBzaGVsbC5vcGVuRXh0ZXJuYWwgXCJodHRwczovL2dpdGh1Yi5jb20vY2RpZy9oeXBlcnppbmUvaXNzdWVzL25ld1wiIH1cbiAgICAgIHsgbGFiZWw6IFwiQmVlcCBmb3IgR29vZCBMdWNrXCIsIGNsaWNrOiAoKS0+IHNoZWxsLmJlZXAoKSB9XG4gICAgXVxuXG4gIE1ha2UgXCJNZW51XCIsIHNldHVwOiAoKS0+XG4gICAgTWVudS5zZXRBcHBsaWNhdGlvbk1lbnUgTWVudS5idWlsZEZyb21UZW1wbGF0ZSB0ZW1wbGF0ZVxuXG5cbiMgbWFpbi9jb2ZmZWUvdXBkYXRlcy5jb2ZmZWVcblRha2UgW1wiRW52XCIsIFwiTG9nXCIsIFwiV2luZG93XCJdLCAoRW52LCBMb2csIFdpbmRvdyktPlxuICB7IGFwcCwgYXV0b1VwZGF0ZXIsIGRpYWxvZyB9ID0gcmVxdWlyZSBcImVsZWN0cm9uXCJcblxuICBNYWtlIFwiVXBkYXRlc1wiLCBVcGRhdGVzID1cbiAgICBzZXR1cDogKCktPlxuICAgICAgcmV0dXJuIGlmIEVudi5pc0RldlxuXG4gICAgICBkb0NoZWNrRm9yVXBkYXRlcyA9IHRydWVcblxuICAgICAgYXV0b1VwZGF0ZXIuc2V0RmVlZFVSTFxuICAgICAgICB1cmw6IFwiaHR0cHM6Ly91cGRhdGUuZWxlY3Ryb25qcy5vcmcvY2RpZy9oeXBlcnppbmUvI3twcm9jZXNzLnBsYXRmb3JtfS0je3Byb2Nlc3MuYXJjaH0vI3thcHAuZ2V0VmVyc2lvbigpfVwiXG5cbiAgICAgIGF1dG9VcGRhdGVyLm9uIFwiY2hlY2tpbmctZm9yLXVwZGF0ZVwiLCAoKS0+IExvZyBcIkNoZWNraW5nIGZvciB1cGRhdGVcIlxuICAgICAgYXV0b1VwZGF0ZXIub24gXCJ1cGRhdGUtbm90LWF2YWlsYWJsZVwiLCAoKS0+IExvZyBcIlVwZGF0ZSBub3QgYXZhaWxhYmxlXCJcbiAgICAgIGF1dG9VcGRhdGVyLm9uIFwidXBkYXRlLWF2YWlsYWJsZVwiLCAoKS0+IGRvQ2hlY2tGb3JVcGRhdGVzID0gZmFsc2U7IExvZyBcIkRvd25sb2FkaW5nIHVwZGF0ZS4uLlwiXG4gICAgICBhdXRvVXBkYXRlci5vbiBcImVycm9yXCIsIChlcnIpLT4gZG9DaGVja0ZvclVwZGF0ZXMgPSBmYWxzZTsgTG9nLmVyciBlcnJcblxuICAgICAgYXV0b1VwZGF0ZXIub24gXCJ1cGRhdGUtZG93bmxvYWRlZFwiLCAoZSwgcmVsZWFzZU5vdGVzLCByZWxlYXNlTmFtZSktPlxuICAgICAgICBMb2cgXCJVcGRhdGUgRG93bmxvYWRlZDogI3tyZWxlYXNlTmFtZX1cIlxuICAgICAgICByZXMgPSBhd2FpdCBkaWFsb2cuc2hvd01lc3NhZ2VCb3hcbiAgICAgICAgICB0eXBlOiBcImluZm9cIlxuICAgICAgICAgIGJ1dHRvbnM6IFtcIlJlc3RhcnQgSHlwZXJ6aW5lXCIsIFwiTGF0ZXJcIl1cbiAgICAgICAgICBkZWZhdWx0SWQ6IDBcbiAgICAgICAgICB0aXRsZTogXCJBcHBsaWNhdGlvbiBVcGRhdGVcIlxuICAgICAgICAgIG1lc3NhZ2U6IFwiSHlwZXJ6aW5lIGhhcyBiZWVuIHVwZGF0ZWQgdG8gI3tyZWxlYXNlTmFtZS5yZXBsYWNlKFwidlwiLCBcInZlcnNpb24gXCIpfS5cXG5cXG5Xb3VsZCB5b3UgbGlrZSB0byByZXN0YXJ0IGFuZCB1c2UgdGhlIHVwZGF0ZWQgdmVyc2lvbiBub3c/XCJcbiAgICAgICAgTG9nIFwiUmVzcG9uc2U6ICN7cmVzLnJlc3BvbnNlfVwiXG4gICAgICAgIGlmIHJlcy5yZXNwb25zZSBpcyAwXG4gICAgICAgICAgV2luZG93LmFib3V0VG9RdWl0KClcbiAgICAgICAgICBhdXRvVXBkYXRlci5xdWl0QW5kSW5zdGFsbCgpXG4gICAgICAgICAgTG9nIFwiUXVpdHRpbmdcIlxuXG4gICAgICBjaGVja0ZvclVwZGF0ZXMgPSAoKS0+XG4gICAgICAgIGF1dG9VcGRhdGVyLmNoZWNrRm9yVXBkYXRlcygpIGlmIGRvQ2hlY2tGb3JVcGRhdGVzXG5cbiAgICAgIGNoZWNrRm9yVXBkYXRlcygpXG4gICAgICBzZXRJbnRlcnZhbCBjaGVja0ZvclVwZGF0ZXMsIDYwICogNjAgKiAxMDAwXG5cblxuIyBtYWluL2NvZmZlZS93aW5kb3cuY29mZmVlXG5UYWtlIFtcIkVudlwiLCBcIk1haW5TdGF0ZVwiXSwgKEVudiwgTWFpblN0YXRlKS0+XG4gIHsgYXBwLCBCcm93c2VyV2luZG93LCBkaWFsb2csIG5hdGl2ZVRoZW1lLCBzY3JlZW4gfSA9IHJlcXVpcmUgXCJlbGVjdHJvblwiXG5cbiAgZGVmYXVsdFdpbmRvdyA9XG4gICAgdGl0bGU6IFwiSHlwZXJ6aW5lXCJcbiAgICB0aXRsZUJhclN0eWxlOiBpZiBFbnYuaXNNYWMgdGhlbiBcImhpZGRlbkluc2V0XCIgZWxzZSBcImhpZGRlblwiXG4gICAgdGl0bGVCYXJPdmVybGF5OiB0cnVlXG4gICAgbWluV2lkdGg6IDM0MFxuICAgIG1pbkhlaWdodDogMzQwXG4gICAgd2ViUHJlZmVyZW5jZXM6XG4gICAgICBjb250ZXh0SXNvbGF0aW9uOiBmYWxzZVxuICAgICAgbm9kZUludGVncmF0aW9uOiB0cnVlXG4gICAgICBzY3JvbGxCb3VuY2U6IHRydWVcbiAgICAgIGJhY2tncm91bmRUaHJvdHRsaW5nOiBmYWxzZVxuICAgICAgbmF0aXZlV2luZG93T3BlbjogZmFsc2UgIyBUaGlzIGlzIGNoYW5naW5nIHRvIHRydWUgYnkgZGVmYXVsdCBpbiBFbGVjdHJvbiAxNVxuXG4gIGRlZmF1bHRCb3VuZHMgPVxuICAgIGFzc2V0OiB3aWR0aDogOTYwLCBoZWlnaHQ6IDU0MFxuICAgIGJyb3dzZXI6IHdpZHRoOiAxMjgwLCBoZWlnaHQ6IDcyMFxuICAgIGRiOiB3aWR0aDogNjQwLCBoZWlnaHQ6IDQ4MFxuICAgIFwic2V0dXAtYXNzaXN0YW50XCI6IHdpZHRoOiA0ODAsIGhlaWdodDogNTQwXG5cbiAgd2luZG93SW5kZXhlcyA9IHt9XG4gIHdpbmRvd0JvdW5kcyA9IG51bGxcblxuICB3aW5kb3dEYXRhID0ge31cblxuICAjIFNpbmdsZSBpbnN0YW5jZSB3aW5kb3dzXG4gIGRiID0gbnVsbFxuICBzZXR1cEFzc2lzdGFudCA9IG51bGxcblxuICBhYm91dFRvUXVpdCA9IGZhbHNlXG4gIGFwcC5vbiBcImJlZm9yZS1xdWl0XCIsICgpLT4gYWJvdXRUb1F1aXQgPSB0cnVlXG5cbiAgIyBXZSB3YW50IHRvIHRyYWNrIHdoZXRoZXIgdGhpcyB3aW5kb3cgaXMgdGhlIDFzdCwgMm5kLCAzcmQgKGV0YykgaW5zdGFuY2Ugb2YgaXRzIHR5cGUuXG4gICMgVGhhdCB3YXksIHdoZW5ldmVyIHdlIG9wZW4gYSBuZXcgd2luZG93LCB3ZSBjYW4gYXNzaWduIGl0IHRvIHRoZSBtb3N0IHJlY2VudGx5IHVzZWRcbiAgIyBwb3NpdGlvbiBmb3IgdGhhdCBpbnN0YW5jZSBvZiB0aGF0IHR5cGUgb2Ygd2luZG93LiBDbG9zaW5nIGEgd2luZG93IHdpbGwgbGVhdmUgYSBudWxsXG4gICMgaW4gdGhlIGxpc3Qgb2Ygd2luZG93cywgd2hpY2ggd2lsbCBiZSBmaWxsZWQgbmV4dCB0aW1lIHRoYXQgdHlwZSBvZiB3aW5kb3cgaXMgb3BlbmVkLlxuICAjIEhlcmUsIFwiaW5kZXhcIiBtZWFucyB0aGUgMXN0LCAybmQsIDNyZCAoZXRjKSBpbnN0YW5jZVxuICBnZXROZXh0SW5kZXggPSAodHlwZSktPlxuICAgIGluZGV4ZXMgPSB3aW5kb3dJbmRleGVzW3R5cGVdID89IFtdXG4gICAgaW5kZXggPSBpbmRleGVzLmluZGV4T2YgbnVsbCAjIEZpbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBudWxsLCBpZiBhbnlcbiAgICBpbmRleCA9IGluZGV4ZXMubGVuZ3RoIGlmIGluZGV4IDwgMCAjIE5vIG51bGxzLCBzbyBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgIHdpbmRvd0luZGV4ZXNbdHlwZV1baW5kZXhdID0gdHJ1ZSAjIFNhdmUgdGhhdCB0aGlzIGluZGV4IGlzIG5vdyBiZWluZyB1c2VkXG4gICAgcmV0dXJuIGluZGV4XG5cbiAgY2xlYXJJbmRleCA9ICh0eXBlLCBpbmRleCktPlxuICAgIHdpbmRvd0luZGV4ZXNbdHlwZV1baW5kZXhdID0gbnVsbFxuXG4gIGdldEJvdW5kcyA9ICh0eXBlLCBpbmRleCktPlxuICAgICMgV2UgZG8gc29tZSBzcGVjaWFsIGxvZ2ljIHRvIHBvc2l0aW9uIHdpbmRvd3MgYmFzZWQgb24gdGhlIHBvc2l0aW9uIG9mIHRoZVxuICAgICMgbW91c2UgY3Vyc29yLCB0byBhdm9pZCBmcnVzdHJhdGlvbiB3aGVuIHdvcmtpbmcgd2l0aCBtdWx0aXBsZSBtb25pdG9ycy5cbiAgICAjIFdlIHJlZ2FyZCB0aGUgbW91c2UgdG8gYmUgb2NjdXB5aW5nIHRoZSBcImN1cnJlbnRcIiBtb25pdG9yLlxuICAgIGN1cnNvciA9IHNjcmVlbi5nZXRDdXJzb3JTY3JlZW5Qb2ludCgpXG4gICAgZGlzcGxheSA9IHNjcmVlbi5nZXREaXNwbGF5TmVhcmVzdFBvaW50KGN1cnNvcikuYm91bmRzXG5cbiAgICAjIFRoZSBTZXR1cCBBc3Npc3RhbnQgaXMgaGFuZGxlZCBzcGVjaWFsbHkuXG4gICAgIyBJdCBzaG91bGQgYWx3YXlzIGFwcGVhciBjZW50ZXJlZCBvbiB0aGUgY3VycmVudCBtb25pdG9yLlxuICAgIGlmIHR5cGUgaXMgXCJzZXR1cC1hc3Npc3RhbnRcIlxuICAgICAgYm91bmRzID0gZGVmYXVsdEJvdW5kc1t0eXBlXVxuICAgICAgYm91bmRzLnggPSBkaXNwbGF5LnggKyBkaXNwbGF5LndpZHRoLzIgLSBib3VuZHMud2lkdGgvMlxuICAgICAgYm91bmRzLnkgPSBkaXNwbGF5LnkgKyBkaXNwbGF5LmhlaWdodC8yIC0gYm91bmRzLmhlaWdodC8yXG4gICAgICByZXR1cm4gYm91bmRzXG5cbiAgICAjIEZvciBvdGhlciB0eXBlcyBvZiB3aW5kb3dzLCB3ZSdsbCBmaXJzdCB0cnkgdG8gbG9hZCB0aGVcbiAgICAjIGxhc3QtdXNlZCBwb3NpdGlvbiBmb3IgdGhpcyBpbnN0YW5jZSAoYnkgaW5kZXgpIG9mIHRoaXMgdHlwZSBvZiB3aW5kb3dcbiAgICBib3VuZHMgPSB3aW5kb3dCb3VuZHNbdHlwZV1baW5kZXhdXG4gICAgcmV0dXJuIGJvdW5kcyBpZiBib3VuZHM/XG5cbiAgICAjIFdlIGRvbid0IGhhdmUgYSBsYXN0LXVzZWQgcG9zaXRpb24sIHNvIGxldCdzIHNldCB1cCBhIG5ldyBvbmUuXG4gICAgYm91bmRzID0gZGVmYXVsdEJvdW5kc1t0eXBlXVxuXG4gICAgaWYgdHlwZSBpcyBcImRiXCJcbiAgICAgICMgQnkgZGVmYXVsdCwgdGhlIGRiIHNob3VsZCBhcHBlYXIgaW4gdGhlIHRvcCBsZWZ0IG9mIHRoZSBjdXJyZW50IG1vbml0b3IuXG4gICAgICBib3VuZHMueCA9IGRpc3BsYXkueFxuICAgICAgYm91bmRzLnkgPSBkaXNwbGF5LnlcblxuICAgIGVsc2UgaWYgdHlwZSBpcyBcImJyb3dzZXJcIiBhbmQgaW5kZXggaXMgMFxuICAgICAgIyBUaGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhlIGJyb3dzZXIgd2luZG93IHNob3VsZCBhcHBlYXIgY2VudGVyZWQgb24gdGhlIGN1cnJlbnQgbW9uaXRvci5cbiAgICAgIGJvdW5kcy54ID0gZGlzcGxheS54ICsgZGlzcGxheS53aWR0aC8yIC0gYm91bmRzLndpZHRoLzJcbiAgICAgIGJvdW5kcy55ID0gZGlzcGxheS55ICsgZGlzcGxheS5oZWlnaHQvMiAtIGJvdW5kcy5oZWlnaHQvMlxuXG4gICAgZWxzZVxuICAgICAgIyBBbGwgb3RoZXIgd2luZG93cyBzaG91bGQgYXBwZWFyIG5lYXIgdGhlIG1vdXNlIGN1cnNvci5cbiAgICAgIGJvdW5kcy54ID0gY3Vyc29yLnggLSA3NFxuICAgICAgYm91bmRzLnkgPSBjdXJzb3IueSAtIDE2XG5cbiAgICBib3VuZHNcblxuICBjaGVja0JvdW5kcyA9ICh3aW4pLT5cbiAgICBib3VuZHMgPSB3aW4uZ2V0Qm91bmRzKClcbiAgICBmb3Igb3RoZXJXaW5kb3cgaW4gQnJvd3NlcldpbmRvdy5nZXRBbGxXaW5kb3dzKCkgd2hlbiBvdGhlcldpbmRvdyBpc250IHdpbiBhbmQgb3RoZXJXaW5kb3cgaXNudCBkYlxuICAgICAgb3RoZXJCb3VuZHMgPSBvdGhlcldpbmRvdy5nZXRCb3VuZHMoKVxuICAgICAgaWYgYm91bmRzLnggaXMgb3RoZXJCb3VuZHMueCBhbmQgYm91bmRzLnkgaXMgb3RoZXJCb3VuZHMueVxuICAgICAgICBib3VuZHMueCArPSAyMlxuICAgICAgICBib3VuZHMueSArPSAyMlxuICAgICAgICAjIFdlJ3ZlIG1vdmVkIG91ciB3aW5kb3csIHNvIHdlIG5lZWQgdG8gc3RhcnQgY2hlY2tpbmcgYWxsIG92ZXIgYWdhaW5cbiAgICAgICAgIyBUT0RPOiBUaGVyZSdzIGEgc21hbGwgcmlzayBvZiBhbiBpbmZpbmUgbG9vcCBoZXJlIGlmIHRoZSBiZWhhdmlvdXIgb2ZcbiAgICAgICAgIyBzZXRCb3VuZHMgZm9sbG93ZWQgYnkgZ2V0Qm91bmRzIGNoYW5nZXMgYW5kIHN0YXJ0cyBjbGlwcGluZyB0byB0aGUgd2luZG93LlxuICAgICAgICAjIEFsc28sIHdlIGFyZW4ndCBtYXRjaGluZyBPU1ggYmVoYXZpb3VyLCB3aGljaCBpcyB0byB3cmFwLlxuICAgICAgICB3aW4uc2V0Qm91bmRzIGJvdW5kc1xuICAgICAgICBjaGVja0JvdW5kcyB3aW5cbiAgICAgICAgcmV0dXJuXG5cbiAgdXBkYXRlQm91bmRzID0gKHR5cGUsIGluZGV4LCB3aW4pLT5cbiAgICB3aW5kb3dCb3VuZHNbdHlwZV1baW5kZXhdID0gd2luLmdldEJvdW5kcygpXG4gICAgTWFpblN0YXRlIFwid2luZG93Qm91bmRzXCIsIHdpbmRvd0JvdW5kc1xuXG4gIG5ld1dpbmRvdyA9ICh0eXBlLCB7dG9vbHN9LCBwcm9wcyA9IHt9KS0+XG4gICAgdW5sZXNzIHByb3BzLnNob3cgaXMgZmFsc2VcbiAgICAgIGRlZmVyUGFpbnQgPSB0cnVlXG4gICAgICBwcm9wcy5zaG93ID0gZmFsc2VcbiAgICBpbmRleCA9IGdldE5leHRJbmRleCB0eXBlXG4gICAgYm91bmRzID0gZ2V0Qm91bmRzIHR5cGUsIGluZGV4XG4gICAgYmFja2dyb3VuZCA9IGJhY2tncm91bmRDb2xvcjogaWYgbmF0aXZlVGhlbWUuc2hvdWxkVXNlRGFya0NvbG9ycyB0aGVuIFwiIzFiMWIxYlwiIGVsc2UgXCIjZjJmMmYyXCJcbiAgICB3aW4gPSBuZXcgQnJvd3NlcldpbmRvdyBPYmplY3QuYXNzaWduIHt9LCBkZWZhdWx0V2luZG93LCBib3VuZHMsIGJhY2tncm91bmQsIHByb3BzXG4gICAgY2hlY2tCb3VuZHMgd2luXG4gICAgdXBkYXRlQm91bmRzIHR5cGUsIGluZGV4LCB3aW5cbiAgICB3aW4ubG9hZEZpbGUgXCJ0YXJnZXQvI3t0eXBlfS5odG1sXCJcbiAgICAuY2F0Y2ggKGVyciktPiBkaWFsb2cuc2hvd01lc3NhZ2VCb3ggbWVzc2FnZTogZXJyLm1lc3NhZ2VcbiAgICB3aW4ub25jZSBcInJlYWR5LXRvLXNob3dcIiwgd2luLnNob3cgaWYgZGVmZXJQYWludFxuICAgIHdpbi5vbiBcIm1vdmVcIiwgKGUpLT4gdXBkYXRlQm91bmRzIHR5cGUsIGluZGV4LCB3aW5cbiAgICB3aW4ub24gXCJyZXNpemVcIiwgKGUpLT4gdXBkYXRlQm91bmRzIHR5cGUsIGluZGV4LCB3aW5cbiAgICB3aW4ub24gXCJjbG9zZWRcIiwgKGUpLT4gY2xlYXJJbmRleCB0eXBlLCBpbmRleFxuICAgIHdpblxuXG4gIG9wZW5Bc3NldCA9IChhc3NldElkKS0+XG4gICAgd2luID0gbmV3V2luZG93IFwiYXNzZXRcIiwge3Rvb2xzOiBmYWxzZX0sIHRpdGxlOiBcIkFzc2V0XCJcbiAgICB3aW5kb3dEYXRhW3dpbi53ZWJDb250ZW50cy5pZF0gPSBhc3NldElkOiBhc3NldElkXG4gICAgcmV0dXJuIHdpblxuXG4gIG9wZW5Ccm93c2VyID0gKCktPlxuICAgIG5ld1dpbmRvdyBcImJyb3dzZXJcIiwge3Rvb2xzOiBmYWxzZX0sIHRpdGxlOiBcIkJyb3dzZXJcIiwgbWluV2lkdGg6IDQwMFxuXG4gIG9wZW5EYiA9ICgpLT5cbiAgICBpZiBkYj9cbiAgICAgIGRiLnNob3coKVxuICAgIGVsc2VcbiAgICAgIGRiID0gbmV3V2luZG93IFwiZGJcIiwge3Rvb2xzOiBmYWxzZX0sIHRpdGxlOiBcIkRlYnVnIExvZ1wiLCBzaG93OiBmYWxzZSAjb3IgRW52LmlzRGV2XG4gICAgICBkYi5vbiBcImNsb3NlXCIsIChlKS0+XG4gICAgICAgIHVubGVzcyBhYm91dFRvUXVpdFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgIGRiLmhpZGUoKVxuICAgICAgTWFrZSBcIkRCV2luZG93UmVhZHlcIlxuICAgIHJldHVybiBkYlxuXG4gIG9wZW5TZXR1cEFzc2lzdGFudCA9ICgpLT5cbiAgICBpZiBzZXR1cEFzc2lzdGFudD9cbiAgICAgIHNldHVwQXNzaXN0YW50LnNob3coKVxuICAgIGVsc2VcbiAgICAgIHNldHVwQXNzaXN0YW50ID0gbmV3V2luZG93IFwic2V0dXAtYXNzaXN0YW50XCIsIHt0b29sczogZmFsc2V9LCB0aXRsZTogXCJTZXR1cCBBc3Npc3RhbnRcIiwgcmVzaXphYmxlOiBmYWxzZSwgZnVsbHNjcmVlbmFibGU6IGZhbHNlLCBmcmFtZTogZmFsc2UsIHRpdGxlQmFyU3R5bGU6IFwiZGVmYXVsdFwiXG4gICAgICBzZXR1cEFzc2lzdGFudC5vbiBcImNsb3NlXCIsIChlKS0+IHNldHVwQXNzaXN0YW50ID0gbnVsbFxuICAgIHJldHVybiBzZXR1cEFzc2lzdGFudFxuXG5cblxuICBNYWtlIFwiV2luZG93XCIsIFdpbmRvdyA9XG4gICAgaW5pdDogKCktPlxuICAgICAgd2luZG93Qm91bmRzID0gTWFpblN0YXRlIFwid2luZG93Qm91bmRzXCJcblxuICAgIGRhdGE6IHdpbmRvd0RhdGFcblxuICAgIGdldERCOiAoKS0+XG4gICAgICB0aHJvdyBFcnJvciBcIkRCIHdpbmRvdyBkb2Vzbid0IGV4aXN0XCIgdW5sZXNzIGRiP1xuICAgICAgZGJcblxuICAgIG9wZW46XG4gICAgICBhc3NldDogb3BlbkFzc2V0XG4gICAgICBicm93c2VyOiBvcGVuQnJvd3NlclxuICAgICAgZGI6IG9wZW5EYlxuICAgICAgc2V0dXBBc3Npc3RhbnQ6IG9wZW5TZXR1cEFzc2lzdGFudFxuXG4gICAgYWN0aXZhdGU6ICgpLT5cbiAgICAgIHVubGVzcyBCcm93c2VyV2luZG93LmdldEFsbFdpbmRvd3MoKS5sZW5ndGggPiAxXG4gICAgICAgICMgVE9ETzogSWYgd2UncmUgbm90IGRvbmUgc2V0dXAsIG9wZW4gdGhlIFNldHVwIEFzc2lzdGFudCBpbnN0ZWFkXG4gICAgICAgIFdpbmRvdy5vcGVuLmJyb3dzZXIoKVxuXG4gICAgYWJvdXRUb1F1aXQ6ICgpLT5cbiAgICAgIGFib3V0VG9RdWl0ID0gdHJ1ZVxuXG5cbiMgbWFpbi9tYWluLmNvZmZlZVxuVGFrZSBbXCJFbnZcIiwgXCJIYW5kbGVyc1wiLCBcIklQQ1wiLCBcIkxvZ1wiLCBcIk1lbnVcIiwgXCJNYWluU3RhdGVcIiwgXCJVcGRhdGVzXCIsIFwiV2luZG93XCJdLCAoRW52LCBIYW5kbGVycywgSVBDLCBMb2csIE1lbnUsIE1haW5TdGF0ZSwgVXBkYXRlcywgV2luZG93KS0+XG4gIHsgYXBwIH0gPSByZXF1aXJlIFwiZWxlY3Ryb25cIlxuXG4gICMgV2luZG93cyB3aWxsIGxhdW5jaCB0aGUgYXBwIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhbiB1cGRhdGUuIFdlIGp1c3QgbmVlZCB0byBxdWl0LlxuICByZXR1cm4gYXBwLnF1aXQoKSBpZiByZXF1aXJlIFwiZWxlY3Ryb24tc3F1aXJyZWwtc3RhcnR1cFwiXG5cbiAgIyBKdXN0IGd1ZXNzaW5nIHRoYXQgdGhlc2UgbWlnaHQgYmUgbmljZS4gSGF2ZW4ndCB0ZXN0ZWQgdGhlbSBhdCBhbGwuXG4gIGFwcC5jb21tYW5kTGluZS5hcHBlbmRTd2l0Y2ggXCJkaXNhYmxlLXJlbmRlcmVyLWJhY2tncm91bmRpbmdcIlxuICAjIGFwcC5jb21tYW5kTGluZS5hcHBlbmRTd2l0Y2ggXCJmb3JjZV9sb3dfcG93ZXJfZ3B1XCIgIyBEaXNhYmxlZCB3aGlsZSB3ZSB0ZXN0IG9uIFdpbmRvd3NcblxuICAjIEhlcmUncyBvdXIgY3VzdG9tIGNvbmZpZyBmb3IgdGhlIEFib3V0IGJveFxuICBhcHAuc2V0QWJvdXRQYW5lbE9wdGlvbnNcbiAgICBhcHBsaWNhdGlvbk5hbWU6IFwiSHlwZXJ6aW5lICN7RW52LnZlcnNpb24ucmVwbGFjZSAvKFxcZFxcLlxcZClcXC4wLywgXCIkMVwifVwiXG4gICAgYXBwbGljYXRpb25WZXJzaW9uOiBbXG4gICAgICBcIkVsZWN0cm9uICN7RW52LnZlcnNpb25zLmVsZWN0cm9uLnNwbGl0KFwiLlwiKVswXX1cIlxuICAgICAgXCJDaHJvbWUgI3tFbnYudmVyc2lvbnMuY2hyb21lLnNwbGl0KFwiLlwiKVswXX1cIlxuICAgICAgXCJOb2RlICN7RW52LnZlcnNpb25zLm5vZGUuc3BsaXQoXCIuXCIpWzBdfVwiXG4gICAgXS5qb2luIFwiIOKAoiBcIlxuICAgIHZlcnNpb246IFwiXCJcbiAgICBjb3B5cmlnaHQ6IFwiQ3JlYXRlZCBieSBJdmFuIFJlZXNlXFxuwqkgQ0QgSW5kdXN0cmlhbCBHcm91cCBJbmMuXCJcblxuICAjIFdoaWxlIHdlJ3JlIHdhaXRpbmcgZm9yIGVsZWN0cm9uIHRvIGdldCByZWFkeSwgd2UgY2FuIGxvYWQgb3VyIHBlcnNpc3RlZCBtYWluIHN0YXRlIChpZiBhbnkpLlxuICBNYWluU3RhdGUuaW5pdCgpXG4gIFdpbmRvdy5pbml0KClcblxuICAjIFdhaXQgZm9yIHJlYWR5IGJlZm9yZSBkb2luZyBhbnl0aGluZyBzdWJzdGFudGlhbC5cbiAgYXdhaXQgYXBwLndoZW5SZWFkeSgpXG5cbiAgIyBGb3Igbm93LCB3ZSBqdXN0IHJvbGwgd2l0aCBhIHN0YXRpYyBtZW51IGJhci4gSW4gdGhlIGZ1dHVyZSwgd2UgbWlnaHQgd2FudCB0byBjaGFuZ2UgaXRcbiAgIyBkZXBlbmRpbmcgb24gd2hpY2ggd2luZG93IGlzIGFjdGl2ZS5cbiAgTWVudS5zZXR1cCgpXG5cbiAgIyBUaGVyZSdzIGFib3V0IHRvIGJlIGEgbG90IG9mIGludGVyLXByb2Nlc3MgY29tbXVuaWNhdGlvbiAoSVBDKS4gTXVjaCBvZiBpdCBpcyBnb2luZyB0byBiZVxuICAjIHdpbmRvd3MgYXNraW5nIHRoZSBtYWluIHByb2Nlc3MgdG8gZG8gdGhpbmdzIG9uIHRoZWlyIGJlaGFsZi4gU28gbGV0J3Mgc2V0IHVwIHRob3NlIGhhbmRsZXJzLlxuICBIYW5kbGVycy5zZXR1cCgpXG5cbiAgIyBUaGUgZmlyc3Qgd2luZG93IHdlIG9wZW4gaXMgdGhlIERCLCB3aGljaCBoYW5kbGVzIGFsbCBmaWxlc3lzdGVtIGFjY2VzcyBhbmQgc3RvcmVzIGdsb2JhbCBzdGF0ZS5cbiAgIyBUaGUgaW5zdGFudCB0aGUgREIgb3BlbnMsIGl0J2xsIGJlIHJlYWR5IHRvIHJlY2VpdmUgcG9ydHMgZnJvbSBvdGhlciB3aW5kb3dzIGFuZCBoZWxwIHRoZW0uXG4gICMgVGhlIERCIHdpbmRvdyBzaG91bGQgbmV2ZXIgYmUgcmVsb2FkZWQgb3IgY2xvc2VkLCB1bnRpbCB0aGUgYXBwIHF1aXRzLCBvciBpdCdsbCBsb3NlIGFsbCB0aGUgcG9ydHMsXG4gICMgYW5kIHdlIGhhdmVuJ3QgZGVzaWduZWQgdGhlIG90aGVyIHdpbmRvd3MgdG8gZnVuY3Rpb24gKGV2ZW4gdGVtcG9yYXJpbHkpIHdpdGhvdXQgYSBwb3J0IHRvIHRoZSBkYi5cbiAgIyBXZSBxdWV1ZSBpdCBzbyB0aGF0IHRoZSBiZWxvdyBJUEMgbGlzdGVuZXJzIHdpbGwgYmUgcmVhZHkgd2hlbiB0aGUgd2luZG93IGFjdHVhbGx5IG9wZW5zLlxuICAjIChXZSBjb3VsZCBqdXN0IGNhbGwgdGhlbSBmaXJzdCwgYnV0IGl0IHJlYWRzIGJldHRlciB0aGlzIHdheSlcbiAgcXVldWVNaWNyb3Rhc2sgV2luZG93Lm9wZW4uZGJcblxuICAjIFdoZW4gdGhlIERCIHdpbmRvdyBpcyBvcGVuLCB3ZSBjYW4gYmVnaW4gbG9nZ2luZyBsb3RzIG9mIHN0dWZmXG4gIGF3YWl0IElQQy5wcm9taXNlLm9uY2UgXCJkYi1vcGVuXCJcbiAgTG9nIFwiRW52LnZlcnNpb246ICN7RW52LnZlcnNpb259XCJcbiAgTG9nIFwiRW52LmlzRGV2OiAje0Vudi5pc0Rldn1cIlxuICBMb2cgXCJFbnYuaXNNYWM6ICN7RW52LmlzTWFjfVwiXG4gIExvZyBcIkVudi51c2VyRGF0YTogI3tFbnYudXNlckRhdGF9XCJcbiAgTG9nIFwiRW52LmhvbWU6ICN7RW52LmhvbWV9XCJcblxuICAjIFdoZW4gdGhlIERCIHdpbmRvdyBmaXJzdCB3YWtlcyB1cCwgaXQnbGwgYXR0ZW1wdCB0byBsb2FkIHNhdmVkIHVzZXIgcHJlZmVyZW5jZXMuXG4gICMgSWYgdGhlIERCIGZhaWxzIHRvIGxvYWQgdGhpcyBkYXRhLCB3ZSBuZWVkIHRvIG9wZW4gdGhlIFNldHVwIEFzc2lzdGFudC5cbiAgIyBUaGUgU2V0dXAgQXNzaXN0YW50IHdpbGwgY29sbGVjdCB1c2VyIHByZWZlcmVuY2VzIGFuZCBzYXZlIHRoZW0gdmlhIHRoZSBEQi5cbiAgSVBDLm9uY2UgXCJvcGVuLXNldHVwLWFzc2lzdGFudFwiLCBXaW5kb3cub3Blbi5zZXR1cEFzc2lzdGFudFxuXG4gICMgV2FpdCB1bnRpbCBlaXRoZXIgdGhlIERCIGhhcyBsb2FkZWQgdGhlIHNhdmVkIHByZWZzLCBvciB0aGUgU2V0dXAgQXNzaXN0YW50IGhhcyBmaW5pc2hlZFxuICBhd2FpdCBJUEMucHJvbWlzZS5vbmNlIFwiY29uZmlnLXJlYWR5XCJcblxuICAjIEV2ZXJ5dGhpbmcgaXMgcmVhZHkg4oCUIG9wZW4gYSBicm93c2VyIHdpbmRvdy5cbiAgIyBFdmVudHVhbGx5LCB3ZSBtaWdodCB3YW50IHRvIHJlc3RvcmUgd2hpY2hldmVyIHdpbmRvd3Mgd2VyZSBvcGVuIHdoZW4gd2UgbGFzdCBxdWl0XG4gIFdpbmRvdy5vcGVuLmJyb3dzZXIoKVxuXG4gICMgV2hlbmV2ZXIgd2Ugc3dpdGNoIHRvIHRoZSBhcHAsIGxldCB0aGUgd2luZG93IG1hbmFnZXIga25vdy5cbiAgYXBwLm9uIFwiYWN0aXZhdGVcIiwgV2luZG93LmFjdGl2YXRlXG5cbiAgIyBEb24ndCBtb3ZlIHRoZSBgdW5sZXNzYCBvdXRzaWRlIHRoZSBoYW5kbGVyIOKAlCB3ZSBuZWVkIHRvIHN1YnNjcmliZSB0byB0aGlzIGV2ZW50IHRvIHN0b3AgdGhlIGRlZmF1bHQgYXV0by1jbG9zZSBiZWhhdmlvdXJcbiAgYXBwLm9uIFwid2luZG93LWFsbC1jbG9zZWRcIiwgKCktPiBhcHAucXVpdCgpIHVubGVzcyBFbnYuaXNNYWNcblxuICAjIFNldCB1cCBhdXRvbWF0aWMgdXBkYXRlc1xuICBVcGRhdGVzLnNldHVwKClcbiJdfQ==
//# sourceURL=/Users/admin/Work/hyperzine/temp/main.coffee